<html>
<head>
<title>Include/abstract.h</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.8.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<a name='TOP'><h2><a href='../mains.html'>root</a>/<a href='../files/3349.html'>Include</a>/abstract.h</h2>
<i><font color='green'>/* [&lt;][&gt;][^][v][top]<a href='#BOTTOM'>[bottom]</a><a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
<hr>
<h2><a href='../J/10.html' title='Multiple included from 2 places.'>INCLUDED FROM</a></h2>
<hr>
<pre>
<a name='L1'><font color='darkred'>#ifndef</font> <a href='../S/499.html#L2' title='Defined at 2 in Include/abstract.h.'>Py_ABSTRACTOBJECT_H</a>
<a name='L2'><font color='darkred'>#define</font> <a href='../S/499.html#L1' title='Refered from 1 in Include/abstract.h.'>Py_ABSTRACTOBJECT_H</a>
<a name='L3'><font color='darkred'>#ifdef</font> __cplusplus
<a name='L4'><b>extern</b> "C" <font color='red'>{</font>
<a name='L5'><font color='darkred'>#endif</font>
<a name='L6'>
<a name='L7'><font color='darkred'>#ifdef</font> <a href='../D/2624.html' title='Multiple defined in 30 places.'>PY_SSIZE_T_CLEAN</a>
<a name='L8'><font color='darkred'>#define</font> <a href='../R/3249.html' title='Multiple refered from 68 places.'>PyObject_CallFunction</a> <a href='../S/2775.html#L2209' title='Defined at 2209 in Objects/abstract.c.'>_PyObject_CallFunction_SizeT</a>
<a name='L9'><font color='darkred'>#define</font> <a href='../R/3251.html' title='Multiple refered from 148 places.'>PyObject_CallMethod</a> <a href='../S/2775.html#L2268' title='Defined at 2268 in Objects/abstract.c.'>_PyObject_CallMethod_SizeT</a>
<a name='L10'><font color='darkred'>#endif</font>
<a name='L11'>
<a name='L12'><i><font color='green'>/* Abstract Object Interface (many thanks to Jim Fulton) */</font></i>
<a name='L13'>
<a name='L14'><i><font color='green'>/*</font></i>
<a name='L15'><i><font color='green'>   PROPOSAL: A Generic Python Object Interface for Python C Modules</font></i>
<a name='L16'><i><font color='green'></font></i>
<a name='L17'><i><font color='green'>Problem</font></i>
<a name='L18'><i><font color='green'></font></i>
<a name='L19'><i><font color='green'>  Python modules written in C that must access Python objects must do</font></i>
<a name='L20'><i><font color='green'>  so through routines whose interfaces are described by a set of</font></i>
<a name='L21'><i><font color='green'>  include files.  Unfortunately, these routines vary according to the</font></i>
<a name='L22'><i><font color='green'>  object accessed.  To use these routines, the C programmer must check</font></i>
<a name='L23'><i><font color='green'>  the type of the object being used and must call a routine based on</font></i>
<a name='L24'><i><font color='green'>  the object type.  For example, to access an element of a sequence,</font></i>
<a name='L25'><i><font color='green'>  the programmer must determine whether the sequence is a list or a</font></i>
<a name='L26'><i><font color='green'>  tuple:</font></i>
<a name='L27'><i><font color='green'></font></i>
<a name='L28'><i><font color='green'>    if(is_tupleobject(o))</font></i>
<a name='L29'><i><font color='green'>      e=gettupleitem(o,i)</font></i>
<a name='L30'><i><font color='green'>    else if(is_listitem(o))</font></i>
<a name='L31'><i><font color='green'>      e=getlistitem(o,i)</font></i>
<a name='L32'><i><font color='green'></font></i>
<a name='L33'><i><font color='green'>  If the programmer wants to get an item from another type of object</font></i>
<a name='L34'><i><font color='green'>  that provides sequence behavior, there is no clear way to do it</font></i>
<a name='L35'><i><font color='green'>  correctly.</font></i>
<a name='L36'><i><font color='green'></font></i>
<a name='L37'><i><font color='green'>  The persistent programmer may peruse object.h and find that the</font></i>
<a name='L38'><i><font color='green'>  _typeobject structure provides a means of invoking up to (currently</font></i>
<a name='L39'><i><font color='green'>  about) 41 special operators.  So, for example, a routine can get an</font></i>
<a name='L40'><i><font color='green'>  item from any object that provides sequence behavior. However, to</font></i>
<a name='L41'><i><font color='green'>  use this mechanism, the programmer must make their code dependent on</font></i>
<a name='L42'><i><font color='green'>  the current Python implementation.</font></i>
<a name='L43'><i><font color='green'></font></i>
<a name='L44'><i><font color='green'>  Also, certain semantics, especially memory management semantics, may</font></i>
<a name='L45'><i><font color='green'>  differ by the type of object being used.  Unfortunately, these</font></i>
<a name='L46'><i><font color='green'>  semantics are not clearly described in the current include files.</font></i>
<a name='L47'><i><font color='green'>  An abstract interface providing more consistent semantics is needed.</font></i>
<a name='L48'><i><font color='green'></font></i>
<a name='L49'><i><font color='green'>Proposal</font></i>
<a name='L50'><i><font color='green'></font></i>
<a name='L51'><i><font color='green'>  I propose the creation of a standard interface (with an associated</font></i>
<a name='L52'><i><font color='green'>  library of routines and/or macros) for generically obtaining the</font></i>
<a name='L53'><i><font color='green'>  services of Python objects.  This proposal can be viewed as one</font></i>
<a name='L54'><i><font color='green'>  components of a Python C interface consisting of several components.</font></i>
<a name='L55'><i><font color='green'></font></i>
<a name='L56'><i><font color='green'>  From the viewpoint of C access to Python services, we have (as</font></i>
<a name='L57'><i><font color='green'>  suggested by Guido in off-line discussions):</font></i>
<a name='L58'><i><font color='green'></font></i>
<a name='L59'><i><font color='green'>  - "Very high level layer": two or three functions that let you exec or</font></i>
<a name='L60'><i><font color='green'>    eval arbitrary Python code given as a string in a module whose name is</font></i>
<a name='L61'><i><font color='green'>    given, passing C values in and getting C values out using</font></i>
<a name='L62'><i><font color='green'>    mkvalue/getargs style format strings.  This does not require the user</font></i>
<a name='L63'><i><font color='green'>    to declare any variables of type "PyObject *".  This should be enough</font></i>
<a name='L64'><i><font color='green'>    to write a simple application that gets Python code from the user,</font></i>
<a name='L65'><i><font color='green'>    execs it, and returns the output or errors.  (Error handling must also</font></i>
<a name='L66'><i><font color='green'>    be part of this API.)</font></i>
<a name='L67'><i><font color='green'></font></i>
<a name='L68'><i><font color='green'>  - "Abstract objects layer": which is the subject of this proposal.</font></i>
<a name='L69'><i><font color='green'>    It has many functions operating on objects, and lest you do many</font></i>
<a name='L70'><i><font color='green'>    things from C that you can also write in Python, without going</font></i>
<a name='L71'><i><font color='green'>    through the Python parser.</font></i>
<a name='L72'><i><font color='green'></font></i>
<a name='L73'><i><font color='green'>  - "Concrete objects layer": This is the public type-dependent</font></i>
<a name='L74'><i><font color='green'>    interface provided by the standard built-in types, such as floats,</font></i>
<a name='L75'><i><font color='green'>    strings, and lists.  This interface exists and is currently</font></i>
<a name='L76'><i><font color='green'>    documented by the collection of include files provided with the</font></i>
<a name='L77'><i><font color='green'>    Python distributions.</font></i>
<a name='L78'><i><font color='green'></font></i>
<a name='L79'><i><font color='green'>  From the point of view of Python accessing services provided by C</font></i>
<a name='L80'><i><font color='green'>  modules:</font></i>
<a name='L81'><i><font color='green'></font></i>
<a name='L82'><i><font color='green'>  - "Python module interface": this interface consist of the basic</font></i>
<a name='L83'><i><font color='green'>    routines used to define modules and their members.  Most of the</font></i>
<a name='L84'><i><font color='green'>    current extensions-writing guide deals with this interface.</font></i>
<a name='L85'><i><font color='green'></font></i>
<a name='L86'><i><font color='green'>  - "Built-in object interface": this is the interface that a new</font></i>
<a name='L87'><i><font color='green'>    built-in type must provide and the mechanisms and rules that a</font></i>
<a name='L88'><i><font color='green'>    developer of a new built-in type must use and follow.</font></i>
<a name='L89'><i><font color='green'></font></i>
<a name='L90'><i><font color='green'>  This proposal is a "first-cut" that is intended to spur</font></i>
<a name='L91'><i><font color='green'>  discussion. See especially the lists of notes.</font></i>
<a name='L92'><i><font color='green'></font></i>
<a name='L93'><i><font color='green'>  The Python C object interface will provide four protocols: object,</font></i>
<a name='L94'><i><font color='green'>  numeric, sequence, and mapping.  Each protocol consists of a</font></i>
<a name='L95'><i><font color='green'>  collection of related operations.  If an operation that is not</font></i>
<a name='L96'><i><font color='green'>  provided by a particular type is invoked, then a standard exception,</font></i>
<a name='L97'><i><font color='green'>  NotImplementedError is raised with a operation name as an argument.</font></i>
<a name='L98'><i><font color='green'>  In addition, for convenience this interface defines a set of</font></i>
<a name='L99'><i><font color='green'>  constructors for building objects of built-in types.  This is needed</font></i>
<a name='L100'><i><font color='green'>  so new objects can be returned from C functions that otherwise treat</font></i>
<a name='L101'><i><font color='green'>  objects generically.</font></i>
<a name='L102'><i><font color='green'></font></i>
<a name='L103'><i><font color='green'>Memory Management</font></i>
<a name='L104'><i><font color='green'></font></i>
<a name='L105'><i><font color='green'>  For all of the functions described in this proposal, if a function</font></i>
<a name='L106'><i><font color='green'>  retains a reference to a Python object passed as an argument, then the</font></i>
<a name='L107'><i><font color='green'>  function will increase the reference count of the object.  It is</font></i>
<a name='L108'><i><font color='green'>  unnecessary for the caller to increase the reference count of an</font></i>
<a name='L109'><i><font color='green'>  argument in anticipation of the object's retention.</font></i>
<a name='L110'><i><font color='green'></font></i>
<a name='L111'><i><font color='green'>  All Python objects returned from functions should be treated as new</font></i>
<a name='L112'><i><font color='green'>  objects.  Functions that return objects assume that the caller will</font></i>
<a name='L113'><i><font color='green'>  retain a reference and the reference count of the object has already</font></i>
<a name='L114'><i><font color='green'>  been incremented to account for this fact.  A caller that does not</font></i>
<a name='L115'><i><font color='green'>  retain a reference to an object that is returned from a function</font></i>
<a name='L116'><i><font color='green'>  must decrement the reference count of the object (using</font></i>
<a name='L117'><i><font color='green'>  DECREF(object)) to prevent memory leaks.</font></i>
<a name='L118'><i><font color='green'></font></i>
<a name='L119'><i><font color='green'>  Note that the behavior mentioned here is different from the current</font></i>
<a name='L120'><i><font color='green'>  behavior for some objects (e.g. lists and tuples) when certain</font></i>
<a name='L121'><i><font color='green'>  type-specific routines are called directly (e.g. setlistitem).  The</font></i>
<a name='L122'><i><font color='green'>  proposed abstraction layer will provide a consistent memory</font></i>
<a name='L123'><i><font color='green'>  management interface, correcting for inconsistent behavior for some</font></i>
<a name='L124'><i><font color='green'>  built-in types.</font></i>
<a name='L125'><i><font color='green'></font></i>
<a name='L126'><i><font color='green'>Protocols</font></i>
<a name='L127'><i><font color='green'></font></i>
<a name='L128'><i><font color='green'>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/</font></i>
<a name='L129'>
<a name='L130'><i><font color='green'>/*  Object Protocol: */</font></i>
<a name='L131'>
<a name='L132'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L133'><i><font color='green'></font></i>
<a name='L134'><i><font color='green'>     int PyObject_Print(PyObject *o, FILE *fp, int flags);</font></i>
<a name='L135'><i><font color='green'></font></i>
<a name='L136'><i><font color='green'>     Print an object, o, on file, fp.  Returns -1 on</font></i>
<a name='L137'><i><font color='green'>     error.  The flags argument is used to enable certain printing</font></i>
<a name='L138'><i><font color='green'>     options. The only option currently supported is Py_Print_RAW.</font></i>
<a name='L139'><i><font color='green'></font></i>
<a name='L140'><i><font color='green'>     (What should be said about Py_Print_RAW?)</font></i>
<a name='L141'><i><font color='green'></font></i>
<a name='L142'><i><font color='green'>       */</font></i>
<a name='L143'>
<a name='L144'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L145'><i><font color='green'></font></i>
<a name='L146'><i><font color='green'>     int PyObject_HasAttrString(PyObject *o, char *attr_name);</font></i>
<a name='L147'><i><font color='green'></font></i>
<a name='L148'><i><font color='green'>     Returns 1 if o has the attribute attr_name, and 0 otherwise.</font></i>
<a name='L149'><i><font color='green'>     This is equivalent to the Python expression:</font></i>
<a name='L150'><i><font color='green'>     hasattr(o,attr_name).</font></i>
<a name='L151'><i><font color='green'></font></i>
<a name='L152'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L153'><i><font color='green'></font></i>
<a name='L154'><i><font color='green'>       */</font></i>
<a name='L155'>
<a name='L156'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L157'><i><font color='green'></font></i>
<a name='L158'><i><font color='green'>     PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name);</font></i>
<a name='L159'><i><font color='green'></font></i>
<a name='L160'><i><font color='green'>     Retrieve an attributed named attr_name form object o.</font></i>
<a name='L161'><i><font color='green'>     Returns the attribute value on success, or NULL on failure.</font></i>
<a name='L162'><i><font color='green'>     This is the equivalent of the Python expression: o.attr_name.</font></i>
<a name='L163'><i><font color='green'></font></i>
<a name='L164'><i><font color='green'>       */</font></i>
<a name='L165'>
<a name='L166'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L167'><i><font color='green'></font></i>
<a name='L168'><i><font color='green'>     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);</font></i>
<a name='L169'><i><font color='green'></font></i>
<a name='L170'><i><font color='green'>     Returns 1 if o has the attribute attr_name, and 0 otherwise.</font></i>
<a name='L171'><i><font color='green'>     This is equivalent to the Python expression:</font></i>
<a name='L172'><i><font color='green'>     hasattr(o,attr_name).</font></i>
<a name='L173'><i><font color='green'></font></i>
<a name='L174'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L175'><i><font color='green'></font></i>
<a name='L176'><i><font color='green'>       */</font></i>
<a name='L177'>
<a name='L178'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L179'><i><font color='green'></font></i>
<a name='L180'><i><font color='green'>     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);</font></i>
<a name='L181'><i><font color='green'></font></i>
<a name='L182'><i><font color='green'>     Retrieve an attributed named attr_name form object o.</font></i>
<a name='L183'><i><font color='green'>     Returns the attribute value on success, or NULL on failure.</font></i>
<a name='L184'><i><font color='green'>     This is the equivalent of the Python expression: o.attr_name.</font></i>
<a name='L185'><i><font color='green'></font></i>
<a name='L186'><i><font color='green'>       */</font></i>
<a name='L187'>
<a name='L188'>
<a name='L189'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L190'><i><font color='green'></font></i>
<a name='L191'><i><font color='green'>     int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v);</font></i>
<a name='L192'><i><font color='green'></font></i>
<a name='L193'><i><font color='green'>     Set the value of the attribute named attr_name, for object o,</font></i>
<a name='L194'><i><font color='green'>     to the value, v. Returns -1 on failure.  This is</font></i>
<a name='L195'><i><font color='green'>     the equivalent of the Python statement: o.attr_name=v.</font></i>
<a name='L196'><i><font color='green'></font></i>
<a name='L197'><i><font color='green'>       */</font></i>
<a name='L198'>
<a name='L199'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L200'><i><font color='green'></font></i>
<a name='L201'><i><font color='green'>     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);</font></i>
<a name='L202'><i><font color='green'></font></i>
<a name='L203'><i><font color='green'>     Set the value of the attribute named attr_name, for object o,</font></i>
<a name='L204'><i><font color='green'>     to the value, v. Returns -1 on failure.  This is</font></i>
<a name='L205'><i><font color='green'>     the equivalent of the Python statement: o.attr_name=v.</font></i>
<a name='L206'><i><font color='green'></font></i>
<a name='L207'><i><font color='green'>       */</font></i>
<a name='L208'>
<a name='L209'>     <i><font color='green'>/* implemented as a macro:</font></i>
<a name='L210'><i><font color='green'></font></i>
<a name='L211'><i><font color='green'>     int PyObject_DelAttrString(PyObject *o, char *attr_name);</font></i>
<a name='L212'><i><font color='green'></font></i>
<a name='L213'><i><font color='green'>     Delete attribute named attr_name, for object o. Returns</font></i>
<a name='L214'><i><font color='green'>     -1 on failure.  This is the equivalent of the Python</font></i>
<a name='L215'><i><font color='green'>     statement: del o.attr_name.</font></i>
<a name='L216'><i><font color='green'></font></i>
<a name='L217'><i><font color='green'>       */</font></i>
<a name='L218'><font color='darkred'>#define</font>  <a href='../R/3257.html' title='Multiple refered from 4 places.'>PyObject_DelAttrString</a>(O,<a href='../D/1.html' title='Multiple defined in 18 places.'>A</a>) <a href='../S/2803.html#L806' title='Defined at 806 in Objects/object.c.'>PyObject_SetAttrString</a>((O),(A),<a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>)
<a name='L219'>
<a name='L220'>     <i><font color='green'>/* implemented as a macro:</font></i>
<a name='L221'><i><font color='green'></font></i>
<a name='L222'><i><font color='green'>     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);</font></i>
<a name='L223'><i><font color='green'></font></i>
<a name='L224'><i><font color='green'>     Delete attribute named attr_name, for object o. Returns -1</font></i>
<a name='L225'><i><font color='green'>     on failure.  This is the equivalent of the Python</font></i>
<a name='L226'><i><font color='green'>     statement: del o.attr_name.</font></i>
<a name='L227'><i><font color='green'></font></i>
<a name='L228'><i><font color='green'>       */</font></i>
<a name='L229'><font color='darkred'>#define</font>  PyObject_DelAttr(O,<a href='../D/1.html' title='Multiple defined in 18 places.'>A</a>) <a href='../S/2803.html#L859' title='Defined at 859 in Objects/object.c.'>PyObject_SetAttr</a>((O),(A),<a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>)
<a name='L230'>
<a name='L231'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L232'><i><font color='green'></font></i>
<a name='L233'><i><font color='green'>     PyObject *PyObject_Repr(PyObject *o);</font></i>
<a name='L234'><i><font color='green'></font></i>
<a name='L235'><i><font color='green'>     Compute the string representation of object, o.  Returns the</font></i>
<a name='L236'><i><font color='green'>     string representation on success, NULL on failure.  This is</font></i>
<a name='L237'><i><font color='green'>     the equivalent of the Python expression: repr(o).</font></i>
<a name='L238'><i><font color='green'></font></i>
<a name='L239'><i><font color='green'>     Called by the repr() built-in function.</font></i>
<a name='L240'><i><font color='green'></font></i>
<a name='L241'><i><font color='green'>       */</font></i>
<a name='L242'>
<a name='L243'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L244'><i><font color='green'></font></i>
<a name='L245'><i><font color='green'>     PyObject *PyObject_Str(PyObject *o);</font></i>
<a name='L246'><i><font color='green'></font></i>
<a name='L247'><i><font color='green'>     Compute the string representation of object, o.  Returns the</font></i>
<a name='L248'><i><font color='green'>     string representation on success, NULL on failure.  This is</font></i>
<a name='L249'><i><font color='green'>     the equivalent of the Python expression: str(o).)</font></i>
<a name='L250'><i><font color='green'></font></i>
<a name='L251'><i><font color='green'>     Called by the str() and print() built-in functions.</font></i>
<a name='L252'><i><font color='green'></font></i>
<a name='L253'><i><font color='green'>       */</font></i>
<a name='L254'>
<a name='L255'>       <i><font color='green'>/* Declared elsewhere</font></i>
<a name='L256'><i><font color='green'></font></i>
<a name='L257'><i><font color='green'>     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);</font></i>
<a name='L258'><i><font color='green'></font></i>
<a name='L259'><i><font color='green'>     Determine if the object, o, is callable.  Return 1 if the</font></i>
<a name='L260'><i><font color='green'>     object is callable and 0 otherwise.</font></i>
<a name='L261'><i><font color='green'></font></i>
<a name='L262'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L263'><i><font color='green'>       */</font></i>
<a name='L264'>
<a name='L265'>     <a href='../D/2716.html' title='Multiple defined in 45 places.'>PyAPI_FUNC</a>(PyObject *) PyObject_Call(PyObject *callable_object,
<a name='L266'>                                          PyObject *args, PyObject *kw);
<a name='L267'>
<a name='L268'>       <i><font color='green'>/*</font></i>
<a name='L269'><i><font color='green'>     Call a callable Python object, callable_object, with</font></i>
<a name='L270'><i><font color='green'>     arguments and keywords arguments.  The 'args' argument can not be</font></i>
<a name='L271'><i><font color='green'>     NULL, but the 'kw' argument can be NULL.</font></i>
<a name='L272'><i><font color='green'>       */</font></i>
<a name='L273'>
<a name='L274'>     PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable_object,
<a name='L275'>                                                PyObject *args);
<a name='L276'>
<a name='L277'>       <i><font color='green'>/*</font></i>
<a name='L278'><i><font color='green'>     Call a callable Python object, callable_object, with</font></i>
<a name='L279'><i><font color='green'>     arguments given by the tuple, args.  If no arguments are</font></i>
<a name='L280'><i><font color='green'>     needed, then args may be NULL.  Returns the result of the</font></i>
<a name='L281'><i><font color='green'>     call on success, or NULL on failure.  This is the equivalent</font></i>
<a name='L282'><i><font color='green'>     of the Python expression: o(*args).</font></i>
<a name='L283'><i><font color='green'>       */</font></i>
<a name='L284'>
<a name='L285'>     PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable_object,
<a name='L286'>                                                  <b>char</b> *format, ...);
<a name='L287'>
<a name='L288'>       <i><font color='green'>/*</font></i>
<a name='L289'><i><font color='green'>     Call a callable Python object, callable_object, with a</font></i>
<a name='L290'><i><font color='green'>     variable number of C arguments. The C arguments are described</font></i>
<a name='L291'><i><font color='green'>     using a mkvalue-style format string. The format may be NULL,</font></i>
<a name='L292'><i><font color='green'>     indicating that no arguments are provided.  Returns the</font></i>
<a name='L293'><i><font color='green'>     result of the call on success, or NULL on failure.  This is</font></i>
<a name='L294'><i><font color='green'>     the equivalent of the Python expression: o(*args).</font></i>
<a name='L295'><i><font color='green'>       */</font></i>
<a name='L296'>
<a name='L297'>
<a name='L298'>     PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *o, <b>char</b> *method,
<a name='L299'>                                                <b>char</b> *format, ...);
<a name='L300'>
<a name='L301'>       <i><font color='green'>/*</font></i>
<a name='L302'><i><font color='green'>     Call the method named m of object o with a variable number of</font></i>
<a name='L303'><i><font color='green'>     C arguments.  The C arguments are described by a mkvalue</font></i>
<a name='L304'><i><font color='green'>     format string.  The format may be NULL, indicating that no</font></i>
<a name='L305'><i><font color='green'>     arguments are provided. Returns the result of the call on</font></i>
<a name='L306'><i><font color='green'>     success, or NULL on failure.  This is the equivalent of the</font></i>
<a name='L307'><i><font color='green'>     Python expression: o.method(args).</font></i>
<a name='L308'><i><font color='green'>       */</font></i>
<a name='L309'>
<a name='L310'>     PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
<a name='L311'>                                                         <b>char</b> *format, ...);
<a name='L312'>     PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *o,
<a name='L313'>                                                       <b>char</b> *name,
<a name='L314'>                                                       <b>char</b> *format, ...);
<a name='L315'>
<a name='L316'>     PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
<a name='L317'>                                                         ...);
<a name='L318'>
<a name='L319'>       <i><font color='green'>/*</font></i>
<a name='L320'><i><font color='green'>     Call a callable Python object, callable_object, with a</font></i>
<a name='L321'><i><font color='green'>     variable number of C arguments.  The C arguments are provided</font></i>
<a name='L322'><i><font color='green'>     as PyObject * values, terminated by a NULL.  Returns the</font></i>
<a name='L323'><i><font color='green'>     result of the call on success, or NULL on failure.  This is</font></i>
<a name='L324'><i><font color='green'>     the equivalent of the Python expression: o(*args).</font></i>
<a name='L325'><i><font color='green'>       */</font></i>
<a name='L326'>
<a name='L327'>
<a name='L328'>     PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(PyObject *o,
<a name='L329'>                                                       PyObject *method, ...);
<a name='L330'>
<a name='L331'>       <i><font color='green'>/*</font></i>
<a name='L332'><i><font color='green'>     Call the method named m of object o with a variable number of</font></i>
<a name='L333'><i><font color='green'>     C arguments.  The C arguments are provided as PyObject *</font></i>
<a name='L334'><i><font color='green'>     values, terminated by NULL.  Returns the result of the call</font></i>
<a name='L335'><i><font color='green'>     on success, or NULL on failure.  This is the equivalent of</font></i>
<a name='L336'><i><font color='green'>     the Python expression: o.method(args).</font></i>
<a name='L337'><i><font color='green'>       */</font></i>
<a name='L338'>
<a name='L339'>
<a name='L340'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L341'><i><font color='green'></font></i>
<a name='L342'><i><font color='green'>     long PyObject_Hash(PyObject *o);</font></i>
<a name='L343'><i><font color='green'></font></i>
<a name='L344'><i><font color='green'>     Compute and return the hash, hash_value, of an object, o.  On</font></i>
<a name='L345'><i><font color='green'>     failure, return -1.  This is the equivalent of the Python</font></i>
<a name='L346'><i><font color='green'>     expression: hash(o).</font></i>
<a name='L347'><i><font color='green'>       */</font></i>
<a name='L348'>
<a name='L349'>
<a name='L350'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L351'><i><font color='green'></font></i>
<a name='L352'><i><font color='green'>     int PyObject_IsTrue(PyObject *o);</font></i>
<a name='L353'><i><font color='green'></font></i>
<a name='L354'><i><font color='green'>     Returns 1 if the object, o, is considered to be true, 0 if o is</font></i>
<a name='L355'><i><font color='green'>     considered to be false and -1 on failure. This is equivalent to the</font></i>
<a name='L356'><i><font color='green'>     Python expression: not not o</font></i>
<a name='L357'><i><font color='green'>       */</font></i>
<a name='L358'>
<a name='L359'>     <i><font color='green'>/* Implemented elsewhere:</font></i>
<a name='L360'><i><font color='green'></font></i>
<a name='L361'><i><font color='green'>     int PyObject_Not(PyObject *o);</font></i>
<a name='L362'><i><font color='green'></font></i>
<a name='L363'><i><font color='green'>     Returns 0 if the object, o, is considered to be true, 1 if o is</font></i>
<a name='L364'><i><font color='green'>     considered to be false and -1 on failure. This is equivalent to the</font></i>
<a name='L365'><i><font color='green'>     Python expression: not o</font></i>
<a name='L366'><i><font color='green'>       */</font></i>
<a name='L367'>
<a name='L368'>     PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
<a name='L369'>
<a name='L370'>       <i><font color='green'>/*</font></i>
<a name='L371'><i><font color='green'>     On success, returns a type object corresponding to the object</font></i>
<a name='L372'><i><font color='green'>     type of object o. On failure, returns NULL.  This is</font></i>
<a name='L373'><i><font color='green'>     equivalent to the Python expression: type(o).</font></i>
<a name='L374'><i><font color='green'>       */</font></i>
<a name='L375'>
<a name='L376'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PyObject_Size(PyObject *o);
<a name='L377'>
<a name='L378'>       <i><font color='green'>/*</font></i>
<a name='L379'><i><font color='green'>     Return the size of object o.  If the object, o, provides</font></i>
<a name='L380'><i><font color='green'>     both sequence and mapping protocols, the sequence size is</font></i>
<a name='L381'><i><font color='green'>     returned. On error, -1 is returned.  This is the equivalent</font></i>
<a name='L382'><i><font color='green'>     to the Python expression: len(o).</font></i>
<a name='L383'><i><font color='green'>       */</font></i>
<a name='L384'>
<a name='L385'>       <i><font color='green'>/* For DLL compatibility */</font></i>
<a name='L386'><font color='darkred'>#undef</font> PyObject_Length
<a name='L387'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PyObject_Length(PyObject *o);
<a name='L388'><font color='darkred'>#define</font> PyObject_Length PyObject_Size
<a name='L389'>
<a name='L390'><font color='darkred'>#ifndef</font> Py_LIMITED_API
<a name='L391'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) _PyObject_LengthHint(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>);
<a name='L392'><font color='darkred'>#endif</font>
<a name='L393'>
<a name='L394'>       <i><font color='green'>/*</font></i>
<a name='L395'><i><font color='green'>     Guess the size of object o using len(o) or o.__length_hint__().</font></i>
<a name='L396'><i><font color='green'>     If neither of those return a non-negative value, then return the</font></i>
<a name='L397'><i><font color='green'>     default value.  If one of the calls fails, this function returns -1.</font></i>
<a name='L398'><i><font color='green'>       */</font></i>
<a name='L399'>
<a name='L400'>     PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
<a name='L401'>
<a name='L402'>       <i><font color='green'>/*</font></i>
<a name='L403'><i><font color='green'>     Return element of o corresponding to the object, key, or NULL</font></i>
<a name='L404'><i><font color='green'>     on failure. This is the equivalent of the Python expression:</font></i>
<a name='L405'><i><font color='green'>     o[key].</font></i>
<a name='L406'><i><font color='green'>       */</font></i>
<a name='L407'>
<a name='L408'>     PyAPI_FUNC(<b>int</b>) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
<a name='L409'>
<a name='L410'>       <i><font color='green'>/*</font></i>
<a name='L411'><i><font color='green'>     Map the object, key, to the value, v.  Returns</font></i>
<a name='L412'><i><font color='green'>     -1 on failure.  This is the equivalent of the Python</font></i>
<a name='L413'><i><font color='green'>     statement: o[key]=v.</font></i>
<a name='L414'><i><font color='green'>       */</font></i>
<a name='L415'>
<a name='L416'>     PyAPI_FUNC(<b>int</b>) PyObject_DelItemString(PyObject *o, <b>char</b> *key);
<a name='L417'>
<a name='L418'>       <i><font color='green'>/*</font></i>
<a name='L419'><i><font color='green'>     Remove the mapping for object, key, from the object *o.</font></i>
<a name='L420'><i><font color='green'>     Returns -1 on failure.  This is equivalent to</font></i>
<a name='L421'><i><font color='green'>     the Python statement: del o[key].</font></i>
<a name='L422'><i><font color='green'>       */</font></i>
<a name='L423'>
<a name='L424'>     PyAPI_FUNC(<b>int</b>) PyObject_DelItem(PyObject *o, PyObject *key);
<a name='L425'>
<a name='L426'>       <i><font color='green'>/*</font></i>
<a name='L427'><i><font color='green'>     Delete the mapping for key from *o.  Returns -1 on failure.</font></i>
<a name='L428'><i><font color='green'>     This is the equivalent of the Python statement: del o[key].</font></i>
<a name='L429'><i><font color='green'>       */</font></i>
<a name='L430'>
<a name='L431'>    <i><font color='green'>/* old buffer API</font></i>
<a name='L432'><i><font color='green'>       FIXME:  usage of these should all be replaced in Python itself</font></i>
<a name='L433'><i><font color='green'>       but for backwards compatibility we will implement them.</font></i>
<a name='L434'><i><font color='green'>       Their usage without a corresponding "unlock" mechansim</font></i>
<a name='L435'><i><font color='green'>       may create issues (but they would already be there). */</font></i>
<a name='L436'>
<a name='L437'>     PyAPI_FUNC(<b>int</b>) PyObject_AsCharBuffer(PyObject *obj,
<a name='L438'>                                           <b>const</b> <b>char</b> **buffer,
<a name='L439'>                                           <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *buffer_len);
<a name='L440'>
<a name='L441'>       <i><font color='green'>/*</font></i>
<a name='L442'><i><font color='green'>      Takes an arbitrary object which must support the (character,</font></i>
<a name='L443'><i><font color='green'>      single segment) buffer interface and returns a pointer to a</font></i>
<a name='L444'><i><font color='green'>      read-only memory location useable as character based input</font></i>
<a name='L445'><i><font color='green'>      for subsequent processing.</font></i>
<a name='L446'><i><font color='green'></font></i>
<a name='L447'><i><font color='green'>      0 is returned on success.  buffer and buffer_len are only</font></i>
<a name='L448'><i><font color='green'>      set in case no error occurs. Otherwise, -1 is returned and</font></i>
<a name='L449'><i><font color='green'>      an exception set.</font></i>
<a name='L450'><i><font color='green'>       */</font></i>
<a name='L451'>
<a name='L452'>     PyAPI_FUNC(<b>int</b>) PyObject_CheckReadBuffer(PyObject *obj);
<a name='L453'>
<a name='L454'>      <i><font color='green'>/*</font></i>
<a name='L455'><i><font color='green'>      Checks whether an arbitrary object supports the (character,</font></i>
<a name='L456'><i><font color='green'>      single segment) buffer interface.  Returns 1 on success, 0</font></i>
<a name='L457'><i><font color='green'>      on failure.</font></i>
<a name='L458'><i><font color='green'>      */</font></i>
<a name='L459'>
<a name='L460'>     PyAPI_FUNC(<b>int</b>) PyObject_AsReadBuffer(PyObject *obj,
<a name='L461'>                                           <b>const</b> <b>void</b> **buffer,
<a name='L462'>                                           <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *buffer_len);
<a name='L463'>
<a name='L464'>       <i><font color='green'>/*</font></i>
<a name='L465'><i><font color='green'>      Same as PyObject_AsCharBuffer() except that this API expects</font></i>
<a name='L466'><i><font color='green'>      (readable, single segment) buffer interface and returns a</font></i>
<a name='L467'><i><font color='green'>      pointer to a read-only memory location which can contain</font></i>
<a name='L468'><i><font color='green'>      arbitrary data.</font></i>
<a name='L469'><i><font color='green'></font></i>
<a name='L470'><i><font color='green'>      0 is returned on success.  buffer and buffer_len are only</font></i>
<a name='L471'><i><font color='green'>      set in case no error occurrs.  Otherwise, -1 is returned and</font></i>
<a name='L472'><i><font color='green'>      an exception set.</font></i>
<a name='L473'><i><font color='green'>       */</font></i>
<a name='L474'>
<a name='L475'>     PyAPI_FUNC(<b>int</b>) PyObject_AsWriteBuffer(PyObject *obj,
<a name='L476'>                                            <b>void</b> **buffer,
<a name='L477'>                                            <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *buffer_len);
<a name='L478'>
<a name='L479'>       <i><font color='green'>/*</font></i>
<a name='L480'><i><font color='green'>      Takes an arbitrary object which must support the (writable,</font></i>
<a name='L481'><i><font color='green'>      single segment) buffer interface and returns a pointer to a</font></i>
<a name='L482'><i><font color='green'>      writable memory location in buffer of size buffer_len.</font></i>
<a name='L483'><i><font color='green'></font></i>
<a name='L484'><i><font color='green'>      0 is returned on success.  buffer and buffer_len are only</font></i>
<a name='L485'><i><font color='green'>      set in case no error occurrs. Otherwise, -1 is returned and</font></i>
<a name='L486'><i><font color='green'>      an exception set.</font></i>
<a name='L487'><i><font color='green'>       */</font></i>
<a name='L488'>
<a name='L489'>    <i><font color='green'>/* new buffer API */</font></i>
<a name='L490'>
<a name='L491'><font color='darkred'>#ifndef</font> Py_LIMITED_API
<a name='L492'><font color='darkred'>#define</font> PyObject_CheckBuffer(obj) \
<a name='L493'>    (((obj)-&gt;ob_type-&gt;tp_as_buffer != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) &amp;&amp;  \
<a name='L494'>     ((obj)-&gt;ob_type-&gt;tp_as_buffer-&gt;bf_getbuffer != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>))
<a name='L495'>
<a name='L496'>    <i><font color='green'>/* Return 1 if the getbuffer function is available, otherwise</font></i>
<a name='L497'><i><font color='green'>       return 0 */</font></i>
<a name='L498'>
<a name='L499'>     <a href='../D/2716.html' title='Multiple defined in 45 places.'>PyAPI_FUNC</a>(<b>int</b>) PyObject_GetBuffer(PyObject *obj, Py_buffer *view,
<a name='L500'>                                        <b>int</b> flags);
<a name='L501'>
<a name='L502'>    <i><font color='green'>/* This is a C-API version of the getbuffer function call.  It checks</font></i>
<a name='L503'><i><font color='green'>       to make sure object has the required function pointer and issues the</font></i>
<a name='L504'><i><font color='green'>       call.  Returns -1 and raises an error on failure and returns 0 on</font></i>
<a name='L505'><i><font color='green'>       success</font></i>
<a name='L506'><i><font color='green'>    */</font></i>
<a name='L507'>
<a name='L508'>
<a name='L509'>     PyAPI_FUNC(<b>void</b> *) PyBuffer_GetPointer(Py_buffer *view, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *indices);
<a name='L510'>
<a name='L511'>    <i><font color='green'>/* Get the memory area pointed to by the indices for the buffer given.</font></i>
<a name='L512'><i><font color='green'>       Note that view-&gt;ndim is the assumed size of indices</font></i>
<a name='L513'><i><font color='green'>    */</font></i>
<a name='L514'>
<a name='L515'>     PyAPI_FUNC(<b>int</b>) PyBuffer_SizeFromFormat(<b>const</b> <b>char</b> *);
<a name='L516'>
<a name='L517'>    <i><font color='green'>/* Return the implied itemsize of the data-format area from a</font></i>
<a name='L518'><i><font color='green'>       struct-style description */</font></i>
<a name='L519'>
<a name='L520'>
<a name='L521'>
<a name='L522'>     PyAPI_FUNC(<b>int</b>) PyBuffer_ToContiguous(<b>void</b> *buf, Py_buffer *view,
<a name='L523'>                                           <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> len, <b>char</b> fort);
<a name='L524'>
<a name='L525'>     PyAPI_FUNC(<b>int</b>) PyBuffer_FromContiguous(Py_buffer *view, <b>void</b> *buf,
<a name='L526'>                                             <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> len, <b>char</b> fort);
<a name='L527'>
<a name='L528'>
<a name='L529'>    <i><font color='green'>/* Copy len bytes of data from the contiguous chunk of memory</font></i>
<a name='L530'><i><font color='green'>       pointed to by buf into the buffer exported by obj.  Return</font></i>
<a name='L531'><i><font color='green'>       0 on success and return -1 and raise a PyBuffer_Error on</font></i>
<a name='L532'><i><font color='green'>       error (i.e. the object does not have a buffer interface or</font></i>
<a name='L533'><i><font color='green'>       it is not working).</font></i>
<a name='L534'><i><font color='green'></font></i>
<a name='L535'><i><font color='green'>       If fort is 'F', then if the object is multi-dimensional,</font></i>
<a name='L536'><i><font color='green'>       then the data will be copied into the array in</font></i>
<a name='L537'><i><font color='green'>       Fortran-style (first dimension varies the fastest).  If</font></i>
<a name='L538'><i><font color='green'>       fort is 'C', then the data will be copied into the array</font></i>
<a name='L539'><i><font color='green'>       in C-style (last dimension varies the fastest).  If fort</font></i>
<a name='L540'><i><font color='green'>       is 'A', then it does not matter and the copy will be made</font></i>
<a name='L541'><i><font color='green'>       in whatever way is more efficient.</font></i>
<a name='L542'><i><font color='green'></font></i>
<a name='L543'><i><font color='green'>    */</font></i>
<a name='L544'>
<a name='L545'>     PyAPI_FUNC(<b>int</b>) PyObject_CopyData(PyObject *dest, PyObject *src);
<a name='L546'>
<a name='L547'>    <i><font color='green'>/* Copy the data from the src buffer to the buffer of destination</font></i>
<a name='L548'><i><font color='green'>     */</font></i>
<a name='L549'>
<a name='L550'>     PyAPI_FUNC(<b>int</b>) PyBuffer_IsContiguous(Py_buffer *view, <b>char</b> fort);
<a name='L551'>
<a name='L552'>
<a name='L553'>     PyAPI_FUNC(<b>void</b>) PyBuffer_FillContiguousStrides(<b>int</b> ndims,
<a name='L554'>                                                    <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *shape,
<a name='L555'>                                                    <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *strides,
<a name='L556'>                                                    <b>int</b> itemsize,
<a name='L557'>                                                    <b>char</b> fort);
<a name='L558'>
<a name='L559'>    <i><font color='green'>/*  Fill the strides array with byte-strides of a contiguous</font></i>
<a name='L560'><i><font color='green'>        (Fortran-style if fort is 'F' or C-style otherwise)</font></i>
<a name='L561'><i><font color='green'>        array of the given shape with the given number of bytes</font></i>
<a name='L562'><i><font color='green'>        per element.</font></i>
<a name='L563'><i><font color='green'>    */</font></i>
<a name='L564'>
<a name='L565'>     PyAPI_FUNC(<b>int</b>) PyBuffer_FillInfo(Py_buffer *view, PyObject *o, <b>void</b> *buf,
<a name='L566'>                                       <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> len, <b>int</b> readonly,
<a name='L567'>                                       <b>int</b> flags);
<a name='L568'>
<a name='L569'>    <i><font color='green'>/* Fills in a buffer-info structure correctly for an exporter</font></i>
<a name='L570'><i><font color='green'>       that can only share a contiguous chunk of memory of</font></i>
<a name='L571'><i><font color='green'>       "unsigned bytes" of the given length. Returns 0 on success</font></i>
<a name='L572'><i><font color='green'>       and -1 (with raising an error) on error.</font></i>
<a name='L573'><i><font color='green'>     */</font></i>
<a name='L574'>
<a name='L575'>     PyAPI_FUNC(<b>void</b>) PyBuffer_Release(Py_buffer *view);
<a name='L576'>
<a name='L577'>       <i><font color='green'>/* Releases a Py_buffer obtained from getbuffer ParseTuple's s*.</font></i>
<a name='L578'><i><font color='green'>    */</font></i>
<a name='L579'><font color='darkred'>#endif</font> <i><font color='green'>/* Py_LIMITED_API */</font></i>
<a name='L580'>
<a name='L581'>     PyAPI_FUNC(PyObject *) PyObject_Format(PyObject* obj,
<a name='L582'>                                            PyObject *format_spec);
<a name='L583'>       <i><font color='green'>/*</font></i>
<a name='L584'><i><font color='green'>     Takes an arbitrary object and returns the result of</font></i>
<a name='L585'><i><font color='green'>     calling obj.__format__(format_spec).</font></i>
<a name='L586'><i><font color='green'>       */</font></i>
<a name='L587'>
<a name='L588'><i><font color='green'>/* Iterators */</font></i>
<a name='L589'>
<a name='L590'>     PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
<a name='L591'>     <i><font color='green'>/* Takes an object and returns an iterator for it.</font></i>
<a name='L592'><i><font color='green'>    This is typically a new iterator but if the argument</font></i>
<a name='L593'><i><font color='green'>    is an iterator, this returns itself. */</font></i>
<a name='L594'>
<a name='L595'><font color='darkred'>#define</font> PyIter_Check(obj) \
<a name='L596'>    ((obj)-&gt;ob_type-&gt;tp_iternext != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a> &amp;&amp; \
<a name='L597'>     (obj)-&gt;ob_type-&gt;tp_iternext != &amp;<a href='../S/2803.html#L945' title='Defined at 945 in Objects/object.c.'>_PyObject_NextNotImplemented</a>)
<a name='L598'>
<a name='L599'>     <a href='../D/2716.html' title='Multiple defined in 45 places.'>PyAPI_FUNC</a>(PyObject *) PyIter_Next(PyObject *);
<a name='L600'>     <i><font color='green'>/* Takes an iterator object and calls its tp_iternext slot,</font></i>
<a name='L601'><i><font color='green'>    returning the next value.  If the iterator is exhausted,</font></i>
<a name='L602'><i><font color='green'>    this returns NULL without setting an exception.</font></i>
<a name='L603'><i><font color='green'>    NULL with an exception means an error occurred. */</font></i>
<a name='L604'>
<a name='L605'><i><font color='green'>/*  Number Protocol:*/</font></i>
<a name='L606'>
<a name='L607'>     PyAPI_FUNC(<b>int</b>) PyNumber_Check(PyObject *o);
<a name='L608'>
<a name='L609'>       <i><font color='green'>/*</font></i>
<a name='L610'><i><font color='green'>     Returns 1 if the object, o, provides numeric protocols, and</font></i>
<a name='L611'><i><font color='green'>     false otherwise.</font></i>
<a name='L612'><i><font color='green'></font></i>
<a name='L613'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L614'><i><font color='green'>       */</font></i>
<a name='L615'>
<a name='L616'>     PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
<a name='L617'>
<a name='L618'>       <i><font color='green'>/*</font></i>
<a name='L619'><i><font color='green'>     Returns the result of adding o1 and o2, or null on failure.</font></i>
<a name='L620'><i><font color='green'>     This is the equivalent of the Python expression: o1+o2.</font></i>
<a name='L621'><i><font color='green'>       */</font></i>
<a name='L622'>
<a name='L623'>     PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
<a name='L624'>
<a name='L625'>       <i><font color='green'>/*</font></i>
<a name='L626'><i><font color='green'>     Returns the result of subtracting o2 from o1, or null on</font></i>
<a name='L627'><i><font color='green'>     failure.  This is the equivalent of the Python expression:</font></i>
<a name='L628'><i><font color='green'>     o1-o2.</font></i>
<a name='L629'><i><font color='green'>       */</font></i>
<a name='L630'>
<a name='L631'>     PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
<a name='L632'>
<a name='L633'>       <i><font color='green'>/*</font></i>
<a name='L634'><i><font color='green'>     Returns the result of multiplying o1 and o2, or null on</font></i>
<a name='L635'><i><font color='green'>     failure.  This is the equivalent of the Python expression:</font></i>
<a name='L636'><i><font color='green'>     o1*o2.</font></i>
<a name='L637'><i><font color='green'>       */</font></i>
<a name='L638'>
<a name='L639'>     PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
<a name='L640'>
<a name='L641'>       <i><font color='green'>/*</font></i>
<a name='L642'><i><font color='green'>     Returns the result of dividing o1 by o2 giving an integral result,</font></i>
<a name='L643'><i><font color='green'>     or null on failure.</font></i>
<a name='L644'><i><font color='green'>     This is the equivalent of the Python expression: o1//o2.</font></i>
<a name='L645'><i><font color='green'>       */</font></i>
<a name='L646'>
<a name='L647'>     PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
<a name='L648'>
<a name='L649'>       <i><font color='green'>/*</font></i>
<a name='L650'><i><font color='green'>     Returns the result of dividing o1 by o2 giving a float result,</font></i>
<a name='L651'><i><font color='green'>     or null on failure.</font></i>
<a name='L652'><i><font color='green'>     This is the equivalent of the Python expression: o1/o2.</font></i>
<a name='L653'><i><font color='green'>       */</font></i>
<a name='L654'>
<a name='L655'>     PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
<a name='L656'>
<a name='L657'>       <i><font color='green'>/*</font></i>
<a name='L658'><i><font color='green'>     Returns the remainder of dividing o1 by o2, or null on</font></i>
<a name='L659'><i><font color='green'>     failure.  This is the equivalent of the Python expression:</font></i>
<a name='L660'><i><font color='green'>     o1%o2.</font></i>
<a name='L661'><i><font color='green'>       */</font></i>
<a name='L662'>
<a name='L663'>     PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
<a name='L664'>
<a name='L665'>       <i><font color='green'>/*</font></i>
<a name='L666'><i><font color='green'>     See the built-in function divmod.  Returns NULL on failure.</font></i>
<a name='L667'><i><font color='green'>     This is the equivalent of the Python expression:</font></i>
<a name='L668'><i><font color='green'>     divmod(o1,o2).</font></i>
<a name='L669'><i><font color='green'>       */</font></i>
<a name='L670'>
<a name='L671'>     PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
<a name='L672'>                                           PyObject *o3);
<a name='L673'>
<a name='L674'>       <i><font color='green'>/*</font></i>
<a name='L675'><i><font color='green'>     See the built-in function pow.  Returns NULL on failure.</font></i>
<a name='L676'><i><font color='green'>     This is the equivalent of the Python expression:</font></i>
<a name='L677'><i><font color='green'>     pow(o1,o2,o3), where o3 is optional.</font></i>
<a name='L678'><i><font color='green'>       */</font></i>
<a name='L679'>
<a name='L680'>     PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
<a name='L681'>
<a name='L682'>       <i><font color='green'>/*</font></i>
<a name='L683'><i><font color='green'>     Returns the negation of o on success, or null on failure.</font></i>
<a name='L684'><i><font color='green'>     This is the equivalent of the Python expression: -o.</font></i>
<a name='L685'><i><font color='green'>       */</font></i>
<a name='L686'>
<a name='L687'>     PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
<a name='L688'>
<a name='L689'>       <i><font color='green'>/*</font></i>
<a name='L690'><i><font color='green'>     Returns the (what?) of o on success, or NULL on failure.</font></i>
<a name='L691'><i><font color='green'>     This is the equivalent of the Python expression: +o.</font></i>
<a name='L692'><i><font color='green'>       */</font></i>
<a name='L693'>
<a name='L694'>     PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
<a name='L695'>
<a name='L696'>       <i><font color='green'>/*</font></i>
<a name='L697'><i><font color='green'>     Returns the absolute value of o, or null on failure.  This is</font></i>
<a name='L698'><i><font color='green'>     the equivalent of the Python expression: abs(o).</font></i>
<a name='L699'><i><font color='green'>       */</font></i>
<a name='L700'>
<a name='L701'>     PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
<a name='L702'>
<a name='L703'>       <i><font color='green'>/*</font></i>
<a name='L704'><i><font color='green'>     Returns the bitwise negation of o on success, or NULL on</font></i>
<a name='L705'><i><font color='green'>     failure.  This is the equivalent of the Python expression:</font></i>
<a name='L706'><i><font color='green'>     ~o.</font></i>
<a name='L707'><i><font color='green'>       */</font></i>
<a name='L708'>
<a name='L709'>     PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
<a name='L710'>
<a name='L711'>       <i><font color='green'>/*</font></i>
<a name='L712'><i><font color='green'>     Returns the result of left shifting o1 by o2 on success, or</font></i>
<a name='L713'><i><font color='green'>     NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L714'><i><font color='green'>     expression: o1 &lt;&lt; o2.</font></i>
<a name='L715'><i><font color='green'>       */</font></i>
<a name='L716'>
<a name='L717'>     PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
<a name='L718'>
<a name='L719'>       <i><font color='green'>/*</font></i>
<a name='L720'><i><font color='green'>     Returns the result of right shifting o1 by o2 on success, or</font></i>
<a name='L721'><i><font color='green'>     NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L722'><i><font color='green'>     expression: o1 &gt;&gt; o2.</font></i>
<a name='L723'><i><font color='green'>       */</font></i>
<a name='L724'>
<a name='L725'>     PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
<a name='L726'>
<a name='L727'>       <i><font color='green'>/*</font></i>
<a name='L728'><i><font color='green'>     Returns the result of bitwise and of o1 and o2 on success, or</font></i>
<a name='L729'><i><font color='green'>     NULL on failure. This is the equivalent of the Python</font></i>
<a name='L730'><i><font color='green'>     expression: o1&amp;o2.</font></i>
<a name='L731'><i><font color='green'></font></i>
<a name='L732'><i><font color='green'>       */</font></i>
<a name='L733'>
<a name='L734'>     PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
<a name='L735'>
<a name='L736'>       <i><font color='green'>/*</font></i>
<a name='L737'><i><font color='green'>     Returns the bitwise exclusive or of o1 by o2 on success, or</font></i>
<a name='L738'><i><font color='green'>     NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L739'><i><font color='green'>     expression: o1^o2.</font></i>
<a name='L740'><i><font color='green'>       */</font></i>
<a name='L741'>
<a name='L742'>     PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
<a name='L743'>
<a name='L744'>       <i><font color='green'>/*</font></i>
<a name='L745'><i><font color='green'>     Returns the result of bitwise or on o1 and o2 on success, or</font></i>
<a name='L746'><i><font color='green'>     NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L747'><i><font color='green'>     expression: o1|o2.</font></i>
<a name='L748'><i><font color='green'>       */</font></i>
<a name='L749'>
<a name='L750'><font color='darkred'>#define</font> PyIndex_Check(obj) \
<a name='L751'>   ((obj)-&gt;ob_type-&gt;tp_as_number != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a> &amp;&amp; \
<a name='L752'>    (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>)
<a name='L753'>
<a name='L754'>     <a href='../D/2716.html' title='Multiple defined in 45 places.'>PyAPI_FUNC</a>(PyObject *) PyNumber_Index(PyObject *o);
<a name='L755'>
<a name='L756'>       <i><font color='green'>/*</font></i>
<a name='L757'><i><font color='green'>     Returns the object converted to a Python long or int</font></i>
<a name='L758'><i><font color='green'>     or NULL with an error raised on failure.</font></i>
<a name='L759'><i><font color='green'>       */</font></i>
<a name='L760'>
<a name='L761'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) <a href='../S/2775.html#L1227' title='Defined at 1227 in Objects/abstract.c.'>PyNumber_AsSsize_t</a>(PyObject *o, PyObject *exc);
<a name='L762'>
<a name='L763'>       <i><font color='green'>/*</font></i>
<a name='L764'><i><font color='green'>     Returns the Integral instance converted to an int. The</font></i>
<a name='L765'><i><font color='green'>     instance is expected to be int or long or have an __int__</font></i>
<a name='L766'><i><font color='green'>     method. Steals integral's reference. error_format will be</font></i>
<a name='L767'><i><font color='green'>     used to create the TypeError if integral isn't actually an</font></i>
<a name='L768'><i><font color='green'>     Integral instance. error_format should be a format string</font></i>
<a name='L769'><i><font color='green'>     that can accept a char* naming integral's type.</font></i>
<a name='L770'><i><font color='green'>       */</font></i>
<a name='L771'>
<a name='L772'><font color='darkred'>#ifndef</font> Py_LIMITED_API
<a name='L773'>     PyAPI_FUNC(PyObject *) _PyNumber_ConvertIntegralToInt(
<a name='L774'>         PyObject *integral,
<a name='L775'>         <b>const</b> <b>char</b>* error_format);
<a name='L776'><font color='darkred'>#endif</font>
<a name='L777'>
<a name='L778'>       <i><font color='green'>/*</font></i>
<a name='L779'><i><font color='green'>    Returns the object converted to Py_ssize_t by going through</font></i>
<a name='L780'><i><font color='green'>    PyNumber_Index first.  If an overflow error occurs while</font></i>
<a name='L781'><i><font color='green'>    converting the int-or-long to Py_ssize_t, then the second argument</font></i>
<a name='L782'><i><font color='green'>    is the error-type to return.  If it is NULL, then the overflow error</font></i>
<a name='L783'><i><font color='green'>    is cleared and the value is clipped.</font></i>
<a name='L784'><i><font color='green'>       */</font></i>
<a name='L785'>
<a name='L786'>     PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
<a name='L787'>
<a name='L788'>       <i><font color='green'>/*</font></i>
<a name='L789'><i><font color='green'>     Returns the o converted to an integer object on success, or</font></i>
<a name='L790'><i><font color='green'>     NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L791'><i><font color='green'>     expression: int(o).</font></i>
<a name='L792'><i><font color='green'>       */</font></i>
<a name='L793'>
<a name='L794'>     PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
<a name='L795'>
<a name='L796'>       <i><font color='green'>/*</font></i>
<a name='L797'><i><font color='green'>     Returns the o converted to a float object on success, or NULL</font></i>
<a name='L798'><i><font color='green'>     on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L799'><i><font color='green'>     float(o).</font></i>
<a name='L800'><i><font color='green'>       */</font></i>
<a name='L801'>
<a name='L802'><i><font color='green'>/*  In-place variants of (some of) the above number protocol functions */</font></i>
<a name='L803'>
<a name='L804'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
<a name='L805'>
<a name='L806'>       <i><font color='green'>/*</font></i>
<a name='L807'><i><font color='green'>     Returns the result of adding o2 to o1, possibly in-place, or null</font></i>
<a name='L808'><i><font color='green'>     on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L809'><i><font color='green'>     o1 += o2.</font></i>
<a name='L810'><i><font color='green'>       */</font></i>
<a name='L811'>
<a name='L812'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
<a name='L813'>
<a name='L814'>       <i><font color='green'>/*</font></i>
<a name='L815'><i><font color='green'>     Returns the result of subtracting o2 from o1, possibly in-place or</font></i>
<a name='L816'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L817'><i><font color='green'>     o1 -= o2.</font></i>
<a name='L818'><i><font color='green'>       */</font></i>
<a name='L819'>
<a name='L820'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
<a name='L821'>
<a name='L822'>       <i><font color='green'>/*</font></i>
<a name='L823'><i><font color='green'>     Returns the result of multiplying o1 by o2, possibly in-place, or</font></i>
<a name='L824'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L825'><i><font color='green'>     o1 *= o2.</font></i>
<a name='L826'><i><font color='green'>       */</font></i>
<a name='L827'>
<a name='L828'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
<a name='L829'>                                                        PyObject *o2);
<a name='L830'>
<a name='L831'>       <i><font color='green'>/*</font></i>
<a name='L832'><i><font color='green'>     Returns the result of dividing o1 by o2 giving an integral result,</font></i>
<a name='L833'><i><font color='green'>     possibly in-place, or null on failure.</font></i>
<a name='L834'><i><font color='green'>     This is the equivalent of the Python expression:</font></i>
<a name='L835'><i><font color='green'>     o1 /= o2.</font></i>
<a name='L836'><i><font color='green'>       */</font></i>
<a name='L837'>
<a name='L838'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
<a name='L839'>                                                       PyObject *o2);
<a name='L840'>
<a name='L841'>       <i><font color='green'>/*</font></i>
<a name='L842'><i><font color='green'>     Returns the result of dividing o1 by o2 giving a float result,</font></i>
<a name='L843'><i><font color='green'>     possibly in-place, or null on failure.</font></i>
<a name='L844'><i><font color='green'>     This is the equivalent of the Python expression:</font></i>
<a name='L845'><i><font color='green'>     o1 /= o2.</font></i>
<a name='L846'><i><font color='green'>       */</font></i>
<a name='L847'>
<a name='L848'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
<a name='L849'>
<a name='L850'>       <i><font color='green'>/*</font></i>
<a name='L851'><i><font color='green'>     Returns the remainder of dividing o1 by o2, possibly in-place, or</font></i>
<a name='L852'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L853'><i><font color='green'>     o1 %= o2.</font></i>
<a name='L854'><i><font color='green'>       */</font></i>
<a name='L855'>
<a name='L856'>     PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
<a name='L857'>                                                  PyObject *o3);
<a name='L858'>
<a name='L859'>       <i><font color='green'>/*</font></i>
<a name='L860'><i><font color='green'>     Returns the result of raising o1 to the power of o2, possibly</font></i>
<a name='L861'><i><font color='green'>     in-place, or null on failure.  This is the equivalent of the Python</font></i>
<a name='L862'><i><font color='green'>     expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.</font></i>
<a name='L863'><i><font color='green'>       */</font></i>
<a name='L864'>
<a name='L865'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
<a name='L866'>
<a name='L867'>       <i><font color='green'>/*</font></i>
<a name='L868'><i><font color='green'>     Returns the result of left shifting o1 by o2, possibly in-place, or</font></i>
<a name='L869'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L870'><i><font color='green'>     o1 &lt;&lt;= o2.</font></i>
<a name='L871'><i><font color='green'>       */</font></i>
<a name='L872'>
<a name='L873'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
<a name='L874'>
<a name='L875'>       <i><font color='green'>/*</font></i>
<a name='L876'><i><font color='green'>     Returns the result of right shifting o1 by o2, possibly in-place or</font></i>
<a name='L877'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L878'><i><font color='green'>     o1 &gt;&gt;= o2.</font></i>
<a name='L879'><i><font color='green'>       */</font></i>
<a name='L880'>
<a name='L881'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
<a name='L882'>
<a name='L883'>       <i><font color='green'>/*</font></i>
<a name='L884'><i><font color='green'>     Returns the result of bitwise and of o1 and o2, possibly in-place,</font></i>
<a name='L885'><i><font color='green'>     or null on failure. This is the equivalent of the Python</font></i>
<a name='L886'><i><font color='green'>     expression: o1 &amp;= o2.</font></i>
<a name='L887'><i><font color='green'>       */</font></i>
<a name='L888'>
<a name='L889'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
<a name='L890'>
<a name='L891'>       <i><font color='green'>/*</font></i>
<a name='L892'><i><font color='green'>     Returns the bitwise exclusive or of o1 by o2, possibly in-place, or</font></i>
<a name='L893'><i><font color='green'>     null on failure.  This is the equivalent of the Python expression:</font></i>
<a name='L894'><i><font color='green'>     o1 ^= o2.</font></i>
<a name='L895'><i><font color='green'>       */</font></i>
<a name='L896'>
<a name='L897'>     PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
<a name='L898'>
<a name='L899'>       <i><font color='green'>/*</font></i>
<a name='L900'><i><font color='green'>     Returns the result of bitwise or of o1 and o2, possibly in-place,</font></i>
<a name='L901'><i><font color='green'>     or null on failure.  This is the equivalent of the Python</font></i>
<a name='L902'><i><font color='green'>     expression: o1 |= o2.</font></i>
<a name='L903'><i><font color='green'>       */</font></i>
<a name='L904'>
<a name='L905'>     PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, <b>int</b> base);
<a name='L906'>
<a name='L907'>       <i><font color='green'>/*</font></i>
<a name='L908'><i><font color='green'>     Returns the integer n converted to a string with a base, with a base</font></i>
<a name='L909'><i><font color='green'>     marker of 0b, 0o or 0x prefixed if applicable.</font></i>
<a name='L910'><i><font color='green'>     If n is not an int object, it is converted with PyNumber_Index first.</font></i>
<a name='L911'><i><font color='green'>       */</font></i>
<a name='L912'>
<a name='L913'>
<a name='L914'><i><font color='green'>/*  Sequence protocol:*/</font></i>
<a name='L915'>
<a name='L916'>     PyAPI_FUNC(<b>int</b>) PySequence_Check(PyObject *o);
<a name='L917'>
<a name='L918'>       <i><font color='green'>/*</font></i>
<a name='L919'><i><font color='green'>     Return 1 if the object provides sequence protocol, and zero</font></i>
<a name='L920'><i><font color='green'>     otherwise.</font></i>
<a name='L921'><i><font color='green'></font></i>
<a name='L922'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L923'><i><font color='green'>       */</font></i>
<a name='L924'>
<a name='L925'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PySequence_Size(PyObject *o);
<a name='L926'>
<a name='L927'>       <i><font color='green'>/*</font></i>
<a name='L928'><i><font color='green'>     Return the size of sequence object o, or -1 on failure.</font></i>
<a name='L929'><i><font color='green'>       */</font></i>
<a name='L930'>
<a name='L931'>       <i><font color='green'>/* For DLL compatibility */</font></i>
<a name='L932'><font color='darkred'>#undef</font> PySequence_Length
<a name='L933'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PySequence_Length(PyObject *o);
<a name='L934'><font color='darkred'>#define</font> PySequence_Length PySequence_Size
<a name='L935'>
<a name='L936'>
<a name='L937'>     PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
<a name='L938'>
<a name='L939'>       <i><font color='green'>/*</font></i>
<a name='L940'><i><font color='green'>     Return the concatenation of o1 and o2 on success, and NULL on</font></i>
<a name='L941'><i><font color='green'>     failure.   This is the equivalent of the Python</font></i>
<a name='L942'><i><font color='green'>     expression: o1+o2.</font></i>
<a name='L943'><i><font color='green'>       */</font></i>
<a name='L944'>
<a name='L945'>     PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> count);
<a name='L946'>
<a name='L947'>       <i><font color='green'>/*</font></i>
<a name='L948'><i><font color='green'>     Return the result of repeating sequence object o count times,</font></i>
<a name='L949'><i><font color='green'>     or NULL on failure.  This is the equivalent of the Python</font></i>
<a name='L950'><i><font color='green'>     expression: o1*count.</font></i>
<a name='L951'><i><font color='green'>       */</font></i>
<a name='L952'>
<a name='L953'>     PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i);
<a name='L954'>
<a name='L955'>       <i><font color='green'>/*</font></i>
<a name='L956'><i><font color='green'>     Return the ith element of o, or NULL on failure. This is the</font></i>
<a name='L957'><i><font color='green'>     equivalent of the Python expression: o[i].</font></i>
<a name='L958'><i><font color='green'>       */</font></i>
<a name='L959'>
<a name='L960'>     PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i1, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i2);
<a name='L961'>
<a name='L962'>       <i><font color='green'>/*</font></i>
<a name='L963'><i><font color='green'>     Return the slice of sequence object o between i1 and i2, or</font></i>
<a name='L964'><i><font color='green'>     NULL on failure. This is the equivalent of the Python</font></i>
<a name='L965'><i><font color='green'>     expression: o[i1:i2].</font></i>
<a name='L966'><i><font color='green'>       */</font></i>
<a name='L967'>
<a name='L968'>     PyAPI_FUNC(<b>int</b>) PySequence_SetItem(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i, PyObject *v);
<a name='L969'>
<a name='L970'>       <i><font color='green'>/*</font></i>
<a name='L971'><i><font color='green'>     Assign object v to the ith element of o.  Returns</font></i>
<a name='L972'><i><font color='green'>     -1 on failure.  This is the equivalent of the Python</font></i>
<a name='L973'><i><font color='green'>     statement: o[i]=v.</font></i>
<a name='L974'><i><font color='green'>       */</font></i>
<a name='L975'>
<a name='L976'>     PyAPI_FUNC(<b>int</b>) PySequence_DelItem(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i);
<a name='L977'>
<a name='L978'>       <i><font color='green'>/*</font></i>
<a name='L979'><i><font color='green'>     Delete the ith element of object v.  Returns</font></i>
<a name='L980'><i><font color='green'>     -1 on failure.  This is the equivalent of the Python</font></i>
<a name='L981'><i><font color='green'>     statement: del o[i].</font></i>
<a name='L982'><i><font color='green'>       */</font></i>
<a name='L983'>
<a name='L984'>     PyAPI_FUNC(<b>int</b>) PySequence_SetSlice(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i1, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i2,
<a name='L985'>                                         PyObject *v);
<a name='L986'>
<a name='L987'>       <i><font color='green'>/*</font></i>
<a name='L988'><i><font color='green'>     Assign the sequence object, v, to the slice in sequence</font></i>
<a name='L989'><i><font color='green'>     object, o, from i1 to i2.  Returns -1 on failure. This is the</font></i>
<a name='L990'><i><font color='green'>     equivalent of the Python statement: o[i1:i2]=v.</font></i>
<a name='L991'><i><font color='green'>       */</font></i>
<a name='L992'>
<a name='L993'>     PyAPI_FUNC(<b>int</b>) PySequence_DelSlice(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i1, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> i2);
<a name='L994'>
<a name='L995'>       <i><font color='green'>/*</font></i>
<a name='L996'><i><font color='green'>     Delete the slice in sequence object, o, from i1 to i2.</font></i>
<a name='L997'><i><font color='green'>     Returns -1 on failure. This is the equivalent of the Python</font></i>
<a name='L998'><i><font color='green'>     statement: del o[i1:i2].</font></i>
<a name='L999'><i><font color='green'>       */</font></i>
<a name='L1000'>
<a name='L1001'>     PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
<a name='L1002'>
<a name='L1003'>       <i><font color='green'>/*</font></i>
<a name='L1004'><i><font color='green'>     Returns the sequence, o, as a tuple on success, and NULL on failure.</font></i>
<a name='L1005'><i><font color='green'>     This is equivalent to the Python expression: tuple(o)</font></i>
<a name='L1006'><i><font color='green'>       */</font></i>
<a name='L1007'>
<a name='L1008'>
<a name='L1009'>     PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
<a name='L1010'>       <i><font color='green'>/*</font></i>
<a name='L1011'><i><font color='green'>     Returns the sequence, o, as a list on success, and NULL on failure.</font></i>
<a name='L1012'><i><font color='green'>     This is equivalent to the Python expression: list(o)</font></i>
<a name='L1013'><i><font color='green'>       */</font></i>
<a name='L1014'>
<a name='L1015'>     PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, <b>const</b> <b>char</b>* m);
<a name='L1016'>       <i><font color='green'>/*</font></i>
<a name='L1017'><i><font color='green'>     Returns the sequence, o, as a tuple, unless it's already a</font></i>
<a name='L1018'><i><font color='green'>     tuple or list.  Use PySequence_Fast_GET_ITEM to access the</font></i>
<a name='L1019'><i><font color='green'>     members of this list, and PySequence_Fast_GET_SIZE to get its length.</font></i>
<a name='L1020'><i><font color='green'></font></i>
<a name='L1021'><i><font color='green'>     Returns NULL on failure.  If the object does not support iteration,</font></i>
<a name='L1022'><i><font color='green'>     raises a TypeError exception with m as the message text.</font></i>
<a name='L1023'><i><font color='green'>       */</font></i>
<a name='L1024'>
<a name='L1025'><font color='darkred'>#define</font> PySequence_Fast_GET_SIZE(o) \
<a name='L1026'>    (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
<a name='L1027'>       <i><font color='green'>/*</font></i>
<a name='L1028'><i><font color='green'>     Return the size of o, assuming that o was returned by</font></i>
<a name='L1029'><i><font color='green'>     PySequence_Fast and is not NULL.</font></i>
<a name='L1030'><i><font color='green'>       */</font></i>
<a name='L1031'>
<a name='L1032'><font color='darkred'>#define</font> PySequence_Fast_GET_ITEM(o, i)\
<a name='L1033'>     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
<a name='L1034'>       <i><font color='green'>/*</font></i>
<a name='L1035'><i><font color='green'>     Return the ith element of o, assuming that o was returned by</font></i>
<a name='L1036'><i><font color='green'>     PySequence_Fast, and that i is within bounds.</font></i>
<a name='L1037'><i><font color='green'>       */</font></i>
<a name='L1038'>
<a name='L1039'><font color='darkred'>#define</font> PySequence_ITEM(o, i)\
<a name='L1040'>    ( Py_TYPE(o)-&gt;tp_as_sequence-&gt;sq_item(o, i) )
<a name='L1041'>       <i><font color='green'>/* Assume tp_as_sequence and sq_item exist and that i does not</font></i>
<a name='L1042'><i><font color='green'>      need to be corrected for a negative index</font></i>
<a name='L1043'><i><font color='green'>       */</font></i>
<a name='L1044'>
<a name='L1045'><font color='darkred'>#define</font> PySequence_Fast_ITEMS(sf) \
<a name='L1046'>    (PyList_Check(sf) ? ((PyListObject *)(sf))-&gt;ob_item \
<a name='L1047'>                      : ((PyTupleObject *)(sf))-&gt;ob_item)
<a name='L1048'>    <i><font color='green'>/* Return a pointer to the underlying item array for</font></i>
<a name='L1049'><i><font color='green'>       an object retured by PySequence_Fast */</font></i>
<a name='L1050'>
<a name='L1051'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PySequence_Count(PyObject *o, PyObject *value);
<a name='L1052'>
<a name='L1053'>       <i><font color='green'>/*</font></i>
<a name='L1054'><i><font color='green'>     Return the number of occurrences on value on o, that is,</font></i>
<a name='L1055'><i><font color='green'>     return the number of keys for which o[key]==value.  On</font></i>
<a name='L1056'><i><font color='green'>     failure, return -1.  This is equivalent to the Python</font></i>
<a name='L1057'><i><font color='green'>     expression: o.count(value).</font></i>
<a name='L1058'><i><font color='green'>       */</font></i>
<a name='L1059'>
<a name='L1060'>     PyAPI_FUNC(<b>int</b>) PySequence_Contains(PyObject *seq, PyObject *ob);
<a name='L1061'>       <i><font color='green'>/*</font></i>
<a name='L1062'><i><font color='green'>     Return -1 if error; 1 if ob in seq; 0 if ob not in seq.</font></i>
<a name='L1063'><i><font color='green'>     Use __contains__ if possible, else _PySequence_IterSearch().</font></i>
<a name='L1064'><i><font color='green'>       */</font></i>
<a name='L1065'>
<a name='L1066'><font color='darkred'>#ifndef</font> Py_LIMITED_API
<a name='L1067'><font color='darkred'>#define</font> PY_ITERSEARCH_COUNT    1
<a name='L1068'><font color='darkred'>#define</font> PY_ITERSEARCH_INDEX    2
<a name='L1069'><font color='darkred'>#define</font> PY_ITERSEARCH_CONTAINS 3
<a name='L1070'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) _PySequence_IterSearch(PyObject *seq,
<a name='L1071'>                                        PyObject *obj, <b>int</b> operation);
<a name='L1072'><font color='darkred'>#endif</font>
<a name='L1073'>    <i><font color='green'>/*</font></i>
<a name='L1074'><i><font color='green'>      Iterate over seq.  Result depends on the operation:</font></i>
<a name='L1075'><i><font color='green'>      PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if</font></i>
<a name='L1076'><i><font color='green'>        error.</font></i>
<a name='L1077'><i><font color='green'>      PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of</font></i>
<a name='L1078'><i><font color='green'>        obj in seq; set ValueError and return -1 if none found;</font></i>
<a name='L1079'><i><font color='green'>        also return -1 on error.</font></i>
<a name='L1080'><i><font color='green'>      PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on</font></i>
<a name='L1081'><i><font color='green'>        error.</font></i>
<a name='L1082'><i><font color='green'>    */</font></i>
<a name='L1083'>
<a name='L1084'><i><font color='green'>/* For DLL-level backwards compatibility */</font></i>
<a name='L1085'><font color='darkred'>#undef</font> PySequence_In
<a name='L1086'>     PyAPI_FUNC(<b>int</b>) PySequence_In(PyObject *o, PyObject *value);
<a name='L1087'>
<a name='L1088'><i><font color='green'>/* For source-level backwards compatibility */</font></i>
<a name='L1089'><font color='darkred'>#define</font> PySequence_In PySequence_Contains
<a name='L1090'>
<a name='L1091'>       <i><font color='green'>/*</font></i>
<a name='L1092'><i><font color='green'>     Determine if o contains value.  If an item in o is equal to</font></i>
<a name='L1093'><i><font color='green'>     X, return 1, otherwise return 0.  On error, return -1.  This</font></i>
<a name='L1094'><i><font color='green'>     is equivalent to the Python expression: value in o.</font></i>
<a name='L1095'><i><font color='green'>       */</font></i>
<a name='L1096'>
<a name='L1097'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PySequence_Index(PyObject *o, PyObject *value);
<a name='L1098'>
<a name='L1099'>       <i><font color='green'>/*</font></i>
<a name='L1100'><i><font color='green'>     Return the first index for which o[i]=value.  On error,</font></i>
<a name='L1101'><i><font color='green'>     return -1.    This is equivalent to the Python</font></i>
<a name='L1102'><i><font color='green'>     expression: o.index(value).</font></i>
<a name='L1103'><i><font color='green'>       */</font></i>
<a name='L1104'>
<a name='L1105'><i><font color='green'>/* In-place versions of some of the above Sequence functions. */</font></i>
<a name='L1106'>
<a name='L1107'>     PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
<a name='L1108'>
<a name='L1109'>       <i><font color='green'>/*</font></i>
<a name='L1110'><i><font color='green'>     Append o2 to o1, in-place when possible. Return the resulting</font></i>
<a name='L1111'><i><font color='green'>     object, which could be o1, or NULL on failure.  This is the</font></i>
<a name='L1112'><i><font color='green'>     equivalent of the Python expression: o1 += o2.</font></i>
<a name='L1113'><i><font color='green'></font></i>
<a name='L1114'><i><font color='green'>       */</font></i>
<a name='L1115'>
<a name='L1116'>     PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> count);
<a name='L1117'>
<a name='L1118'>       <i><font color='green'>/*</font></i>
<a name='L1119'><i><font color='green'>     Repeat o1 by count, in-place when possible. Return the resulting</font></i>
<a name='L1120'><i><font color='green'>     object, which could be o1, or NULL on failure.  This is the</font></i>
<a name='L1121'><i><font color='green'>     equivalent of the Python expression: o1 *= count.</font></i>
<a name='L1122'><i><font color='green'></font></i>
<a name='L1123'><i><font color='green'>       */</font></i>
<a name='L1124'>
<a name='L1125'><i><font color='green'>/*  Mapping protocol:*/</font></i>
<a name='L1126'>
<a name='L1127'>     PyAPI_FUNC(<b>int</b>) PyMapping_Check(PyObject *o);
<a name='L1128'>
<a name='L1129'>       <i><font color='green'>/*</font></i>
<a name='L1130'><i><font color='green'>     Return 1 if the object provides mapping protocol, and zero</font></i>
<a name='L1131'><i><font color='green'>     otherwise.</font></i>
<a name='L1132'><i><font color='green'></font></i>
<a name='L1133'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L1134'><i><font color='green'>       */</font></i>
<a name='L1135'>
<a name='L1136'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PyMapping_Size(PyObject *o);
<a name='L1137'>
<a name='L1138'>       <i><font color='green'>/*</font></i>
<a name='L1139'><i><font color='green'>     Returns the number of keys in object o on success, and -1 on</font></i>
<a name='L1140'><i><font color='green'>     failure.  For objects that do not provide sequence protocol,</font></i>
<a name='L1141'><i><font color='green'>     this is equivalent to the Python expression: len(o).</font></i>
<a name='L1142'><i><font color='green'>       */</font></i>
<a name='L1143'>
<a name='L1144'>       <i><font color='green'>/* For DLL compatibility */</font></i>
<a name='L1145'><font color='darkred'>#undef</font> PyMapping_Length
<a name='L1146'>     PyAPI_FUNC(<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>) PyMapping_Length(PyObject *o);
<a name='L1147'><font color='darkred'>#define</font> PyMapping_Length PyMapping_Size
<a name='L1148'>
<a name='L1149'>
<a name='L1150'>     <i><font color='green'>/* implemented as a macro:</font></i>
<a name='L1151'><i><font color='green'></font></i>
<a name='L1152'><i><font color='green'>     int PyMapping_DelItemString(PyObject *o, char *key);</font></i>
<a name='L1153'><i><font color='green'></font></i>
<a name='L1154'><i><font color='green'>     Remove the mapping for object, key, from the object *o.</font></i>
<a name='L1155'><i><font color='green'>     Returns -1 on failure.  This is equivalent to</font></i>
<a name='L1156'><i><font color='green'>     the Python statement: del o[key].</font></i>
<a name='L1157'><i><font color='green'>       */</font></i>
<a name='L1158'><font color='darkred'>#define</font> PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))
<a name='L1159'>
<a name='L1160'>     <i><font color='green'>/* implemented as a macro:</font></i>
<a name='L1161'><i><font color='green'></font></i>
<a name='L1162'><i><font color='green'>     int PyMapping_DelItem(PyObject *o, PyObject *key);</font></i>
<a name='L1163'><i><font color='green'></font></i>
<a name='L1164'><i><font color='green'>     Remove the mapping for object, key, from the object *o.</font></i>
<a name='L1165'><i><font color='green'>     Returns -1 on failure.  This is equivalent to</font></i>
<a name='L1166'><i><font color='green'>     the Python statement: del o[key].</font></i>
<a name='L1167'><i><font color='green'>       */</font></i>
<a name='L1168'><font color='darkred'>#define</font> PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))
<a name='L1169'>
<a name='L1170'>     PyAPI_FUNC(<b>int</b>) PyMapping_HasKeyString(PyObject *o, <b>char</b> *key);
<a name='L1171'>
<a name='L1172'>       <i><font color='green'>/*</font></i>
<a name='L1173'><i><font color='green'>     On success, return 1 if the mapping object has the key, key,</font></i>
<a name='L1174'><i><font color='green'>     and 0 otherwise.  This is equivalent to the Python expression:</font></i>
<a name='L1175'><i><font color='green'>     key in o.</font></i>
<a name='L1176'><i><font color='green'></font></i>
<a name='L1177'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L1178'><i><font color='green'>       */</font></i>
<a name='L1179'>
<a name='L1180'>     PyAPI_FUNC(<b>int</b>) PyMapping_HasKey(PyObject *o, PyObject *key);
<a name='L1181'>
<a name='L1182'>       <i><font color='green'>/*</font></i>
<a name='L1183'><i><font color='green'>     Return 1 if the mapping object has the key, key,</font></i>
<a name='L1184'><i><font color='green'>     and 0 otherwise.  This is equivalent to the Python expression:</font></i>
<a name='L1185'><i><font color='green'>     key in o.</font></i>
<a name='L1186'><i><font color='green'></font></i>
<a name='L1187'><i><font color='green'>     This function always succeeds.</font></i>
<a name='L1188'><i><font color='green'></font></i>
<a name='L1189'><i><font color='green'>       */</font></i>
<a name='L1190'>
<a name='L1191'>     PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);
<a name='L1192'>
<a name='L1193'>       <i><font color='green'>/*</font></i>
<a name='L1194'><i><font color='green'>     On success, return a list or tuple of the keys in object o.</font></i>
<a name='L1195'><i><font color='green'>     On failure, return NULL.</font></i>
<a name='L1196'><i><font color='green'>       */</font></i>
<a name='L1197'>
<a name='L1198'>     PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);
<a name='L1199'>
<a name='L1200'>       <i><font color='green'>/*</font></i>
<a name='L1201'><i><font color='green'>     On success, return a list or tuple of the values in object o.</font></i>
<a name='L1202'><i><font color='green'>     On failure, return NULL.</font></i>
<a name='L1203'><i><font color='green'>       */</font></i>
<a name='L1204'>
<a name='L1205'>     PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);
<a name='L1206'>
<a name='L1207'>       <i><font color='green'>/*</font></i>
<a name='L1208'><i><font color='green'>     On success, return a list or tuple of the items in object o,</font></i>
<a name='L1209'><i><font color='green'>     where each item is a tuple containing a key-value pair.</font></i>
<a name='L1210'><i><font color='green'>     On failure, return NULL.</font></i>
<a name='L1211'><i><font color='green'></font></i>
<a name='L1212'><i><font color='green'>       */</font></i>
<a name='L1213'>
<a name='L1214'>     PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o, <b>char</b> *key);
<a name='L1215'>
<a name='L1216'>       <i><font color='green'>/*</font></i>
<a name='L1217'><i><font color='green'>     Return element of o corresponding to the object, key, or NULL</font></i>
<a name='L1218'><i><font color='green'>     on failure. This is the equivalent of the Python expression:</font></i>
<a name='L1219'><i><font color='green'>     o[key].</font></i>
<a name='L1220'><i><font color='green'>       */</font></i>
<a name='L1221'>
<a name='L1222'>     PyAPI_FUNC(<b>int</b>) PyMapping_SetItemString(PyObject *o, <b>char</b> *key,
<a name='L1223'>                                            PyObject *value);
<a name='L1224'>
<a name='L1225'>       <i><font color='green'>/*</font></i>
<a name='L1226'><i><font color='green'>     Map the object, key, to the value, v.  Returns</font></i>
<a name='L1227'><i><font color='green'>     -1 on failure.  This is the equivalent of the Python</font></i>
<a name='L1228'><i><font color='green'>     statement: o[key]=v.</font></i>
<a name='L1229'><i><font color='green'>      */</font></i>
<a name='L1230'>
<a name='L1231'>
<a name='L1232'>PyAPI_FUNC(<b>int</b>) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
<a name='L1233'>      <i><font color='green'>/* isinstance(object, typeorclass) */</font></i>
<a name='L1234'>
<a name='L1235'>PyAPI_FUNC(<b>int</b>) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
<a name='L1236'>      <i><font color='green'>/* issubclass(object, typeorclass) */</font></i>
<a name='L1237'>
<a name='L1238'>
<a name='L1239'><font color='darkred'>#ifndef</font> Py_LIMITED_API
<a name='L1240'>PyAPI_FUNC(<b>int</b>) _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);
<a name='L1241'>
<a name='L1242'>PyAPI_FUNC(<b>int</b>) _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);
<a name='L1243'>
<a name='L1244'>PyAPI_FUNC(<b>char</b> *<b>const</b> *) _PySequence_BytesToCharpArray(PyObject* self);
<a name='L1245'>
<a name='L1246'>PyAPI_FUNC(<b>void</b>) _Py_FreeCharPArray(<b>char</b> *<b>const</b> array[]);
<a name='L1247'><font color='darkred'>#endif</font>
<a name='L1248'>
<a name='L1249'><i><font color='green'>/* For internal use by buffer API functions */</font></i>
<a name='L1250'>PyAPI_FUNC(<b>void</b>) _Py_add_one_to_index_F(<b>int</b> nd, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *index,
<a name='L1251'>                                        <b>const</b> <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *shape);
<a name='L1252'>PyAPI_FUNC(<b>void</b>) _Py_add_one_to_index_C(<b>int</b> nd, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *index,
<a name='L1253'>                                        <b>const</b> <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> *shape);
<a name='L1254'>
<a name='L1255'>
<a name='L1256'><font color='darkred'>#ifdef</font> __cplusplus
<a name='L1257'><font color='red'>}</font>
<a name='L1258'><font color='darkred'>#endif</font>
<a name='L1259'><font color='darkred'>#endif</font> <i><font color='green'>/* Py_ABSTRACTOBJECT_H */</font></i>
</pre>
<hr>
<a name='BOTTOM'>
<i><font color='green'>/* [&lt;][&gt;][^][v]<a href='#TOP'>[top]</a>[bottom]<a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
</body>
</html>
