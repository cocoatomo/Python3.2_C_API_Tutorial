<html>
<head>
<title>Python/pystrtod.c</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.8.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<a name='TOP'><h2><a href='../mains.html'>root</a>/<a href='../files/3402.html'>Python</a>/pystrtod.c</h2>
<i><font color='green'>/* [&lt;][&gt;]<a href='#L10'>[^]</a><a href='#L1134'>[v]</a>[top]<a href='#BOTTOM'>[bottom]</a><a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
<hr>
<h2>DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href='#L10' title='Defined at 10.'>case_insensitive_match</a>
<li><a href='#L26' title='Defined at 26.'>_Py_parse_inf_or_nan</a>
<li><a href='#L92' title='Defined at 92.'>_PyOS_ascii_strtod</a>
<li><a href='#L125' title='Defined at 125.'>_PyOS_ascii_strtod</a>
<li><a href='#L298' title='Defined at 298.'>PyOS_string_to_double</a>
<li><a href='#L339' title='Defined at 339.'>Py_LOCAL_INLINE</a>
<li><a href='#L377' title='Defined at 377.'>Py_LOCAL_INLINE</a>
<li><a href='#L445' title='Defined at 445.'>Py_LOCAL_INLINE</a>
<li><a href='#L491' title='Defined at 491.'>Py_LOCAL_INLINE</a>
<li><a href='#L605' title='Defined at 605.'>_PyOS_ascii_formatd</a>
<li><a href='#L686' title='Defined at 686.'>PyAPI_FUNC</a>
<li><a href='#L886' title='Defined at 886.'>format_float_short</a>
<li><a href='#L1134' title='Defined at 1134.'>PyAPI_FUNC</a>
</ol>
<hr>
<pre>
<a name='L1'><i><font color='green'>/* -*- Mode: C; c-file-style: "python" -*- */</font></i>
<a name='L2'>
<a name='L3'><font color='darkred'>#include</font> &lt;<a href='570.html'>Python.h</a>&gt;
<a name='L4'><font color='darkred'>#include</font> &lt;locale.h&gt;
<a name='L5'>
<a name='L6'><i><font color='green'>/* Case-insensitive string match used for nan and inf detection; t should be</font></i>
<a name='L7'><i><font color='green'>   lower-case.  Returns 1 for a successful match, 0 otherwise. */</font></i>
<a name='L8'>
<a name='L9'><b>static</b> <b>int</b>
<a name='L10'><a href='../R/6580.html' title='Multiple refered from 3 places.'>case_insensitive_match</a>(<b>const</b> <b>char</b> *s, <b>const</b> <b>char</b> *t)
<a name='L11'><font color='red'>{</font>
<a name='L12'>    <b>while</b>(*t &amp;&amp; <a href='../S/556.html#L29' title='Defined at 29 in Include/pyctype.h.'>Py_TOLOWER</a>(*s) == *t) <font color='red'>{</font>
<a name='L13'>        s++;
<a name='L14'>        t++;
<a name='L15'>    <font color='red'>}</font>
<a name='L16'>    <b>return</b> *t ? 0 : 1;
<a name='L17'><font color='red'>}</font>
<a name='L18'>
<a name='L19'><i><font color='green'>/* _Py_parse_inf_or_nan: Attempt to parse a string of the form "nan", "inf" or</font></i>
<a name='L20'><i><font color='green'>   "infinity", with an optional leading sign of "+" or "-".  On success,</font></i>
<a name='L21'><i><font color='green'>   return the NaN or Infinity as a double and set *endptr to point just beyond</font></i>
<a name='L22'><i><font color='green'>   the successfully parsed portion of the string.  On failure, return -1.0 and</font></i>
<a name='L23'><i><font color='green'>   set *endptr to point to the start of the string. */</font></i>
<a name='L24'>
<a name='L25'><b>double</b>
<a name='L26'><a href='../R/5636.html' title='Multiple refered from 3 places.'>_Py_parse_inf_or_nan</a>(<b>const</b> <b>char</b> *p, <b>char</b> **endptr)
<a name='L27'><font color='red'>{</font>
<a name='L28'>    <b>double</b> retval;
<a name='L29'>    <b>const</b> <b>char</b> *s;
<a name='L30'>    <b>int</b> negate = 0;
<a name='L31'>
<a name='L32'>    s = p;
<a name='L33'>    <b>if</b> (*s == '-') <font color='red'>{</font>
<a name='L34'>        negate = 1;
<a name='L35'>        s++;
<a name='L36'>    <font color='red'>}</font>
<a name='L37'>    <b>else</b> <b>if</b> (*s == '+') <font color='red'>{</font>
<a name='L38'>        s++;
<a name='L39'>    <font color='red'>}</font>
<a name='L40'>    <b>if</b> (<a href='../S/3136.html#L10' title='Defined at 10 in Python/pystrtod.c.'>case_insensitive_match</a>(s, "inf")) <font color='red'>{</font>
<a name='L41'>        s += 3;
<a name='L42'>        <b>if</b> (<a href='../S/3136.html#L10' title='Defined at 10 in Python/pystrtod.c.'>case_insensitive_match</a>(s, "inity"))
<a name='L43'>            s += 5;
<a name='L44'>        retval = negate ? -<a href='../S/563.html#L150' title='Defined at 150 in Include/pymath.h.'>Py_HUGE_VAL</a> : <a href='../S/563.html#L150' title='Defined at 150 in Include/pymath.h.'>Py_HUGE_VAL</a>;
<a name='L45'>    <font color='red'>}</font>
<a name='L46'><font color='darkred'>#ifdef</font> <a href='../S/563.html#L159' title='Defined at 159 in Include/pymath.h.'>Py_NAN</a>
<a name='L47'>    <b>else</b> <b>if</b> (<a href='../S/3136.html#L10' title='Defined at 10 in Python/pystrtod.c.'>case_insensitive_match</a>(s, "nan")) <font color='red'>{</font>
<a name='L48'>        s += 3;
<a name='L49'>        retval = negate ? -<a href='../S/563.html#L159' title='Defined at 159 in Include/pymath.h.'>Py_NAN</a> : <a href='../S/563.html#L159' title='Defined at 159 in Include/pymath.h.'>Py_NAN</a>;
<a name='L50'>    <font color='red'>}</font>
<a name='L51'><font color='darkred'>#endif</font>
<a name='L52'>    <b>else</b> <font color='red'>{</font>
<a name='L53'>        s = p;
<a name='L54'>        retval = -1.0;
<a name='L55'>    <font color='red'>}</font>
<a name='L56'>    *endptr = (<b>char</b> *)s;
<a name='L57'>    <b>return</b> retval;
<a name='L58'><font color='red'>}</font>
<a name='L59'>
<a name='L60'><i><font color='green'>/**</font></i>
<a name='L61'><i><font color='green'> * _PyOS_ascii_strtod:</font></i>
<a name='L62'><i><font color='green'> * @nptr:    the string to convert to a numeric value.</font></i>
<a name='L63'><i><font color='green'> * @endptr:  if non-%NULL, it returns the character after</font></i>
<a name='L64'><i><font color='green'> *           the last character used in the conversion.</font></i>
<a name='L65'><i><font color='green'> *</font></i>
<a name='L66'><i><font color='green'> * Converts a string to a #gdouble value.</font></i>
<a name='L67'><i><font color='green'> * This function behaves like the standard strtod() function</font></i>
<a name='L68'><i><font color='green'> * does in the C locale. It does this without actually</font></i>
<a name='L69'><i><font color='green'> * changing the current locale, since that would not be</font></i>
<a name='L70'><i><font color='green'> * thread-safe.</font></i>
<a name='L71'><i><font color='green'> *</font></i>
<a name='L72'><i><font color='green'> * This function is typically used when reading configuration</font></i>
<a name='L73'><i><font color='green'> * files or other non-user input that should be locale independent.</font></i>
<a name='L74'><i><font color='green'> * To handle input from the user you should normally use the</font></i>
<a name='L75'><i><font color='green'> * locale-sensitive system strtod() function.</font></i>
<a name='L76'><i><font color='green'> *</font></i>
<a name='L77'><i><font color='green'> * If the correct value would cause overflow, plus or minus %HUGE_VAL</font></i>
<a name='L78'><i><font color='green'> * is returned (according to the sign of the value), and %ERANGE is</font></i>
<a name='L79'><i><font color='green'> * stored in %errno. If the correct value would cause underflow,</font></i>
<a name='L80'><i><font color='green'> * zero is returned and %ERANGE is stored in %errno.</font></i>
<a name='L81'><i><font color='green'> * If memory allocation fails, %ENOMEM is stored in %errno.</font></i>
<a name='L82'><i><font color='green'> *</font></i>
<a name='L83'><i><font color='green'> * This function resets %errno before calling strtod() so that</font></i>
<a name='L84'><i><font color='green'> * you can reliably detect overflow and underflow.</font></i>
<a name='L85'><i><font color='green'> *</font></i>
<a name='L86'><i><font color='green'> * Return value: the #gdouble value.</font></i>
<a name='L87'><i><font color='green'> **/</font></i>
<a name='L88'>
<a name='L89'><font color='darkred'>#ifndef</font> <a href='../D/2612.html' title='Multiple defined in 2 places.'>PY_NO_SHORT_FLOAT_REPR</a>
<a name='L90'>
<a name='L91'><b>static</b> <b>double</b>
<a name='L92'><a href='../S/3136.html#L307' title='Refered from 307 in Python/pystrtod.c.'>_PyOS_ascii_strtod</a>(<b>const</b> <b>char</b> *nptr, <b>char</b> **endptr)
<a name='L93'><font color='red'>{</font>
<a name='L94'>    <b>double</b> <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a>;
<a name='L95'>    <a href='../D/6314.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_HEADER</a>;
<a name='L96'>
<a name='L97'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(nptr != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>);
<a name='L98'>    <i><font color='green'>/* Set errno to zero, so that we can distinguish zero results</font></i>
<a name='L99'><i><font color='green'>       and underflows */</font></i>
<a name='L100'>    errno = 0;
<a name='L101'>
<a name='L102'>    <a href='../D/6315.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_START</a>;
<a name='L103'>    <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a> = <a href='../S/3095.html#L1490' title='Defined at 1490 in Python/dtoa.c.'>_Py_dg_strtod</a>(nptr, endptr);
<a name='L104'>    <a href='../D/6313.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_END</a>;
<a name='L105'>
<a name='L106'>    <b>if</b> (*endptr == nptr)
<a name='L107'>        <i><font color='green'>/* string might represent an inf or nan */</font></i>
<a name='L108'>        <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a> = <a href='../S/3136.html#L26' title='Defined at 26 in Python/pystrtod.c.'>_Py_parse_inf_or_nan</a>(nptr, endptr);
<a name='L109'>
<a name='L110'>    <b>return</b> <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a>;
<a name='L111'>
<a name='L112'><font color='red'>}</font>
<a name='L113'>
<a name='L114'><font color='darkred'>#else</font>
<a name='L115'>
<a name='L116'><i><font color='green'>/*</font></i>
<a name='L117'><i><font color='green'>   Use system strtod;  since strtod is locale aware, we may</font></i>
<a name='L118'><i><font color='green'>   have to first fix the decimal separator.</font></i>
<a name='L119'><i><font color='green'></font></i>
<a name='L120'><i><font color='green'>   Note that unlike _Py_dg_strtod, the system strtod may not always give</font></i>
<a name='L121'><i><font color='green'>   correctly rounded results.</font></i>
<a name='L122'><i><font color='green'>*/</font></i>
<a name='L123'>
<a name='L124'><b>static</b> <b>double</b>
<a name='L125'><a href='../S/3136.html#L307' title='Refered from 307 in Python/pystrtod.c.'>_PyOS_ascii_strtod</a>(<b>const</b> <b>char</b> *nptr, <b>char</b> **endptr)
<a name='L126'><font color='red'>{</font>
<a name='L127'>    <b>char</b> *fail_pos;
<a name='L128'>    <b>double</b> val = -1.0;
<a name='L129'>    <b>struct</b> lconv *locale_data;
<a name='L130'>    <b>const</b> <b>char</b> *decimal_point;
<a name='L131'>    <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> decimal_point_len;
<a name='L132'>    <b>const</b> <b>char</b> *p, *decimal_point_pos;
<a name='L133'>    <b>const</b> <b>char</b> *end = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>; <i><font color='green'>/* Silence gcc */</font></i>
<a name='L134'>    <b>const</b> <b>char</b> *digits_pos = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L135'>    <b>int</b> negate = 0;
<a name='L136'>
<a name='L137'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(nptr != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>);
<a name='L138'>
<a name='L139'>    fail_pos = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L140'>
<a name='L141'>    locale_data = localeconv();
<a name='L142'>    decimal_point = locale_data-&gt;decimal_point;
<a name='L143'>    decimal_point_len = strlen(decimal_point);
<a name='L144'>
<a name='L145'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(decimal_point_len != 0);
<a name='L146'>
<a name='L147'>    decimal_point_pos = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L148'>
<a name='L149'>    <i><font color='green'>/* Parse infinities and nans */</font></i>
<a name='L150'>    val = <a href='../S/3136.html#L26' title='Defined at 26 in Python/pystrtod.c.'>_Py_parse_inf_or_nan</a>(nptr, endptr);
<a name='L151'>    <b>if</b> (*endptr != nptr)
<a name='L152'>        <b>return</b> val;
<a name='L153'>
<a name='L154'>    <i><font color='green'>/* Set errno to zero, so that we can distinguish zero results</font></i>
<a name='L155'><i><font color='green'>       and underflows */</font></i>
<a name='L156'>    errno = 0;
<a name='L157'>
<a name='L158'>    <i><font color='green'>/* We process the optional sign manually, then pass the remainder to</font></i>
<a name='L159'><i><font color='green'>       the system strtod.  This ensures that the result of an underflow</font></i>
<a name='L160'><i><font color='green'>       has the correct sign. (bug #1725)  */</font></i>
<a name='L161'>    p = nptr;
<a name='L162'>    <i><font color='green'>/* Process leading sign, if present */</font></i>
<a name='L163'>    <b>if</b> (*p == '-') <font color='red'>{</font>
<a name='L164'>        negate = 1;
<a name='L165'>        p++;
<a name='L166'>    <font color='red'>}</font>
<a name='L167'>    <b>else</b> <b>if</b> (*p == '+') <font color='red'>{</font>
<a name='L168'>        p++;
<a name='L169'>    <font color='red'>}</font>
<a name='L170'>
<a name='L171'>    <i><font color='green'>/* Some platform strtods accept hex floats; Python shouldn't (at the</font></i>
<a name='L172'><i><font color='green'>       moment), so we check explicitly for strings starting with '0x'. */</font></i>
<a name='L173'>    <b>if</b> (*p == '0' &amp;&amp; (*(p+1) == 'x' || *(p+1) == 'X'))
<a name='L174'>        <b>goto</b> invalid_string;
<a name='L175'>
<a name='L176'>    <i><font color='green'>/* Check that what's left begins with a digit or decimal point */</font></i>
<a name='L177'>    <b>if</b> (!<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p) &amp;&amp; *p != '.')
<a name='L178'>        <b>goto</b> invalid_string;
<a name='L179'>
<a name='L180'>    digits_pos = p;
<a name='L181'>    <b>if</b> (decimal_point[0] != '.' ||
<a name='L182'>        decimal_point[1] != 0)
<a name='L183'>    <font color='red'>{</font>
<a name='L184'>        <i><font color='green'>/* Look for a '.' in the input; if present, it'll need to be</font></i>
<a name='L185'><i><font color='green'>           swapped for the current locale's decimal point before we</font></i>
<a name='L186'><i><font color='green'>           call strtod.  On the other hand, if we find the current</font></i>
<a name='L187'><i><font color='green'>           locale's decimal point then the input is invalid. */</font></i>
<a name='L188'>        <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L189'>            p++;
<a name='L190'>
<a name='L191'>        <b>if</b> (*p == '.')
<a name='L192'>        <font color='red'>{</font>
<a name='L193'>            decimal_point_pos = p++;
<a name='L194'>
<a name='L195'>            <i><font color='green'>/* locate end of number */</font></i>
<a name='L196'>            <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L197'>                p++;
<a name='L198'>
<a name='L199'>            <b>if</b> (*p == 'e' || *p == 'E')
<a name='L200'>                p++;
<a name='L201'>            <b>if</b> (*p == '+' || *p == '-')
<a name='L202'>                p++;
<a name='L203'>            <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L204'>                p++;
<a name='L205'>            end = p;
<a name='L206'>        <font color='red'>}</font>
<a name='L207'>        <b>else</b> <b>if</b> (strncmp(p, decimal_point, decimal_point_len) == 0)
<a name='L208'>            <i><font color='green'>/* Python bug #1417699 */</font></i>
<a name='L209'>            <b>goto</b> invalid_string;
<a name='L210'>        <i><font color='green'>/* For the other cases, we need not convert the decimal</font></i>
<a name='L211'><i><font color='green'>           point */</font></i>
<a name='L212'>    <font color='red'>}</font>
<a name='L213'>
<a name='L214'>    <b>if</b> (decimal_point_pos) <font color='red'>{</font>
<a name='L215'>        <b>char</b> *copy, *c;
<a name='L216'>        <i><font color='green'>/* Create a copy of the input, with the '.' converted to the</font></i>
<a name='L217'><i><font color='green'>           locale-specific decimal point */</font></i>
<a name='L218'>        copy = (<b>char</b> *)PyMem_MALLOC(end - digits_pos +
<a name='L219'>                                    1 + decimal_point_len);
<a name='L220'>        <b>if</b> (copy == <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) <font color='red'>{</font>
<a name='L221'>            *endptr = (<b>char</b> *)nptr;
<a name='L222'>            errno = ENOMEM;
<a name='L223'>            <b>return</b> val;
<a name='L224'>        <font color='red'>}</font>
<a name='L225'>
<a name='L226'>        c = copy;
<a name='L227'>        <a href='../D/9803.html' title='Multiple defined in 4 places.'>memcpy</a>(c, digits_pos, decimal_point_pos - digits_pos);
<a name='L228'>        c += decimal_point_pos - digits_pos;
<a name='L229'>        <a href='../D/9803.html' title='Multiple defined in 4 places.'>memcpy</a>(c, decimal_point, decimal_point_len);
<a name='L230'>        c += decimal_point_len;
<a name='L231'>        <a href='../D/9803.html' title='Multiple defined in 4 places.'>memcpy</a>(c, decimal_point_pos + 1,
<a name='L232'>               end - (decimal_point_pos + 1));
<a name='L233'>        c += end - (decimal_point_pos + 1);
<a name='L234'>        *c = 0;
<a name='L235'>
<a name='L236'>        val = strtod(copy, &amp;fail_pos);
<a name='L237'>
<a name='L238'>        <b>if</b> (fail_pos)
<a name='L239'>        <font color='red'>{</font>
<a name='L240'>            <b>if</b> (fail_pos &gt; decimal_point_pos)
<a name='L241'>                fail_pos = (<b>char</b> *)digits_pos +
<a name='L242'>                    (fail_pos - copy) -
<a name='L243'>                    (decimal_point_len - 1);
<a name='L244'>            <b>else</b>
<a name='L245'>                fail_pos = (<b>char</b> *)digits_pos +
<a name='L246'>                    (fail_pos - copy);
<a name='L247'>        <font color='red'>}</font>
<a name='L248'>
<a name='L249'>        PyMem_FREE(copy);
<a name='L250'>
<a name='L251'>    <font color='red'>}</font>
<a name='L252'>    <b>else</b> <font color='red'>{</font>
<a name='L253'>        val = strtod(digits_pos, &amp;fail_pos);
<a name='L254'>    <font color='red'>}</font>
<a name='L255'>
<a name='L256'>    <b>if</b> (fail_pos == digits_pos)
<a name='L257'>        <b>goto</b> invalid_string;
<a name='L258'>
<a name='L259'>    <b>if</b> (negate &amp;&amp; fail_pos != nptr)
<a name='L260'>        val = -val;
<a name='L261'>    *endptr = fail_pos;
<a name='L262'>
<a name='L263'>    <b>return</b> val;
<a name='L264'>
<a name='L265'>  invalid_string:
<a name='L266'>    *endptr = (<b>char</b>*)nptr;
<a name='L267'>    errno = EINVAL;
<a name='L268'>    <b>return</b> -1.0;
<a name='L269'><font color='red'>}</font>
<a name='L270'>
<a name='L271'><font color='darkred'>#endif</font>
<a name='L272'>
<a name='L273'><i><font color='green'>/* PyOS_string_to_double converts a null-terminated byte string s (interpreted</font></i>
<a name='L274'><i><font color='green'>   as a string of ASCII characters) to a float.  The string should not have</font></i>
<a name='L275'><i><font color='green'>   leading or trailing whitespace.  The conversion is independent of the</font></i>
<a name='L276'><i><font color='green'>   current locale.</font></i>
<a name='L277'><i><font color='green'></font></i>
<a name='L278'><i><font color='green'>   If endptr is NULL, try to convert the whole string.  Raise ValueError and</font></i>
<a name='L279'><i><font color='green'>   return -1.0 if the string is not a valid representation of a floating-point</font></i>
<a name='L280'><i><font color='green'>   number.</font></i>
<a name='L281'><i><font color='green'></font></i>
<a name='L282'><i><font color='green'>   If endptr is non-NULL, try to convert as much of the string as possible.</font></i>
<a name='L283'><i><font color='green'>   If no initial segment of the string is the valid representation of a</font></i>
<a name='L284'><i><font color='green'>   floating-point number then *endptr is set to point to the beginning of the</font></i>
<a name='L285'><i><font color='green'>   string, -1.0 is returned and again ValueError is raised.</font></i>
<a name='L286'><i><font color='green'></font></i>
<a name='L287'><i><font color='green'>   On overflow (e.g., when trying to convert '1e500' on an IEEE 754 machine),</font></i>
<a name='L288'><i><font color='green'>   if overflow_exception is NULL then +-Py_HUGE_VAL is returned, and no Python</font></i>
<a name='L289'><i><font color='green'>   exception is raised.  Otherwise, overflow_exception should point to a</font></i>
<a name='L290'><i><font color='green'>   a Python exception, this exception will be raised, -1.0 will be returned,</font></i>
<a name='L291'><i><font color='green'>   and *endptr will point just past the end of the converted value.</font></i>
<a name='L292'><i><font color='green'></font></i>
<a name='L293'><i><font color='green'>   If any other failure occurs (for example lack of memory), -1.0 is returned</font></i>
<a name='L294'><i><font color='green'>   and the appropriate Python exception will have been set.</font></i>
<a name='L295'><i><font color='green'>*/</font></i>
<a name='L296'>
<a name='L297'><b>double</b>
<a name='L298'><a href='../R/3237.html' title='Multiple refered from 11 places.'>PyOS_string_to_double</a>(<b>const</b> <b>char</b> *s,
<a name='L299'>                      <b>char</b> **endptr,
<a name='L300'>                      PyObject *overflow_exception)
<a name='L301'><font color='red'>{</font>
<a name='L302'>    <b>double</b> x, <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a>=-1.0;
<a name='L303'>    <b>char</b> *fail_pos;
<a name='L304'>
<a name='L305'>    errno = 0;
<a name='L306'>    <a href='../D/3220.html' title='Multiple defined in 2 places.'>PyFPE_START_PROTECT</a>("PyOS_string_to_double", <b>return</b> -1.0)
<a name='L307'>    x = <a href='../D/6138.html' title='Multiple defined in 2 places.'>_PyOS_ascii_strtod</a>(s, &amp;fail_pos);
<a name='L308'>    <a href='../D/3219.html' title='Multiple defined in 2 places.'>PyFPE_END_PROTECT</a>(x)
<a name='L309'>
<a name='L310'>    <b>if</b> (errno == ENOMEM) <font color='red'>{</font>
<a name='L311'>        <a href='../S/3106.html#L334' title='Defined at 334 in Python/errors.c.'>PyErr_NoMemory</a>();
<a name='L312'>        fail_pos = (<b>char</b> *)s;
<a name='L313'>    <font color='red'>}</font>
<a name='L314'>    <b>else</b> <b>if</b> (!endptr &amp;&amp; (fail_pos == s || *fail_pos != '\0'))
<a name='L315'>        <a href='../S/3106.html#L600' title='Defined at 600 in Python/errors.c.'>PyErr_Format</a>(PyExc_ValueError,
<a name='L316'>                      "could not convert string to float: "
<a name='L317'>                      "%.200s", s);
<a name='L318'>    <b>else</b> <b>if</b> (fail_pos == s)
<a name='L319'>        <a href='../S/3106.html#L600' title='Defined at 600 in Python/errors.c.'>PyErr_Format</a>(PyExc_ValueError,
<a name='L320'>                      "could not convert string to float: "
<a name='L321'>                      "%.200s", s);
<a name='L322'>    <b>else</b> <b>if</b> (errno == ERANGE &amp;&amp; fabs(x) &gt;= 1.0 &amp;&amp; overflow_exception)
<a name='L323'>        <a href='../S/3106.html#L600' title='Defined at 600 in Python/errors.c.'>PyErr_Format</a>(overflow_exception,
<a name='L324'>                      "value too large to convert to float: "
<a name='L325'>                      "%.200s", s);
<a name='L326'>    <b>else</b>
<a name='L327'>        <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a> = x;
<a name='L328'>
<a name='L329'>    <b>if</b> (endptr != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>)
<a name='L330'>        *endptr = fail_pos;
<a name='L331'>    <b>return</b> <a href='../S/2250.html#L579' title='Defined at 579 in Modules/_ctypes/callproc.c.'>result</a>;
<a name='L332'><font color='red'>}</font>
<a name='L333'>
<a name='L334'><font color='darkred'>#ifdef</font> <a href='../D/2612.html' title='Multiple defined in 2 places.'>PY_NO_SHORT_FLOAT_REPR</a>
<a name='L335'>
<a name='L336'><i><font color='green'>/* Given a string that may have a decimal point in the current</font></i>
<a name='L337'><i><font color='green'>   locale, change it back to a dot.  Since the string cannot get</font></i>
<a name='L338'><i><font color='green'>   longer, no need for a maximum buffer size parameter. */</font></i>
<a name='L339'>Py_LOCAL_INLINE(<b>void</b>)
<a name='L340'>change_decimal_from_locale_to_dot(<b>char</b>* buffer)
<a name='L341'><font color='red'>{</font>
<a name='L342'>    <b>struct</b> lconv *locale_data = localeconv();
<a name='L343'>    <b>const</b> <b>char</b> *decimal_point = locale_data-&gt;decimal_point;
<a name='L344'>
<a name='L345'>    <b>if</b> (decimal_point[0] != '.' || decimal_point[1] != 0) <font color='red'>{</font>
<a name='L346'>        <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> decimal_point_len = strlen(decimal_point);
<a name='L347'>
<a name='L348'>        <b>if</b> (*<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> == '+' || *<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> == '-')
<a name='L349'>            <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>++;
<a name='L350'>        <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>))
<a name='L351'>            <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>++;
<a name='L352'>        <b>if</b> (strncmp(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>, decimal_point, decimal_point_len) == 0) <font color='red'>{</font>
<a name='L353'>            *<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> = '.';
<a name='L354'>            <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>++;
<a name='L355'>            <b>if</b> (decimal_point_len &gt; 1) <font color='red'>{</font>
<a name='L356'>                <i><font color='green'>/* buffer needs to get smaller */</font></i>
<a name='L357'>                <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> rest_len = strlen(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> +
<a name='L358'>                                     (decimal_point_len - 1));
<a name='L359'>                <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>,
<a name='L360'>                    <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> + (decimal_point_len - 1),
<a name='L361'>                    rest_len);
<a name='L362'>                <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>[rest_len] = 0;
<a name='L363'>            <font color='red'>}</font>
<a name='L364'>        <font color='red'>}</font>
<a name='L365'>    <font color='red'>}</font>
<a name='L366'><font color='red'>}</font>
<a name='L367'>
<a name='L368'>
<a name='L369'><i><font color='green'>/* From the C99 standard, section 7.19.6:</font></i>
<a name='L370'><i><font color='green'>The exponent always contains at least two digits, and only as many more digits</font></i>
<a name='L371'><i><font color='green'>as necessary to represent the exponent.</font></i>
<a name='L372'><i><font color='green'>*/</font></i>
<a name='L373'><font color='darkred'>#define</font> <a href='../R/1933.html' title='Multiple refered from 5 places.'>MIN_EXPONENT_DIGITS</a> 2
<a name='L374'>
<a name='L375'><i><font color='green'>/* Ensure that any exponent, if present, is at least MIN_EXPONENT_DIGITS</font></i>
<a name='L376'><i><font color='green'>   in length. */</font></i>
<a name='L377'>Py_LOCAL_INLINE(<b>void</b>)
<a name='L378'>ensure_minimum_exponent_length(<b>char</b>* buffer, <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> buf_size)
<a name='L379'><font color='red'>{</font>
<a name='L380'>    <b>char</b> *p = strpbrk(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>, "eE");
<a name='L381'>    <b>if</b> (p &amp;&amp; (*(p + 1) == '-' || *(p + 1) == '+')) <font color='red'>{</font>
<a name='L382'>        <b>char</b> *start = p + 2;
<a name='L383'>        <b>int</b> exponent_digit_cnt = 0;
<a name='L384'>        <b>int</b> leading_zero_cnt = 0;
<a name='L385'>        <b>int</b> in_leading_zeros = 1;
<a name='L386'>        <b>int</b> significant_digit_cnt;
<a name='L387'>
<a name='L388'>        <i><font color='green'>/* Skip over the exponent and the sign. */</font></i>
<a name='L389'>        p += 2;
<a name='L390'>
<a name='L391'>        <i><font color='green'>/* Find the end of the exponent, keeping track of leading</font></i>
<a name='L392'><i><font color='green'>           zeros. */</font></i>
<a name='L393'>        <b>while</b> (*p &amp;&amp; <a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p)) <font color='red'>{</font>
<a name='L394'>            <b>if</b> (in_leading_zeros &amp;&amp; *p == '0')
<a name='L395'>                ++leading_zero_cnt;
<a name='L396'>            <b>if</b> (*p != '0')
<a name='L397'>                in_leading_zeros = 0;
<a name='L398'>            ++p;
<a name='L399'>            ++exponent_digit_cnt;
<a name='L400'>        <font color='red'>}</font>
<a name='L401'>
<a name='L402'>        significant_digit_cnt = exponent_digit_cnt - leading_zero_cnt;
<a name='L403'>        <b>if</b> (exponent_digit_cnt == <a href='../S/3136.html#L373' title='Defined at 373 in Python/pystrtod.c.'>MIN_EXPONENT_DIGITS</a>) <font color='red'>{</font>
<a name='L404'>            <i><font color='green'>/* If there are 2 exactly digits, we're done,</font></i>
<a name='L405'><i><font color='green'>               regardless of what they contain */</font></i>
<a name='L406'>        <font color='red'>}</font>
<a name='L407'>        <b>else</b> <b>if</b> (exponent_digit_cnt &gt; <a href='../S/3136.html#L373' title='Defined at 373 in Python/pystrtod.c.'>MIN_EXPONENT_DIGITS</a>) <font color='red'>{</font>
<a name='L408'>            <b>int</b> extra_zeros_cnt;
<a name='L409'>
<a name='L410'>            <i><font color='green'>/* There are more than 2 digits in the exponent.  See</font></i>
<a name='L411'><i><font color='green'>               if we can delete some of the leading zeros */</font></i>
<a name='L412'>            <b>if</b> (significant_digit_cnt &lt; <a href='../S/3136.html#L373' title='Defined at 373 in Python/pystrtod.c.'>MIN_EXPONENT_DIGITS</a>)
<a name='L413'>                significant_digit_cnt = <a href='../S/3136.html#L373' title='Defined at 373 in Python/pystrtod.c.'>MIN_EXPONENT_DIGITS</a>;
<a name='L414'>            extra_zeros_cnt = exponent_digit_cnt -
<a name='L415'>                significant_digit_cnt;
<a name='L416'>
<a name='L417'>            <i><font color='green'>/* Delete extra_zeros_cnt worth of characters from the</font></i>
<a name='L418'><i><font color='green'>               front of the exponent */</font></i>
<a name='L419'>            <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(extra_zeros_cnt &gt;= 0);
<a name='L420'>
<a name='L421'>            <i><font color='green'>/* Add one to significant_digit_cnt to copy the</font></i>
<a name='L422'><i><font color='green'>               trailing 0 byte, thus setting the length */</font></i>
<a name='L423'>            <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(start,
<a name='L424'>                start + extra_zeros_cnt,
<a name='L425'>                significant_digit_cnt + 1);
<a name='L426'>        <font color='red'>}</font>
<a name='L427'>        <b>else</b> <font color='red'>{</font>
<a name='L428'>            <i><font color='green'>/* If there are fewer than 2 digits, add zeros</font></i>
<a name='L429'><i><font color='green'>               until there are 2, if there's enough room */</font></i>
<a name='L430'>            <b>int</b> zeros = <a href='../S/3136.html#L373' title='Defined at 373 in Python/pystrtod.c.'>MIN_EXPONENT_DIGITS</a> - exponent_digit_cnt;
<a name='L431'>            <b>if</b> (start + zeros + exponent_digit_cnt + 1
<a name='L432'>                  &lt; <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> + buf_size) <font color='red'>{</font>
<a name='L433'>                <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(start + zeros, start,
<a name='L434'>                    exponent_digit_cnt + 1);
<a name='L435'>                memset(start, '0', zeros);
<a name='L436'>            <font color='red'>}</font>
<a name='L437'>        <font color='red'>}</font>
<a name='L438'>    <font color='red'>}</font>
<a name='L439'><font color='red'>}</font>
<a name='L440'>
<a name='L441'><i><font color='green'>/* Remove trailing zeros after the decimal point from a numeric string; also</font></i>
<a name='L442'><i><font color='green'>   remove the decimal point if all digits following it are zero.  The numeric</font></i>
<a name='L443'><i><font color='green'>   string must end in '\0', and should not have any leading or trailing</font></i>
<a name='L444'><i><font color='green'>   whitespace.  Assumes that the decimal point is '.'. */</font></i>
<a name='L445'>Py_LOCAL_INLINE(<b>void</b>)
<a name='L446'>remove_trailing_zeros(<b>char</b> *buffer)
<a name='L447'><font color='red'>{</font>
<a name='L448'>    <b>char</b> *old_fraction_end, *new_fraction_end, *end, *p;
<a name='L449'>
<a name='L450'>    p = <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>;
<a name='L451'>    <b>if</b> (*p == '-' || *p == '+')
<a name='L452'>        <i><font color='green'>/* Skip leading sign, if present */</font></i>
<a name='L453'>        ++p;
<a name='L454'>    <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L455'>        ++p;
<a name='L456'>
<a name='L457'>    <i><font color='green'>/* if there's no decimal point there's nothing to do */</font></i>
<a name='L458'>    <b>if</b> (*p++ != '.')
<a name='L459'>        <b>return</b>;
<a name='L460'>
<a name='L461'>    <i><font color='green'>/* scan any digits after the point */</font></i>
<a name='L462'>    <b>while</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L463'>        ++p;
<a name='L464'>    old_fraction_end = p;
<a name='L465'>
<a name='L466'>    <i><font color='green'>/* scan up to ending '\0' */</font></i>
<a name='L467'>    <b>while</b> (*p != '\0')
<a name='L468'>        p++;
<a name='L469'>    <i><font color='green'>/* +1 to make sure that we move the null byte as well */</font></i>
<a name='L470'>    end = p+1;
<a name='L471'>
<a name='L472'>    <i><font color='green'>/* scan back from fraction_end, looking for removable zeros */</font></i>
<a name='L473'>    p = old_fraction_end;
<a name='L474'>    <b>while</b> (*(p-1) == '0')
<a name='L475'>        --p;
<a name='L476'>    <i><font color='green'>/* and remove point if we've got that far */</font></i>
<a name='L477'>    <b>if</b> (*(p-1) == '.')
<a name='L478'>        --p;
<a name='L479'>    new_fraction_end = p;
<a name='L480'>
<a name='L481'>    <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(new_fraction_end, old_fraction_end, end-old_fraction_end);
<a name='L482'><font color='red'>}</font>
<a name='L483'>
<a name='L484'><i><font color='green'>/* Ensure that buffer has a decimal point in it.  The decimal point will not</font></i>
<a name='L485'><i><font color='green'>   be in the current locale, it will always be '.'. Don't add a decimal point</font></i>
<a name='L486'><i><font color='green'>   if an exponent is present.  Also, convert to exponential notation where</font></i>
<a name='L487'><i><font color='green'>   adding a '.0' would produce too many significant digits (see issue 5864).</font></i>
<a name='L488'><i><font color='green'></font></i>
<a name='L489'><i><font color='green'>   Returns a pointer to the fixed buffer, or NULL on failure.</font></i>
<a name='L490'><i><font color='green'>*/</font></i>
<a name='L491'>Py_LOCAL_INLINE(<b>char</b> *)
<a name='L492'>ensure_decimal_point(<b>char</b>* buffer, <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> buf_size, <b>int</b> precision)
<a name='L493'><font color='red'>{</font>
<a name='L494'>    <b>int</b> digit_count, insert_count = 0, convert_to_exp = 0;
<a name='L495'>    <b>char</b> *chars_to_insert, *digits_start;
<a name='L496'>
<a name='L497'>    <i><font color='green'>/* search for the first non-digit character */</font></i>
<a name='L498'>    <b>char</b> *p = <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>;
<a name='L499'>    <b>if</b> (*p == '-' || *p == '+')
<a name='L500'>        <i><font color='green'>/* Skip leading sign, if present.  I think this could only</font></i>
<a name='L501'><i><font color='green'>           ever be '-', but it can't hurt to check for both. */</font></i>
<a name='L502'>        ++p;
<a name='L503'>    digits_start = p;
<a name='L504'>    <b>while</b> (*p &amp;&amp; <a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*p))
<a name='L505'>        ++p;
<a name='L506'>    digit_count = <a href='../D/4230.html' title='Multiple defined in 2 places.'>Py_SAFE_DOWNCAST</a>(p - digits_start, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>, <b>int</b>);
<a name='L507'>
<a name='L508'>    <b>if</b> (*p == '.') <font color='red'>{</font>
<a name='L509'>        <b>if</b> (<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(*(p+1))) <font color='red'>{</font>
<a name='L510'>            <i><font color='green'>/* Nothing to do, we already have a decimal</font></i>
<a name='L511'><i><font color='green'>               point and a digit after it */</font></i>
<a name='L512'>        <font color='red'>}</font>
<a name='L513'>        <b>else</b> <font color='red'>{</font>
<a name='L514'>            <i><font color='green'>/* We have a decimal point, but no following</font></i>
<a name='L515'><i><font color='green'>               digit.  Insert a zero after the decimal. */</font></i>
<a name='L516'>            <i><font color='green'>/* can't ever get here via PyOS_double_to_string */</font></i>
<a name='L517'>            <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(precision == -1);
<a name='L518'>            ++p;
<a name='L519'>            chars_to_insert = "0";
<a name='L520'>            insert_count = 1;
<a name='L521'>        <font color='red'>}</font>
<a name='L522'>    <font color='red'>}</font>
<a name='L523'>    <b>else</b> <b>if</b> (!(*p == 'e' || *p == 'E')) <font color='red'>{</font>
<a name='L524'>        <i><font color='green'>/* Don't add ".0" if we have an exponent. */</font></i>
<a name='L525'>        <b>if</b> (digit_count == precision) <font color='red'>{</font>
<a name='L526'>            <i><font color='green'>/* issue 5864: don't add a trailing .0 in the case</font></i>
<a name='L527'><i><font color='green'>               where the '%g'-formatted result already has as many</font></i>
<a name='L528'><i><font color='green'>               significant digits as were requested.  Switch to</font></i>
<a name='L529'><i><font color='green'>               exponential notation instead. */</font></i>
<a name='L530'>            convert_to_exp = 1;
<a name='L531'>            <i><font color='green'>/* no exponent, no point, and we shouldn't land here</font></i>
<a name='L532'><i><font color='green'>               for infs and nans, so we must be at the end of the</font></i>
<a name='L533'><i><font color='green'>               string. */</font></i>
<a name='L534'>            <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(*p == '\0');
<a name='L535'>        <font color='red'>}</font>
<a name='L536'>        <b>else</b> <font color='red'>{</font>
<a name='L537'>            <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(precision == -1 || digit_count &lt; precision);
<a name='L538'>            chars_to_insert = ".0";
<a name='L539'>            insert_count = 2;
<a name='L540'>        <font color='red'>}</font>
<a name='L541'>    <font color='red'>}</font>
<a name='L542'>    <b>if</b> (insert_count) <font color='red'>{</font>
<a name='L543'>        <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> buf_len = strlen(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>);
<a name='L544'>        <b>if</b> (buf_len + insert_count + 1 &gt;= buf_size) <font color='red'>{</font>
<a name='L545'>            <i><font color='green'>/* If there is not enough room in the buffer</font></i>
<a name='L546'><i><font color='green'>               for the additional text, just skip it.  It's</font></i>
<a name='L547'><i><font color='green'>               not worth generating an error over. */</font></i>
<a name='L548'>        <font color='red'>}</font>
<a name='L549'>        <b>else</b> <font color='red'>{</font>
<a name='L550'>            <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(p + insert_count, p,
<a name='L551'>                <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> + strlen(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>) - p + 1);
<a name='L552'>            <a href='../D/9803.html' title='Multiple defined in 4 places.'>memcpy</a>(p, chars_to_insert, insert_count);
<a name='L553'>        <font color='red'>}</font>
<a name='L554'>    <font color='red'>}</font>
<a name='L555'>    <b>if</b> (convert_to_exp) <font color='red'>{</font>
<a name='L556'>        <b>int</b> written;
<a name='L557'>        <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> buf_avail;
<a name='L558'>        p = digits_start;
<a name='L559'>        <i><font color='green'>/* insert decimal point */</font></i>
<a name='L560'>        <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(digit_count &gt;= 1);
<a name='L561'>        <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(p+2, p+1, digit_count); <i><font color='green'>/* safe, but overwrites nul */</font></i>
<a name='L562'>        p[1] = '.';
<a name='L563'>        p += digit_count+1;
<a name='L564'>        <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(p &lt;= buf_size+<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>);
<a name='L565'>        buf_avail = buf_size+<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>-p;
<a name='L566'>        <b>if</b> (buf_avail == 0)
<a name='L567'>            <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L568'>        <i><font color='green'>/* Add exponent.  It's okay to use lower case 'e': we only</font></i>
<a name='L569'><i><font color='green'>           arrive here as a result of using the empty format code or</font></i>
<a name='L570'><i><font color='green'>           repr/str builtins and those never want an upper case 'E' */</font></i>
<a name='L571'>        written = <a href='../S/3126.html#L41' title='Defined at 41 in Python/mysnprintf.c.'>PyOS_snprintf</a>(p, buf_avail, "e%+.02d", digit_count-1);
<a name='L572'>        <b>if</b> (!(0 &lt;= written &amp;&amp;
<a name='L573'>              written &lt; <a href='../D/4230.html' title='Multiple defined in 2 places.'>Py_SAFE_DOWNCAST</a>(buf_avail, <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a>, <b>int</b>)))
<a name='L574'>            <i><font color='green'>/* output truncated, or something else bad happened */</font></i>
<a name='L575'>            <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L576'>        remove_trailing_zeros(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>);
<a name='L577'>    <font color='red'>}</font>
<a name='L578'>    <b>return</b> <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>;
<a name='L579'><font color='red'>}</font>
<a name='L580'>
<a name='L581'><i><font color='green'>/* see FORMATBUFLEN in unicodeobject.c */</font></i>
<a name='L582'><font color='darkred'>#define</font> <a href='../S/3136.html#L616' title='Refered from 616 in Python/pystrtod.c.'>FLOAT_FORMATBUFLEN</a> 120
<a name='L583'>
<a name='L584'><i><font color='green'>/**</font></i>
<a name='L585'><i><font color='green'> * _PyOS_ascii_formatd:</font></i>
<a name='L586'><i><font color='green'> * @buffer: A buffer to place the resulting string in</font></i>
<a name='L587'><i><font color='green'> * @buf_size: The length of the buffer.</font></i>
<a name='L588'><i><font color='green'> * @format: The printf()-style format to use for the</font></i>
<a name='L589'><i><font color='green'> *          code to use for converting.</font></i>
<a name='L590'><i><font color='green'> * @d: The #gdouble to convert</font></i>
<a name='L591'><i><font color='green'> * @precision: The precision to use when formatting.</font></i>
<a name='L592'><i><font color='green'> *</font></i>
<a name='L593'><i><font color='green'> * Converts a #gdouble to a string, using the '.' as</font></i>
<a name='L594'><i><font color='green'> * decimal point. To format the number you pass in</font></i>
<a name='L595'><i><font color='green'> * a printf()-style format string. Allowed conversion</font></i>
<a name='L596'><i><font color='green'> * specifiers are 'e', 'E', 'f', 'F', 'g', 'G', and 'Z'.</font></i>
<a name='L597'><i><font color='green'> *</font></i>
<a name='L598'><i><font color='green'> * 'Z' is the same as 'g', except it always has a decimal and</font></i>
<a name='L599'><i><font color='green'> *     at least one digit after the decimal.</font></i>
<a name='L600'><i><font color='green'> *</font></i>
<a name='L601'><i><font color='green'> * Return value: The pointer to the buffer with the converted string.</font></i>
<a name='L602'><i><font color='green'> * On failure returns NULL but does not set any Python exception.</font></i>
<a name='L603'><i><font color='green'> **/</font></i>
<a name='L604'><b>static</b> <b>char</b> *
<a name='L605'><a href='../S/3136.html#L809' title='Refered from 809 in Python/pystrtod.c.'>_PyOS_ascii_formatd</a>(<b>char</b>       *buffer,
<a name='L606'>                   <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a>      buf_size,
<a name='L607'>                   <b>const</b> <b>char</b> *format,
<a name='L608'>                   <b>double</b>      d,
<a name='L609'>                   <b>int</b>         precision)
<a name='L610'><font color='red'>{</font>
<a name='L611'>    <b>char</b> format_char;
<a name='L612'>    <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> format_len = strlen(format);
<a name='L613'>
<a name='L614'>    <i><font color='green'>/* Issue 2264: code 'Z' requires copying the format.  'Z' is 'g', but</font></i>
<a name='L615'><i><font color='green'>       also with at least one character past the decimal. */</font></i>
<a name='L616'>    <b>char</b> tmp_format[<a href='../S/3136.html#L582' title='Defined at 582 in Python/pystrtod.c.'>FLOAT_FORMATBUFLEN</a>];
<a name='L617'>
<a name='L618'>    <i><font color='green'>/* The last character in the format string must be the format char */</font></i>
<a name='L619'>    format_char = format[format_len - 1];
<a name='L620'>
<a name='L621'>    <b>if</b> (format[0] != '%')
<a name='L622'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L623'>
<a name='L624'>    <i><font color='green'>/* I'm not sure why this test is here.  It's ensuring that the format</font></i>
<a name='L625'><i><font color='green'>       string after the first character doesn't have a single quote, a</font></i>
<a name='L626'><i><font color='green'>       lowercase l, or a percent. This is the reverse of the commented-out</font></i>
<a name='L627'><i><font color='green'>       test about 10 lines ago. */</font></i>
<a name='L628'>    <b>if</b> (strpbrk(format + 1, "'l%"))
<a name='L629'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L630'>
<a name='L631'>    <i><font color='green'>/* Also curious about this function is that it accepts format strings</font></i>
<a name='L632'><i><font color='green'>       like "%xg", which are invalid for floats.  In general, the</font></i>
<a name='L633'><i><font color='green'>       interface to this function is not very good, but changing it is</font></i>
<a name='L634'><i><font color='green'>       difficult because it's a public API. */</font></i>
<a name='L635'>
<a name='L636'>    <b>if</b> (!(format_char == 'e' || format_char == 'E' ||
<a name='L637'>          format_char == 'f' || format_char == 'F' ||
<a name='L638'>          format_char == 'g' || format_char == 'G' ||
<a name='L639'>          format_char == 'Z'))
<a name='L640'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L641'>
<a name='L642'>    <i><font color='green'>/* Map 'Z' format_char to 'g', by copying the format string and</font></i>
<a name='L643'><i><font color='green'>       replacing the final char with a 'g' */</font></i>
<a name='L644'>    <b>if</b> (format_char == 'Z') <font color='red'>{</font>
<a name='L645'>        <b>if</b> (format_len + 1 &gt;= <b>sizeof</b>(tmp_format)) <font color='red'>{</font>
<a name='L646'>            <i><font color='green'>/* The format won't fit in our copy.  Error out.  In</font></i>
<a name='L647'><i><font color='green'>               practice, this will never happen and will be</font></i>
<a name='L648'><i><font color='green'>               detected by returning NULL */</font></i>
<a name='L649'>            <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L650'>        <font color='red'>}</font>
<a name='L651'>        strcpy(tmp_format, format);
<a name='L652'>        tmp_format[format_len - 1] = 'g';
<a name='L653'>        format = tmp_format;
<a name='L654'>    <font color='red'>}</font>
<a name='L655'>
<a name='L656'>
<a name='L657'>    <i><font color='green'>/* Have PyOS_snprintf do the hard work */</font></i>
<a name='L658'>    <a href='../S/3126.html#L41' title='Defined at 41 in Python/mysnprintf.c.'>PyOS_snprintf</a>(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>, buf_size, format, d);
<a name='L659'>
<a name='L660'>    <i><font color='green'>/* Do various fixups on the return string */</font></i>
<a name='L661'>
<a name='L662'>    <i><font color='green'>/* Get the current locale, and find the decimal point string.</font></i>
<a name='L663'><i><font color='green'>       Convert that string back to a dot. */</font></i>
<a name='L664'>    change_decimal_from_locale_to_dot(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>);
<a name='L665'>
<a name='L666'>    <i><font color='green'>/* If an exponent exists, ensure that the exponent is at least</font></i>
<a name='L667'><i><font color='green'>       MIN_EXPONENT_DIGITS digits, providing the buffer is large enough</font></i>
<a name='L668'><i><font color='green'>       for the extra zeros.  Also, if there are more than</font></i>
<a name='L669'><i><font color='green'>       MIN_EXPONENT_DIGITS, remove as many zeros as possible until we get</font></i>
<a name='L670'><i><font color='green'>       back to MIN_EXPONENT_DIGITS */</font></i>
<a name='L671'>    ensure_minimum_exponent_length(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>, buf_size);
<a name='L672'>
<a name='L673'>    <i><font color='green'>/* If format_char is 'Z', make sure we have at least one character</font></i>
<a name='L674'><i><font color='green'>       after the decimal point (and make sure we have a decimal point);</font></i>
<a name='L675'><i><font color='green'>       also switch to exponential notation in some edge cases where the</font></i>
<a name='L676'><i><font color='green'>       extra character would produce more significant digits that we</font></i>
<a name='L677'><i><font color='green'>       really want. */</font></i>
<a name='L678'>    <b>if</b> (format_char == 'Z')
<a name='L679'>        <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a> = ensure_decimal_point(<a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>, buf_size, precision);
<a name='L680'>
<a name='L681'>    <b>return</b> <a href='../S/2664.html#L607' title='Defined at 607 in Modules/expat/xmlparse.c.'>buffer</a>;
<a name='L682'><font color='red'>}</font>
<a name='L683'>
<a name='L684'><i><font color='green'>/* The fallback code to use if _Py_dg_dtoa is not available. */</font></i>
<a name='L685'>
<a name='L686'><a href='../R/2475.html' title='Multiple refered from 87 places.'>PyAPI_FUNC</a>(<b>char</b> *) PyOS_double_to_string(<b>double</b> val,
<a name='L687'>                                         <b>char</b> format_code,
<a name='L688'>                                         <b>int</b> precision,
<a name='L689'>                                         <b>int</b> flags,
<a name='L690'>                                         <b>int</b> *type)
<a name='L691'><font color='red'>{</font>
<a name='L692'>    <b>char</b> format[32];
<a name='L693'>    <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> bufsize;
<a name='L694'>    <b>char</b> *buf;
<a name='L695'>    <b>int</b> t, exp;
<a name='L696'>    <b>int</b> upper = 0;
<a name='L697'>
<a name='L698'>    <i><font color='green'>/* Validate format_code, and map upper and lower case */</font></i>
<a name='L699'>    <b>switch</b> (format_code) <font color='red'>{</font>
<a name='L700'>    <b>case</b> 'e':          <i><font color='green'>/* exponent */</font></i>
<a name='L701'>    <b>case</b> 'f':          <i><font color='green'>/* fixed */</font></i>
<a name='L702'>    <b>case</b> 'g':          <i><font color='green'>/* general */</font></i>
<a name='L703'>        <b>break</b>;
<a name='L704'>    <b>case</b> 'E':
<a name='L705'>        upper = 1;
<a name='L706'>        format_code = 'e';
<a name='L707'>        <b>break</b>;
<a name='L708'>    <b>case</b> 'F':
<a name='L709'>        upper = 1;
<a name='L710'>        format_code = 'f';
<a name='L711'>        <b>break</b>;
<a name='L712'>    <b>case</b> 'G':
<a name='L713'>        upper = 1;
<a name='L714'>        format_code = 'g';
<a name='L715'>        <b>break</b>;
<a name='L716'>    <b>case</b> 'r':          <i><font color='green'>/* repr format */</font></i>
<a name='L717'>        <i><font color='green'>/* Supplied precision is unused, must be 0. */</font></i>
<a name='L718'>        <b>if</b> (precision != 0) <font color='red'>{</font>
<a name='L719'>            <a href='../D/3142.html' title='Multiple defined in 3 places.'>PyErr_BadInternalCall</a>();
<a name='L720'>            <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L721'>        <font color='red'>}</font>
<a name='L722'>        <i><font color='green'>/* The repr() precision (17 significant decimal digits) is the</font></i>
<a name='L723'><i><font color='green'>           minimal number that is guaranteed to have enough precision</font></i>
<a name='L724'><i><font color='green'>           so that if the number is read back in the exact same binary</font></i>
<a name='L725'><i><font color='green'>           value is recreated.  This is true for IEEE floating point</font></i>
<a name='L726'><i><font color='green'>           by design, and also happens to work for all other modern</font></i>
<a name='L727'><i><font color='green'>           hardware. */</font></i>
<a name='L728'>        precision = 17;
<a name='L729'>        format_code = 'g';
<a name='L730'>        <b>break</b>;
<a name='L731'>    <b>default</b>:
<a name='L732'>        <a href='../D/3142.html' title='Multiple defined in 3 places.'>PyErr_BadInternalCall</a>();
<a name='L733'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L734'>    <font color='red'>}</font>
<a name='L735'>
<a name='L736'>    <i><font color='green'>/* Here's a quick-and-dirty calculation to figure out how big a buffer</font></i>
<a name='L737'><i><font color='green'>       we need.  In general, for a finite float we need:</font></i>
<a name='L738'><i><font color='green'></font></i>
<a name='L739'><i><font color='green'>         1 byte for each digit of the decimal significand, and</font></i>
<a name='L740'><i><font color='green'></font></i>
<a name='L741'><i><font color='green'>         1 for a possible sign</font></i>
<a name='L742'><i><font color='green'>         1 for a possible decimal point</font></i>
<a name='L743'><i><font color='green'>         2 for a possible [eE][+-]</font></i>
<a name='L744'><i><font color='green'>         1 for each digit of the exponent;  if we allow 19 digits</font></i>
<a name='L745'><i><font color='green'>           total then we're safe up to exponents of 2**63.</font></i>
<a name='L746'><i><font color='green'>         1 for the trailing nul byte</font></i>
<a name='L747'><i><font color='green'></font></i>
<a name='L748'><i><font color='green'>       This gives a total of 24 + the number of digits in the significand,</font></i>
<a name='L749'><i><font color='green'>       and the number of digits in the significand is:</font></i>
<a name='L750'><i><font color='green'></font></i>
<a name='L751'><i><font color='green'>         for 'g' format: at most precision, except possibly</font></i>
<a name='L752'><i><font color='green'>           when precision == 0, when it's 1.</font></i>
<a name='L753'><i><font color='green'>         for 'e' format: precision+1</font></i>
<a name='L754'><i><font color='green'>         for 'f' format: precision digits after the point, at least 1</font></i>
<a name='L755'><i><font color='green'>           before.  To figure out how many digits appear before the point</font></i>
<a name='L756'><i><font color='green'>           we have to examine the size of the number.  If fabs(val) &lt; 1.0</font></i>
<a name='L757'><i><font color='green'>           then there will be only one digit before the point.  If</font></i>
<a name='L758'><i><font color='green'>           fabs(val) &gt;= 1.0, then there are at most</font></i>
<a name='L759'><i><font color='green'></font></i>
<a name='L760'><i><font color='green'>         1+floor(log10(ceiling(fabs(val))))</font></i>
<a name='L761'><i><font color='green'></font></i>
<a name='L762'><i><font color='green'>           digits before the point (where the 'ceiling' allows for the</font></i>
<a name='L763'><i><font color='green'>           possibility that the rounding rounds the integer part of val</font></i>
<a name='L764'><i><font color='green'>           up).  A safe upper bound for the above quantity is</font></i>
<a name='L765'><i><font color='green'>           1+floor(exp/3), where exp is the unique integer such that 0.5</font></i>
<a name='L766'><i><font color='green'>           &lt;= fabs(val)/2**exp &lt; 1.0.  This exp can be obtained from</font></i>
<a name='L767'><i><font color='green'>           frexp.</font></i>
<a name='L768'><i><font color='green'></font></i>
<a name='L769'><i><font color='green'>       So we allow room for precision+1 digits for all formats, plus an</font></i>
<a name='L770'><i><font color='green'>       extra floor(exp/3) digits for 'f' format.</font></i>
<a name='L771'><i><font color='green'></font></i>
<a name='L772'><i><font color='green'>    */</font></i>
<a name='L773'>
<a name='L774'>    <b>if</b> (<a href='../S/2906.html#L212' title='Defined at 212 in PC/pyconfig.h.'>Py_IS_NAN</a>(val) || <a href='../D/4165.html' title='Multiple defined in 3 places.'>Py_IS_INFINITY</a>(val))
<a name='L775'>        <i><font color='green'>/* 3 for 'inf'/'nan', 1 for sign, 1 for '\0' */</font></i>
<a name='L776'>        bufsize = 5;
<a name='L777'>    <b>else</b> <font color='red'>{</font>
<a name='L778'>        bufsize = 25 + precision;
<a name='L779'>        <b>if</b> (format_code == 'f' &amp;&amp; fabs(val) &gt;= 1.0) <font color='red'>{</font>
<a name='L780'>            frexp(val, &amp;exp);
<a name='L781'>            bufsize += exp/3;
<a name='L782'>        <font color='red'>}</font>
<a name='L783'>    <font color='red'>}</font>
<a name='L784'>
<a name='L785'>    buf = <a href='../S/2803.html#L1769' title='Defined at 1769 in Objects/object.c.'>PyMem_Malloc</a>(bufsize);
<a name='L786'>    <b>if</b> (buf == <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) <font color='red'>{</font>
<a name='L787'>        <a href='../S/3106.html#L334' title='Defined at 334 in Python/errors.c.'>PyErr_NoMemory</a>();
<a name='L788'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L789'>    <font color='red'>}</font>
<a name='L790'>
<a name='L791'>    <i><font color='green'>/* Handle nan and inf. */</font></i>
<a name='L792'>    <b>if</b> (<a href='../S/2906.html#L212' title='Defined at 212 in PC/pyconfig.h.'>Py_IS_NAN</a>(val)) <font color='red'>{</font>
<a name='L793'>        strcpy(buf, "nan");
<a name='L794'>        t = Py_DTST_NAN;
<a name='L795'>    <font color='red'>}</font> <b>else</b> <b>if</b> (<a href='../D/4165.html' title='Multiple defined in 3 places.'>Py_IS_INFINITY</a>(val)) <font color='red'>{</font>
<a name='L796'>        <b>if</b> (<a href='../D/7796.html' title='Multiple defined in 2 places.'>copysign</a>(1., val) == 1.)
<a name='L797'>            strcpy(buf, "inf");
<a name='L798'>        <b>else</b>
<a name='L799'>            strcpy(buf, "-inf");
<a name='L800'>        t = Py_DTST_INFINITE;
<a name='L801'>    <font color='red'>}</font> <b>else</b> <font color='red'>{</font>
<a name='L802'>        t = Py_DTST_FINITE;
<a name='L803'>        <b>if</b> (<a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_ADD_DOT_0)
<a name='L804'>            format_code = 'Z';
<a name='L805'>
<a name='L806'>        <a href='../S/3126.html#L41' title='Defined at 41 in Python/mysnprintf.c.'>PyOS_snprintf</a>(format, <b>sizeof</b>(format), "%%%s.%i%c",
<a name='L807'>                      (<a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_ALT ? "#" : ""), precision,
<a name='L808'>                      format_code);
<a name='L809'>        <a href='../S/3136.html#L605' title='Defined at 605 in Python/pystrtod.c.'>_PyOS_ascii_formatd</a>(buf, bufsize, format, val, precision);
<a name='L810'>    <font color='red'>}</font>
<a name='L811'>
<a name='L812'>    <i><font color='green'>/* Add sign when requested.  It's convenient (esp. when formatting</font></i>
<a name='L813'><i><font color='green'>     complex numbers) to include a sign even for inf and nan. */</font></i>
<a name='L814'>    <b>if</b> (<a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_SIGN &amp;&amp; buf[0] != '-') <font color='red'>{</font>
<a name='L815'>        <a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a> len = strlen(buf);
<a name='L816'>        <i><font color='green'>/* the bufsize calculations above should ensure that we've got</font></i>
<a name='L817'><i><font color='green'>           space to add a sign */</font></i>
<a name='L818'>        <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>((<a href='../D/11182.html' title='Multiple defined in 2 places.'>size_t</a>)bufsize &gt;= len+2);
<a name='L819'>        <a href='../S/2664.html#L75' title='Defined at 75 in Modules/expat/xmlparse.c.'>memmove</a>(buf+1, buf, len+1);
<a name='L820'>        buf[0] = '+';
<a name='L821'>    <font color='red'>}</font>
<a name='L822'>    <b>if</b> (upper) <font color='red'>{</font>
<a name='L823'>        <i><font color='green'>/* Convert to upper case. */</font></i>
<a name='L824'>        <b>char</b> *p1;
<a name='L825'>        <b>for</b> (p1 = buf; *p1; p1++)
<a name='L826'>            *p1 = <a href='../S/556.html#L30' title='Defined at 30 in Include/pyctype.h.'>Py_TOUPPER</a>(*p1);
<a name='L827'>    <font color='red'>}</font>
<a name='L828'>
<a name='L829'>    <b>if</b> (type)
<a name='L830'>        *type = t;
<a name='L831'>    <b>return</b> buf;
<a name='L832'><font color='red'>}</font>
<a name='L833'>
<a name='L834'><font color='darkred'>#else</font>
<a name='L835'>
<a name='L836'><i><font color='green'>/* _Py_dg_dtoa is available. */</font></i>
<a name='L837'>
<a name='L838'><i><font color='green'>/* I'm using a lookup table here so that I don't have to invent a non-locale</font></i>
<a name='L839'><i><font color='green'>   specific way to convert to uppercase */</font></i>
<a name='L840'><font color='darkred'>#define</font> <a href='../S/3136.html#L940' title='Refered from 940 in Python/pystrtod.c.'>OFS_INF</a> 0
<a name='L841'><font color='darkred'>#define</font> <a href='../S/3136.html#L947' title='Refered from 947 in Python/pystrtod.c.'>OFS_NAN</a> 1
<a name='L842'><font color='darkred'>#define</font> <a href='../S/3136.html#L1116' title='Refered from 1116 in Python/pystrtod.c.'>OFS_E</a> 2
<a name='L843'>
<a name='L844'><i><font color='green'>/* The lengths of these are known to the code below, so don't change them */</font></i>
<a name='L845'><b>static</b> <b>char</b> *lc_float_strings[] = <font color='red'>{</font>
<a name='L846'>    "inf",
<a name='L847'>    "nan",
<a name='L848'>    "e",
<a name='L849'><font color='red'>}</font>;
<a name='L850'><b>static</b> <b>char</b> *uc_float_strings[] = <font color='red'>{</font>
<a name='L851'>    "INF",
<a name='L852'>    "NAN",
<a name='L853'>    "E",
<a name='L854'><font color='red'>}</font>;
<a name='L855'>
<a name='L856'>
<a name='L857'><i><font color='green'>/* Convert a double d to a string, and return a PyMem_Malloc'd block of</font></i>
<a name='L858'><i><font color='green'>   memory contain the resulting string.</font></i>
<a name='L859'><i><font color='green'></font></i>
<a name='L860'><i><font color='green'>   Arguments:</font></i>
<a name='L861'><i><font color='green'>     d is the double to be converted</font></i>
<a name='L862'><i><font color='green'>     format_code is one of 'e', 'f', 'g', 'r'.  'e', 'f' and 'g'</font></i>
<a name='L863'><i><font color='green'>       correspond to '%e', '%f' and '%g';  'r' corresponds to repr.</font></i>
<a name='L864'><i><font color='green'>     mode is one of '0', '2' or '3', and is completely determined by</font></i>
<a name='L865'><i><font color='green'>       format_code: 'e' and 'g' use mode 2; 'f' mode 3, 'r' mode 0.</font></i>
<a name='L866'><i><font color='green'>     precision is the desired precision</font></i>
<a name='L867'><i><font color='green'>     always_add_sign is nonzero if a '+' sign should be included for positive</font></i>
<a name='L868'><i><font color='green'>       numbers</font></i>
<a name='L869'><i><font color='green'>     add_dot_0_if_integer is nonzero if integers in non-exponential form</font></i>
<a name='L870'><i><font color='green'>       should have ".0" added.  Only applies to format codes 'r' and 'g'.</font></i>
<a name='L871'><i><font color='green'>     use_alt_formatting is nonzero if alternative formatting should be</font></i>
<a name='L872'><i><font color='green'>       used.  Only applies to format codes 'e', 'f' and 'g'.  For code 'g',</font></i>
<a name='L873'><i><font color='green'>       at most one of use_alt_formatting and add_dot_0_if_integer should</font></i>
<a name='L874'><i><font color='green'>       be nonzero.</font></i>
<a name='L875'><i><font color='green'>     type, if non-NULL, will be set to one of these constants to identify</font></i>
<a name='L876'><i><font color='green'>       the type of the 'd' argument:</font></i>
<a name='L877'><i><font color='green'>     Py_DTST_FINITE</font></i>
<a name='L878'><i><font color='green'>     Py_DTST_INFINITE</font></i>
<a name='L879'><i><font color='green'>     Py_DTST_NAN</font></i>
<a name='L880'><i><font color='green'></font></i>
<a name='L881'><i><font color='green'>   Returns a PyMem_Malloc'd block of memory containing the resulting string,</font></i>
<a name='L882'><i><font color='green'>    or NULL on error. If NULL is returned, the Python error has been set.</font></i>
<a name='L883'><i><font color='green'> */</font></i>
<a name='L884'>
<a name='L885'><b>static</b> <b>char</b> *
<a name='L886'><a href='../S/3136.html#L1192' title='Refered from 1192 in Python/pystrtod.c.'>format_float_short</a>(<b>double</b> d, <b>char</b> format_code,
<a name='L887'>                   <b>int</b> mode, <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> precision,
<a name='L888'>                   <b>int</b> always_add_sign, <b>int</b> add_dot_0_if_integer,
<a name='L889'>                   <b>int</b> use_alt_formatting, <b>char</b> **float_strings, <b>int</b> *type)
<a name='L890'><font color='red'>{</font>
<a name='L891'>    <b>char</b> *buf = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L892'>    <b>char</b> *p = <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L893'>    <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> bufsize = 0;
<a name='L894'>    <b>char</b> *digits, *digits_end;
<a name='L895'>    <b>int</b> decpt_as_int, sign, exp_len, exp = 0, use_exp = 0;
<a name='L896'>    <a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a> decpt, digits_len, vdigits_start, vdigits_end;
<a name='L897'>    <a href='../D/6314.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_HEADER</a>;
<a name='L898'>
<a name='L899'>    <i><font color='green'>/* _Py_dg_dtoa returns a digit string (no decimal point or exponent).</font></i>
<a name='L900'><i><font color='green'>       Must be matched by a call to _Py_dg_freedtoa. */</font></i>
<a name='L901'>    <a href='../D/6315.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_START</a>;
<a name='L902'>    digits = <a href='../S/3095.html#L2314' title='Defined at 2314 in Python/dtoa.c.'>_Py_dg_dtoa</a>(d, mode, precision, &amp;decpt_as_int, &amp;sign,
<a name='L903'>                         &amp;digits_end);
<a name='L904'>    <a href='../D/6313.html' title='Multiple defined in 2 places.'>_Py_SET_53BIT_PRECISION_END</a>;
<a name='L905'>
<a name='L906'>    decpt = (<a href='../D/4364.html' title='Multiple defined in 6 places.'>Py_ssize_t</a>)decpt_as_int;
<a name='L907'>    <b>if</b> (digits == <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) <font color='red'>{</font>
<a name='L908'>        <i><font color='green'>/* The only failure mode is no memory. */</font></i>
<a name='L909'>        <a href='../S/3106.html#L334' title='Defined at 334 in Python/errors.c.'>PyErr_NoMemory</a>();
<a name='L910'>        <b>goto</b> exit;
<a name='L911'>    <font color='red'>}</font>
<a name='L912'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(digits_end != <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a> &amp;&amp; digits_end &gt;= digits);
<a name='L913'>    digits_len = digits_end - digits;
<a name='L914'>
<a name='L915'>    <b>if</b> (digits_len &amp;&amp; !<a href='../S/556.html#L21' title='Defined at 21 in Include/pyctype.h.'>Py_ISDIGIT</a>(digits[0])) <font color='red'>{</font>
<a name='L916'>        <i><font color='green'>/* Infinities and nans here; adapt Gay's output,</font></i>
<a name='L917'><i><font color='green'>           so convert Infinity to inf and NaN to nan, and</font></i>
<a name='L918'><i><font color='green'>           ignore sign of nan. Then return. */</font></i>
<a name='L919'>
<a name='L920'>        <i><font color='green'>/* ignore the actual sign of a nan */</font></i>
<a name='L921'>        <b>if</b> (digits[0] == 'n' || digits[0] == 'N')
<a name='L922'>            sign = 0;
<a name='L923'>
<a name='L924'>        <i><font color='green'>/* We only need 5 bytes to hold the result "+inf\0" . */</font></i>
<a name='L925'>        bufsize = 5; <i><font color='green'>/* Used later in an assert. */</font></i>
<a name='L926'>        buf = (<b>char</b> *)<a href='../S/2803.html#L1769' title='Defined at 1769 in Objects/object.c.'>PyMem_Malloc</a>(bufsize);
<a name='L927'>        <b>if</b> (buf == <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) <font color='red'>{</font>
<a name='L928'>            <a href='../S/3106.html#L334' title='Defined at 334 in Python/errors.c.'>PyErr_NoMemory</a>();
<a name='L929'>            <b>goto</b> exit;
<a name='L930'>        <font color='red'>}</font>
<a name='L931'>        p = buf;
<a name='L932'>
<a name='L933'>        <b>if</b> (sign == 1) <font color='red'>{</font>
<a name='L934'>            *p++ = '-';
<a name='L935'>        <font color='red'>}</font>
<a name='L936'>        <b>else</b> <b>if</b> (always_add_sign) <font color='red'>{</font>
<a name='L937'>            *p++ = '+';
<a name='L938'>        <font color='red'>}</font>
<a name='L939'>        <b>if</b> (digits[0] == 'i' || digits[0] == 'I') <font color='red'>{</font>
<a name='L940'>            strncpy(p, float_strings[<a href='../S/3136.html#L840' title='Defined at 840 in Python/pystrtod.c.'>OFS_INF</a>], 3);
<a name='L941'>            p += 3;
<a name='L942'>
<a name='L943'>            <b>if</b> (type)
<a name='L944'>                *type = Py_DTST_INFINITE;
<a name='L945'>        <font color='red'>}</font>
<a name='L946'>        <b>else</b> <b>if</b> (digits[0] == 'n' || digits[0] == 'N') <font color='red'>{</font>
<a name='L947'>            strncpy(p, float_strings[<a href='../S/3136.html#L841' title='Defined at 841 in Python/pystrtod.c.'>OFS_NAN</a>], 3);
<a name='L948'>            p += 3;
<a name='L949'>
<a name='L950'>            <b>if</b> (type)
<a name='L951'>                *type = Py_DTST_NAN;
<a name='L952'>        <font color='red'>}</font>
<a name='L953'>        <b>else</b> <font color='red'>{</font>
<a name='L954'>            <i><font color='green'>/* shouldn't get here: Gay's code should always return</font></i>
<a name='L955'><i><font color='green'>               something starting with a digit, an 'I',  or 'N' */</font></i>
<a name='L956'>            strncpy(p, "ERR", 3);
<a name='L957'>            p += 3;
<a name='L958'>            <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(0);
<a name='L959'>        <font color='red'>}</font>
<a name='L960'>        <b>goto</b> exit;
<a name='L961'>    <font color='red'>}</font>
<a name='L962'>
<a name='L963'>    <i><font color='green'>/* The result must be finite (not inf or nan). */</font></i>
<a name='L964'>    <b>if</b> (type)
<a name='L965'>        *type = Py_DTST_FINITE;
<a name='L966'>
<a name='L967'>
<a name='L968'>    <i><font color='green'>/* We got digits back, format them.  We may need to pad 'digits'</font></i>
<a name='L969'><i><font color='green'>       either on the left or right (or both) with extra zeros, so in</font></i>
<a name='L970'><i><font color='green'>       general the resulting string has the form</font></i>
<a name='L971'><i><font color='green'></font></i>
<a name='L972'><i><font color='green'>         [&lt;sign&gt;]&lt;zeros&gt;&lt;digits&gt;&lt;zeros&gt;[&lt;exponent&gt;]</font></i>
<a name='L973'><i><font color='green'></font></i>
<a name='L974'><i><font color='green'>       where either of the &lt;zeros&gt; pieces could be empty, and there's a</font></i>
<a name='L975'><i><font color='green'>       decimal point that could appear either in &lt;digits&gt; or in the</font></i>
<a name='L976'><i><font color='green'>       leading or trailing &lt;zeros&gt;.</font></i>
<a name='L977'><i><font color='green'></font></i>
<a name='L978'><i><font color='green'>       Imagine an infinite 'virtual' string vdigits, consisting of the</font></i>
<a name='L979'><i><font color='green'>       string 'digits' (starting at index 0) padded on both the left and</font></i>
<a name='L980'><i><font color='green'>       right with infinite strings of zeros.  We want to output a slice</font></i>
<a name='L981'><i><font color='green'></font></i>
<a name='L982'><i><font color='green'>         vdigits[vdigits_start : vdigits_end]</font></i>
<a name='L983'><i><font color='green'></font></i>
<a name='L984'><i><font color='green'>       of this virtual string.  Thus if vdigits_start &lt; 0 then we'll end</font></i>
<a name='L985'><i><font color='green'>       up producing some leading zeros; if vdigits_end &gt; digits_len there</font></i>
<a name='L986'><i><font color='green'>       will be trailing zeros in the output.  The next section of code</font></i>
<a name='L987'><i><font color='green'>       determines whether to use an exponent or not, figures out the</font></i>
<a name='L988'><i><font color='green'>       position 'decpt' of the decimal point, and computes 'vdigits_start'</font></i>
<a name='L989'><i><font color='green'>       and 'vdigits_end'. */</font></i>
<a name='L990'>    vdigits_end = digits_len;
<a name='L991'>    <b>switch</b> (format_code) <font color='red'>{</font>
<a name='L992'>    <b>case</b> 'e':
<a name='L993'>        use_exp = 1;
<a name='L994'>        vdigits_end = precision;
<a name='L995'>        <b>break</b>;
<a name='L996'>    <b>case</b> 'f':
<a name='L997'>        vdigits_end = decpt + precision;
<a name='L998'>        <b>break</b>;
<a name='L999'>    <b>case</b> 'g':
<a name='L1000'>        <b>if</b> (decpt &lt;= -4 || decpt &gt;
<a name='L1001'>            (add_dot_0_if_integer ? precision-1 : precision))
<a name='L1002'>            use_exp = 1;
<a name='L1003'>        <b>if</b> (use_alt_formatting)
<a name='L1004'>            vdigits_end = precision;
<a name='L1005'>        <b>break</b>;
<a name='L1006'>    <b>case</b> 'r':
<a name='L1007'>        <i><font color='green'>/* convert to exponential format at 1e16.  We used to convert</font></i>
<a name='L1008'><i><font color='green'>           at 1e17, but that gives odd-looking results for some values</font></i>
<a name='L1009'><i><font color='green'>           when a 16-digit 'shortest' repr is padded with bogus zeros.</font></i>
<a name='L1010'><i><font color='green'>           For example, repr(2e16+8) would give 20000000000000010.0;</font></i>
<a name='L1011'><i><font color='green'>           the true value is 20000000000000008.0. */</font></i>
<a name='L1012'>        <b>if</b> (decpt &lt;= -4 || decpt &gt; 16)
<a name='L1013'>            use_exp = 1;
<a name='L1014'>        <b>break</b>;
<a name='L1015'>    <b>default</b>:
<a name='L1016'>        <a href='../D/3142.html' title='Multiple defined in 3 places.'>PyErr_BadInternalCall</a>();
<a name='L1017'>        <b>goto</b> exit;
<a name='L1018'>    <font color='red'>}</font>
<a name='L1019'>
<a name='L1020'>    <i><font color='green'>/* if using an exponent, reset decimal point position to 1 and adjust</font></i>
<a name='L1021'><i><font color='green'>       exponent accordingly.*/</font></i>
<a name='L1022'>    <b>if</b> (use_exp) <font color='red'>{</font>
<a name='L1023'>        exp = decpt - 1;
<a name='L1024'>        decpt = 1;
<a name='L1025'>    <font color='red'>}</font>
<a name='L1026'>    <i><font color='green'>/* ensure vdigits_start &lt; decpt &lt;= vdigits_end, or vdigits_start &lt;</font></i>
<a name='L1027'><i><font color='green'>       decpt &lt; vdigits_end if add_dot_0_if_integer and no exponent */</font></i>
<a name='L1028'>    vdigits_start = decpt &lt;= 0 ? decpt-1 : 0;
<a name='L1029'>    <b>if</b> (!use_exp &amp;&amp; add_dot_0_if_integer)
<a name='L1030'>        vdigits_end = vdigits_end &gt; decpt ? vdigits_end : decpt + 1;
<a name='L1031'>    <b>else</b>
<a name='L1032'>        vdigits_end = vdigits_end &gt; decpt ? vdigits_end : decpt;
<a name='L1033'>
<a name='L1034'>    <i><font color='green'>/* double check inequalities */</font></i>
<a name='L1035'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(vdigits_start &lt;= 0 &amp;&amp;
<a name='L1036'>           0 &lt;= digits_len &amp;&amp;
<a name='L1037'>           digits_len &lt;= vdigits_end);
<a name='L1038'>    <i><font color='green'>/* decimal point should be in (vdigits_start, vdigits_end] */</font></i>
<a name='L1039'>    <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(vdigits_start &lt; decpt &amp;&amp; decpt &lt;= vdigits_end);
<a name='L1040'>
<a name='L1041'>    <i><font color='green'>/* Compute an upper bound how much memory we need. This might be a few</font></i>
<a name='L1042'><i><font color='green'>       chars too long, but no big deal. */</font></i>
<a name='L1043'>    bufsize =
<a name='L1044'>        <i><font color='green'>/* sign, decimal point and trailing 0 byte */</font></i>
<a name='L1045'>        3 +
<a name='L1046'>
<a name='L1047'>        <i><font color='green'>/* total digit count (including zero padding on both sides) */</font></i>
<a name='L1048'>        (vdigits_end - vdigits_start) +
<a name='L1049'>
<a name='L1050'>        <i><font color='green'>/* exponent "e+100", max 3 numerical digits */</font></i>
<a name='L1051'>        (use_exp ? 5 : 0);
<a name='L1052'>
<a name='L1053'>    <i><font color='green'>/* Now allocate the memory and initialize p to point to the start of</font></i>
<a name='L1054'><i><font color='green'>       it. */</font></i>
<a name='L1055'>    buf = (<b>char</b> *)<a href='../S/2803.html#L1769' title='Defined at 1769 in Objects/object.c.'>PyMem_Malloc</a>(bufsize);
<a name='L1056'>    <b>if</b> (buf == <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>) <font color='red'>{</font>
<a name='L1057'>        <a href='../S/3106.html#L334' title='Defined at 334 in Python/errors.c.'>PyErr_NoMemory</a>();
<a name='L1058'>        <b>goto</b> exit;
<a name='L1059'>    <font color='red'>}</font>
<a name='L1060'>    p = buf;
<a name='L1061'>
<a name='L1062'>    <i><font color='green'>/* Add a negative sign if negative, and a plus sign if non-negative</font></i>
<a name='L1063'><i><font color='green'>       and always_add_sign is true. */</font></i>
<a name='L1064'>    <b>if</b> (sign == 1)
<a name='L1065'>        *p++ = '-';
<a name='L1066'>    <b>else</b> <b>if</b> (always_add_sign)
<a name='L1067'>        *p++ = '+';
<a name='L1068'>
<a name='L1069'>    <i><font color='green'>/* note that exactly one of the three 'if' conditions is true,</font></i>
<a name='L1070'><i><font color='green'>       so we include exactly one decimal point */</font></i>
<a name='L1071'>    <i><font color='green'>/* Zero padding on left of digit string */</font></i>
<a name='L1072'>    <b>if</b> (decpt &lt;= 0) <font color='red'>{</font>
<a name='L1073'>        memset(p, '0', decpt-vdigits_start);
<a name='L1074'>        p += decpt - vdigits_start;
<a name='L1075'>        *p++ = '.';
<a name='L1076'>        memset(p, '0', 0-decpt);
<a name='L1077'>        p += 0-decpt;
<a name='L1078'>    <font color='red'>}</font>
<a name='L1079'>    <b>else</b> <font color='red'>{</font>
<a name='L1080'>        memset(p, '0', 0-vdigits_start);
<a name='L1081'>        p += 0 - vdigits_start;
<a name='L1082'>    <font color='red'>}</font>
<a name='L1083'>
<a name='L1084'>    <i><font color='green'>/* Digits, with included decimal point */</font></i>
<a name='L1085'>    <b>if</b> (0 &lt; decpt &amp;&amp; decpt &lt;= digits_len) <font color='red'>{</font>
<a name='L1086'>        strncpy(p, digits, decpt-0);
<a name='L1087'>        p += decpt-0;
<a name='L1088'>        *p++ = '.';
<a name='L1089'>        strncpy(p, digits+decpt, digits_len-decpt);
<a name='L1090'>        p += digits_len-decpt;
<a name='L1091'>    <font color='red'>}</font>
<a name='L1092'>    <b>else</b> <font color='red'>{</font>
<a name='L1093'>        strncpy(p, digits, digits_len);
<a name='L1094'>        p += digits_len;
<a name='L1095'>    <font color='red'>}</font>
<a name='L1096'>
<a name='L1097'>    <i><font color='green'>/* And zeros on the right */</font></i>
<a name='L1098'>    <b>if</b> (digits_len &lt; decpt) <font color='red'>{</font>
<a name='L1099'>        memset(p, '0', decpt-digits_len);
<a name='L1100'>        p += decpt-digits_len;
<a name='L1101'>        *p++ = '.';
<a name='L1102'>        memset(p, '0', vdigits_end-decpt);
<a name='L1103'>        p += vdigits_end-decpt;
<a name='L1104'>    <font color='red'>}</font>
<a name='L1105'>    <b>else</b> <font color='red'>{</font>
<a name='L1106'>        memset(p, '0', vdigits_end-digits_len);
<a name='L1107'>        p += vdigits_end-digits_len;
<a name='L1108'>    <font color='red'>}</font>
<a name='L1109'>
<a name='L1110'>    <i><font color='green'>/* Delete a trailing decimal pt unless using alternative formatting. */</font></i>
<a name='L1111'>    <b>if</b> (p[-1] == '.' &amp;&amp; !use_alt_formatting)
<a name='L1112'>        p--;
<a name='L1113'>
<a name='L1114'>    <i><font color='green'>/* Now that we've done zero padding, add an exponent if needed. */</font></i>
<a name='L1115'>    <b>if</b> (use_exp) <font color='red'>{</font>
<a name='L1116'>        *p++ = float_strings[<a href='../S/3136.html#L842' title='Defined at 842 in Python/pystrtod.c.'>OFS_E</a>][0];
<a name='L1117'>        exp_len = sprintf(p, "%+.02d", exp);
<a name='L1118'>        p += exp_len;
<a name='L1119'>    <font color='red'>}</font>
<a name='L1120'>  exit:
<a name='L1121'>    <b>if</b> (buf) <font color='red'>{</font>
<a name='L1122'>        *p = '\0';
<a name='L1123'>        <i><font color='green'>/* It's too late if this fails, as we've already stepped on</font></i>
<a name='L1124'><i><font color='green'>           memory that isn't ours. But it's an okay debugging test. */</font></i>
<a name='L1125'>        <a href='../D/6814.html' title='Multiple defined in 2 places.'>assert</a>(p-buf &lt; bufsize);
<a name='L1126'>    <font color='red'>}</font>
<a name='L1127'>    <b>if</b> (digits)
<a name='L1128'>        <a href='../S/3095.html#L2268' title='Defined at 2268 in Python/dtoa.c.'>_Py_dg_freedtoa</a>(digits);
<a name='L1129'>
<a name='L1130'>    <b>return</b> buf;
<a name='L1131'><font color='red'>}</font>
<a name='L1132'>
<a name='L1133'>
<a name='L1134'><a href='../R/2475.html' title='Multiple refered from 87 places.'>PyAPI_FUNC</a>(<b>char</b> *) PyOS_double_to_string(<b>double</b> val,
<a name='L1135'>                                         <b>char</b> format_code,
<a name='L1136'>                                         <b>int</b> precision,
<a name='L1137'>                                         <b>int</b> flags,
<a name='L1138'>                                         <b>int</b> *type)
<a name='L1139'><font color='red'>{</font>
<a name='L1140'>    <b>char</b> **float_strings = lc_float_strings;
<a name='L1141'>    <b>int</b> mode;
<a name='L1142'>
<a name='L1143'>    <i><font color='green'>/* Validate format_code, and map upper and lower case. Compute the</font></i>
<a name='L1144'><i><font color='green'>       mode and make any adjustments as needed. */</font></i>
<a name='L1145'>    <b>switch</b> (format_code) <font color='red'>{</font>
<a name='L1146'>    <i><font color='green'>/* exponent */</font></i>
<a name='L1147'>    <b>case</b> 'E':
<a name='L1148'>        float_strings = uc_float_strings;
<a name='L1149'>        format_code = 'e';
<a name='L1150'>        <i><font color='green'>/* Fall through. */</font></i>
<a name='L1151'>    <b>case</b> 'e':
<a name='L1152'>        mode = 2;
<a name='L1153'>        precision++;
<a name='L1154'>        <b>break</b>;
<a name='L1155'>
<a name='L1156'>    <i><font color='green'>/* fixed */</font></i>
<a name='L1157'>    <b>case</b> 'F':
<a name='L1158'>        float_strings = uc_float_strings;
<a name='L1159'>        format_code = 'f';
<a name='L1160'>        <i><font color='green'>/* Fall through. */</font></i>
<a name='L1161'>    <b>case</b> 'f':
<a name='L1162'>        mode = 3;
<a name='L1163'>        <b>break</b>;
<a name='L1164'>
<a name='L1165'>    <i><font color='green'>/* general */</font></i>
<a name='L1166'>    <b>case</b> 'G':
<a name='L1167'>        float_strings = uc_float_strings;
<a name='L1168'>        format_code = 'g';
<a name='L1169'>        <i><font color='green'>/* Fall through. */</font></i>
<a name='L1170'>    <b>case</b> 'g':
<a name='L1171'>        mode = 2;
<a name='L1172'>        <i><font color='green'>/* precision 0 makes no sense for 'g' format; interpret as 1 */</font></i>
<a name='L1173'>        <b>if</b> (precision == 0)
<a name='L1174'>            precision = 1;
<a name='L1175'>        <b>break</b>;
<a name='L1176'>
<a name='L1177'>    <i><font color='green'>/* repr format */</font></i>
<a name='L1178'>    <b>case</b> 'r':
<a name='L1179'>        mode = 0;
<a name='L1180'>        <i><font color='green'>/* Supplied precision is unused, must be 0. */</font></i>
<a name='L1181'>        <b>if</b> (precision != 0) <font color='red'>{</font>
<a name='L1182'>            <a href='../D/3142.html' title='Multiple defined in 3 places.'>PyErr_BadInternalCall</a>();
<a name='L1183'>            <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L1184'>        <font color='red'>}</font>
<a name='L1185'>        <b>break</b>;
<a name='L1186'>
<a name='L1187'>    <b>default</b>:
<a name='L1188'>        <a href='../D/3142.html' title='Multiple defined in 3 places.'>PyErr_BadInternalCall</a>();
<a name='L1189'>        <b>return</b> <a href='../S/2891.html#L5' title='Defined at 5 in PC/os2emx/dllentry.c.'>NULL</a>;
<a name='L1190'>    <font color='red'>}</font>
<a name='L1191'>
<a name='L1192'>    <b>return</b> <a href='../S/3136.html#L886' title='Defined at 886 in Python/pystrtod.c.'>format_float_short</a>(val, format_code, mode, precision,
<a name='L1193'>                              <a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_SIGN,
<a name='L1194'>                              <a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_ADD_DOT_0,
<a name='L1195'>                              <a href='../D/8626.html' title='Multiple defined in 2 places.'>flags</a> &amp; Py_DTSF_ALT,
<a name='L1196'>                              float_strings, type);
<a name='L1197'><font color='red'>}</font>
<a name='L1198'><font color='darkred'>#endif</font> <i><font color='green'>/* ifdef PY_NO_SHORT_FLOAT_REPR */</font></i>
</pre>
<hr>
<a name='BOTTOM'>
<i><font color='green'>/* [&lt;][&gt;]<a href='#L10'>[^]</a><a href='#L1134'>[v]</a><a href='#TOP'>[top]</a>[bottom]<a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
</body>
</html>
