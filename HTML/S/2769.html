<html>
<head>
<title>Modules/zlib/zlib.h</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.8.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<a name='TOP'><h2><a href='../mains.html'>root</a>/<a href='../files/3353.html'>Modules</a>/<a href='../files/3390.html'>zlib</a>/zlib.h</h2>
<i><font color='green'>/* [&lt;][&gt;][^][v][top]<a href='#BOTTOM'>[bottom]</a><a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
<hr>
<h2><a href='../J/545.html' title='Multiple included from 9 places.'>INCLUDED FROM</a></h2>
<hr>
<pre>
<a name='L1'><i><font color='green'>/* zlib.h -- interface of the 'zlib' general purpose compression library</font></i>
<a name='L2'><i><font color='green'>  version 1.2.5, April 19th, 2010</font></i>
<a name='L3'><i><font color='green'></font></i>
<a name='L4'><i><font color='green'>  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler</font></i>
<a name='L5'><i><font color='green'></font></i>
<a name='L6'><i><font color='green'>  This software is provided 'as-is', without any express or implied</font></i>
<a name='L7'><i><font color='green'>  warranty.  In no event will the authors be held liable for any damages</font></i>
<a name='L8'><i><font color='green'>  arising from the use of this software.</font></i>
<a name='L9'><i><font color='green'></font></i>
<a name='L10'><i><font color='green'>  Permission is granted to anyone to use this software for any purpose,</font></i>
<a name='L11'><i><font color='green'>  including commercial applications, and to alter it and redistribute it</font></i>
<a name='L12'><i><font color='green'>  freely, subject to the following restrictions:</font></i>
<a name='L13'><i><font color='green'></font></i>
<a name='L14'><i><font color='green'>  1. The origin of this software must not be misrepresented; you must not</font></i>
<a name='L15'><i><font color='green'>     claim that you wrote the original software. If you use this software</font></i>
<a name='L16'><i><font color='green'>     in a product, an acknowledgment in the product documentation would be</font></i>
<a name='L17'><i><font color='green'>     appreciated but is not required.</font></i>
<a name='L18'><i><font color='green'>  2. Altered source versions must be plainly marked as such, and must not be</font></i>
<a name='L19'><i><font color='green'>     misrepresented as being the original software.</font></i>
<a name='L20'><i><font color='green'>  3. This notice may not be removed or altered from any source distribution.</font></i>
<a name='L21'><i><font color='green'></font></i>
<a name='L22'><i><font color='green'>  Jean-loup Gailly        Mark Adler</font></i>
<a name='L23'><i><font color='green'>  jloup@gzip.org          madler@alumni.caltech.edu</font></i>
<a name='L24'><i><font color='green'></font></i>
<a name='L25'><i><font color='green'></font></i>
<a name='L26'><i><font color='green'>  The data format used by the zlib library is described by RFCs (Request for</font></i>
<a name='L27'><i><font color='green'>  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt</font></i>
<a name='L28'><i><font color='green'>  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).</font></i>
<a name='L29'><i><font color='green'>*/</font></i>
<a name='L30'>
<a name='L31'><font color='darkred'>#ifndef</font> <a href='../S/2769.html#L32' title='Defined at 32 in Modules/zlib/zlib.h.'>ZLIB_H</a>
<a name='L32'><font color='darkred'>#define</font> <a href='../S/2769.html#L31' title='Refered from 31 in Modules/zlib/zlib.h.'>ZLIB_H</a>
<a name='L33'>
<a name='L34'><font color='darkred'>#include</font> "<a href='2764.html'>zconf.h</a>"
<a name='L35'>
<a name='L36'><font color='darkred'>#ifdef</font> __cplusplus
<a name='L37'><b>extern</b> "C" <font color='red'>{</font>
<a name='L38'><font color='darkred'>#endif</font>
<a name='L39'>
<a name='L40'><font color='darkred'>#define</font> <a href='../R/5266.html' title='Multiple refered from 13 places.'>ZLIB_VERSION</a> "1.2.5"
<a name='L41'><font color='darkred'>#define</font> <a href='../S/2739.html#L532' title='Refered from 532 in Modules/zlib/example.c.'>ZLIB_VERNUM</a> 0x1250
<a name='L42'><font color='darkred'>#define</font> ZLIB_VER_MAJOR 1
<a name='L43'><font color='darkred'>#define</font> ZLIB_VER_MINOR 2
<a name='L44'><font color='darkred'>#define</font> ZLIB_VER_REVISION 5
<a name='L45'><font color='darkred'>#define</font> ZLIB_VER_SUBREVISION 0
<a name='L46'>
<a name='L47'><i><font color='green'>/*</font></i>
<a name='L48'><i><font color='green'>    The 'zlib' compression library provides in-memory compression and</font></i>
<a name='L49'><i><font color='green'>  decompression functions, including integrity checks of the uncompressed data.</font></i>
<a name='L50'><i><font color='green'>  This version of the library supports only one compression method (deflation)</font></i>
<a name='L51'><i><font color='green'>  but other algorithms will be added later and will have the same stream</font></i>
<a name='L52'><i><font color='green'>  interface.</font></i>
<a name='L53'><i><font color='green'></font></i>
<a name='L54'><i><font color='green'>    Compression can be done in a single step if the buffers are large enough,</font></i>
<a name='L55'><i><font color='green'>  or can be done by repeated calls of the compression function.  In the latter</font></i>
<a name='L56'><i><font color='green'>  case, the application must provide more input and/or consume the output</font></i>
<a name='L57'><i><font color='green'>  (providing more output space) before each call.</font></i>
<a name='L58'><i><font color='green'></font></i>
<a name='L59'><i><font color='green'>    The compressed data format used by default by the in-memory functions is</font></i>
<a name='L60'><i><font color='green'>  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped</font></i>
<a name='L61'><i><font color='green'>  around a deflate stream, which is itself documented in RFC 1951.</font></i>
<a name='L62'><i><font color='green'></font></i>
<a name='L63'><i><font color='green'>    The library also supports reading and writing files in gzip (.gz) format</font></i>
<a name='L64'><i><font color='green'>  with an interface similar to that of stdio using the functions that start</font></i>
<a name='L65'><i><font color='green'>  with "gz".  The gzip format is different from the zlib format.  gzip is a</font></i>
<a name='L66'><i><font color='green'>  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.</font></i>
<a name='L67'><i><font color='green'></font></i>
<a name='L68'><i><font color='green'>    This library can optionally read and write gzip streams in memory as well.</font></i>
<a name='L69'><i><font color='green'></font></i>
<a name='L70'><i><font color='green'>    The zlib format was designed to be compact and fast for use in memory</font></i>
<a name='L71'><i><font color='green'>  and on communications channels.  The gzip format was designed for single-</font></i>
<a name='L72'><i><font color='green'>  file compression on file systems, has a larger header than zlib to maintain</font></i>
<a name='L73'><i><font color='green'>  directory information, and uses a different, slower check method than zlib.</font></i>
<a name='L74'><i><font color='green'></font></i>
<a name='L75'><i><font color='green'>    The library does not install any signal handler.  The decoder checks</font></i>
<a name='L76'><i><font color='green'>  the consistency of the compressed data, so the library should never crash</font></i>
<a name='L77'><i><font color='green'>  even in case of corrupted input.</font></i>
<a name='L78'><i><font color='green'>*/</font></i>
<a name='L79'>
<a name='L80'><b>typedef</b> <a href='../D/12267.html' title='Multiple defined in 6 places.'>voidpf</a> (*alloc_func) <a href='../R/2174.html' title='Multiple refered from 189 places.'>OF</a>((voidpf opaque, uInt items, uInt size));
<a name='L81'><b>typedef</b> <b>void</b>   (*free_func)  <a href='../R/2174.html' title='Multiple refered from 189 places.'>OF</a>((voidpf opaque, voidpf address));
<a name='L82'>
<a name='L83'><b>struct</b> <a href='../D/9267.html' title='Multiple defined in 5 places.'>internal_state</a>;
<a name='L84'>
<a name='L85'><b>typedef</b> <b>struct</b> z_stream_s <font color='red'>{</font>
<a name='L86'>    <a href='../D/459.html' title='Multiple defined in 6 places.'>Bytef</a>    *next_in;  <i><font color='green'>/* next input byte */</font></i>
<a name='L87'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>     avail_in;  <i><font color='green'>/* number of bytes available at next_in */</font></i>
<a name='L88'>    <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a>    total_in;  <i><font color='green'>/* total nb of input bytes read so far */</font></i>
<a name='L89'>
<a name='L90'>    <a href='../D/459.html' title='Multiple defined in 6 places.'>Bytef</a>    *next_out; <i><font color='green'>/* next output byte should be put there */</font></i>
<a name='L91'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>     avail_out; <i><font color='green'>/* remaining free space at next_out */</font></i>
<a name='L92'>    <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a>    total_out; <i><font color='green'>/* total nb of bytes output so far */</font></i>
<a name='L93'>
<a name='L94'>    <b>char</b>     *msg;      <i><font color='green'>/* last error message, NULL if no error */</font></i>
<a name='L95'>    <b>struct</b> <a href='../D/9267.html' title='Multiple defined in 5 places.'>internal_state</a> <a href='../D/1088.html' title='Multiple defined in 13 places.'>FAR</a> *<a href='../S/530.html#L46' title='Defined at 46 in Include/grammar.h.'>state</a>; <i><font color='green'>/* not visible by applications */</font></i>
<a name='L96'>
<a name='L97'>    <a href='../D/6713.html' title='Multiple defined in 2 places.'>alloc_func</a> zalloc;  <i><font color='green'>/* used to allocate the internal state */</font></i>
<a name='L98'>    <a href='../D/8725.html' title='Multiple defined in 2 places.'>free_func</a>  zfree;   <i><font color='green'>/* used to free the internal state */</font></i>
<a name='L99'>    <a href='../D/12267.html' title='Multiple defined in 6 places.'>voidpf</a>     opaque;  <i><font color='green'>/* private data object passed to zalloc and zfree */</font></i>
<a name='L100'>
<a name='L101'>    <b>int</b>     data_type;  <i><font color='green'>/* best guess about the data type: binary or text */</font></i>
<a name='L102'>    <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a>   adler;      <i><font color='green'>/* adler32 value of the uncompressed data */</font></i>
<a name='L103'>    <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a>   reserved;   <i><font color='green'>/* reserved for future use */</font></i>
<a name='L104'><font color='red'>}</font> <a href='../R/11529.html' title='Multiple refered from 27 places.'>z_stream</a>;
<a name='L105'>
<a name='L106'><b>typedef</b> <a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a> FAR *<a href='../R/11530.html' title='Multiple refered from 15 places.'>z_streamp</a>;
<a name='L107'>
<a name='L108'><i><font color='green'>/*</font></i>
<a name='L109'><i><font color='green'>     gzip header information passed to and from zlib routines.  See RFC 1952</font></i>
<a name='L110'><i><font color='green'>  for more details on the meanings of these fields.</font></i>
<a name='L111'><i><font color='green'>*/</font></i>
<a name='L112'><b>typedef</b> <b>struct</b> gz_header_s <font color='red'>{</font>
<a name='L113'>    <b>int</b>     text;       <i><font color='green'>/* true if compressed data believed to be text */</font></i>
<a name='L114'>    <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a>   time;       <i><font color='green'>/* modification time */</font></i>
<a name='L115'>    <b>int</b>     xflags;     <i><font color='green'>/* extra flags (not used when writing a gzip file) */</font></i>
<a name='L116'>    <b>int</b>     os;         <i><font color='green'>/* operating system */</font></i>
<a name='L117'>    <a href='../D/459.html' title='Multiple defined in 6 places.'>Bytef</a>   *extra;     <i><font color='green'>/* pointer to extra field or Z_NULL if none */</font></i>
<a name='L118'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>    extra_len;  <i><font color='green'>/* extra field length (valid if extra != Z_NULL) */</font></i>
<a name='L119'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>    extra_max;  <i><font color='green'>/* space at extra (only when reading header) */</font></i>
<a name='L120'>    <a href='../D/459.html' title='Multiple defined in 6 places.'>Bytef</a>   *name;      <i><font color='green'>/* pointer to zero-terminated file name or Z_NULL */</font></i>
<a name='L121'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>    name_max;   <i><font color='green'>/* space at name (only when reading header) */</font></i>
<a name='L122'>    <a href='../D/459.html' title='Multiple defined in 6 places.'>Bytef</a>   *comment;   <i><font color='green'>/* pointer to zero-terminated comment or Z_NULL */</font></i>
<a name='L123'>    <a href='../D/11918.html' title='Multiple defined in 4 places.'>uInt</a>    comm_max;   <i><font color='green'>/* space at comment (only when reading header) */</font></i>
<a name='L124'>    <b>int</b>     hcrc;       <i><font color='green'>/* true if there was or will be a header crc */</font></i>
<a name='L125'>    <b>int</b>     done;       <i><font color='green'>/* true when done reading gzip header (not used</font></i>
<a name='L126'><i><font color='green'>                           when writing a gzip file) */</font></i>
<a name='L127'><font color='red'>}</font> <a href='../S/2769.html#L129' title='Refered from 129 in Modules/zlib/zlib.h.'>gz_header</a>;
<a name='L128'>
<a name='L129'><b>typedef</b> <a href='../D/9001.html' title='Multiple defined in 2 places.'>gz_header</a> FAR *<a href='../R/8200.html' title='Multiple refered from 2 places.'>gz_headerp</a>;
<a name='L130'>
<a name='L131'><i><font color='green'>/*</font></i>
<a name='L132'><i><font color='green'>     The application must update next_in and avail_in when avail_in has dropped</font></i>
<a name='L133'><i><font color='green'>   to zero.  It must update next_out and avail_out when avail_out has dropped</font></i>
<a name='L134'><i><font color='green'>   to zero.  The application must initialize zalloc, zfree and opaque before</font></i>
<a name='L135'><i><font color='green'>   calling the init function.  All other fields are set by the compression</font></i>
<a name='L136'><i><font color='green'>   library and must not be updated by the application.</font></i>
<a name='L137'><i><font color='green'></font></i>
<a name='L138'><i><font color='green'>     The opaque value provided by the application will be passed as the first</font></i>
<a name='L139'><i><font color='green'>   parameter for calls of zalloc and zfree.  This can be useful for custom</font></i>
<a name='L140'><i><font color='green'>   memory management.  The compression library attaches no meaning to the</font></i>
<a name='L141'><i><font color='green'>   opaque value.</font></i>
<a name='L142'><i><font color='green'></font></i>
<a name='L143'><i><font color='green'>     zalloc must return Z_NULL if there is not enough memory for the object.</font></i>
<a name='L144'><i><font color='green'>   If zlib is used in a multi-threaded application, zalloc and zfree must be</font></i>
<a name='L145'><i><font color='green'>   thread safe.</font></i>
<a name='L146'><i><font color='green'></font></i>
<a name='L147'><i><font color='green'>     On 16-bit systems, the functions zalloc and zfree must be able to allocate</font></i>
<a name='L148'><i><font color='green'>   exactly 65536 bytes, but will not be required to allocate more than this if</font></i>
<a name='L149'><i><font color='green'>   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers</font></i>
<a name='L150'><i><font color='green'>   returned by zalloc for objects of exactly 65536 bytes *must* have their</font></i>
<a name='L151'><i><font color='green'>   offset normalized to zero.  The default allocation function provided by this</font></i>
<a name='L152'><i><font color='green'>   library ensures this (see zutil.c).  To reduce memory requirements and avoid</font></i>
<a name='L153'><i><font color='green'>   any allocation of 64K objects, at the expense of compression ratio, compile</font></i>
<a name='L154'><i><font color='green'>   the library with -DMAX_WBITS=14 (see zconf.h).</font></i>
<a name='L155'><i><font color='green'></font></i>
<a name='L156'><i><font color='green'>     The fields total_in and total_out can be used for statistics or progress</font></i>
<a name='L157'><i><font color='green'>   reports.  After compression, total_in holds the total size of the</font></i>
<a name='L158'><i><font color='green'>   uncompressed data and may be saved for use in the decompressor (particularly</font></i>
<a name='L159'><i><font color='green'>   if the decompressor wants to decompress everything in a single step).</font></i>
<a name='L160'><i><font color='green'>*/</font></i>
<a name='L161'>
<a name='L162'>                        <i><font color='green'>/* constants */</font></i>
<a name='L163'>
<a name='L164'><font color='darkred'>#define</font> <a href='../R/5288.html' title='Multiple refered from 31 places.'>Z_NO_FLUSH</a>      0
<a name='L165'><font color='darkred'>#define</font> <a href='../R/5291.html' title='Multiple refered from 2 places.'>Z_PARTIAL_FLUSH</a> 1
<a name='L166'><font color='darkred'>#define</font> <a href='../R/5296.html' title='Multiple refered from 3 places.'>Z_SYNC_FLUSH</a>    2
<a name='L167'><font color='darkred'>#define</font> <a href='../R/5282.html' title='Multiple refered from 3 places.'>Z_FULL_FLUSH</a>    3
<a name='L168'><font color='darkred'>#define</font> <a href='../R/5280.html' title='Multiple refered from 34 places.'>Z_FINISH</a>        4
<a name='L169'><font color='darkred'>#define</font> <a href='../R/5271.html' title='Multiple refered from 4 places.'>Z_BLOCK</a>         5
<a name='L170'><font color='darkred'>#define</font> <a href='../R/5298.html' title='Multiple refered from 4 places.'>Z_TREES</a>         6
<a name='L171'><i><font color='green'>/* Allowed flush values; see deflate() and inflate() below for details */</font></i>
<a name='L172'>
<a name='L173'><font color='darkred'>#define</font> <a href='../R/5290.html' title='Multiple refered from 99 places.'>Z_OK</a>            0
<a name='L174'><font color='darkred'>#define</font> <a href='../R/5294.html' title='Multiple refered from 34 places.'>Z_STREAM_END</a>    1
<a name='L175'><font color='darkred'>#define</font> <a href='../R/5286.html' title='Multiple refered from 5 places.'>Z_NEED_DICT</a>     2
<a name='L176'><font color='darkred'>#define</font> <a href='../R/5278.html' title='Multiple refered from 19 places.'>Z_ERRNO</a>        (-1)
<a name='L177'><font color='darkred'>#define</font> <a href='../R/5295.html' title='Multiple refered from 67 places.'>Z_STREAM_ERROR</a> (-2)
<a name='L178'><font color='darkred'>#define</font> <a href='../R/5274.html' title='Multiple refered from 24 places.'>Z_DATA_ERROR</a>   (-3)
<a name='L179'><font color='darkred'>#define</font> <a href='../R/5285.html' title='Multiple refered from 28 places.'>Z_MEM_ERROR</a>    (-4)
<a name='L180'><font color='darkred'>#define</font> <a href='../R/5273.html' title='Multiple refered from 24 places.'>Z_BUF_ERROR</a>    (-5)
<a name='L181'><font color='darkred'>#define</font> <a href='../R/5300.html' title='Multiple refered from 3 places.'>Z_VERSION_ERROR</a> (-6)
<a name='L182'><i><font color='green'>/* Return codes for the compression/decompression functions. Negative values</font></i>
<a name='L183'><i><font color='green'> * are errors, positive values are used for special but normal events.</font></i>
<a name='L184'><i><font color='green'> */</font></i>
<a name='L185'>
<a name='L186'><font color='darkred'>#define</font> <a href='../S/2739.html#L278' title='Refered from 278 in Modules/zlib/example.c.'>Z_NO_COMPRESSION</a>         0
<a name='L187'><font color='darkred'>#define</font> <a href='../R/5269.html' title='Multiple refered from 2 places.'>Z_BEST_SPEED</a>             1
<a name='L188'><font color='darkred'>#define</font> <a href='../R/5268.html' title='Multiple refered from 3 places.'>Z_BEST_COMPRESSION</a>       9
<a name='L189'><font color='darkred'>#define</font> <a href='../R/5275.html' title='Multiple refered from 10 places.'>Z_DEFAULT_COMPRESSION</a>  (-1)
<a name='L190'><i><font color='green'>/* compression levels */</font></i>
<a name='L191'>
<a name='L192'><font color='darkred'>#define</font> <a href='../R/5279.html' title='Multiple refered from 5 places.'>Z_FILTERED</a>            1
<a name='L193'><font color='darkred'>#define</font> <a href='../R/5284.html' title='Multiple refered from 7 places.'>Z_HUFFMAN_ONLY</a>        2
<a name='L194'><font color='darkred'>#define</font> <a href='../R/5293.html' title='Multiple refered from 3 places.'>Z_RLE</a>                 3
<a name='L195'><font color='darkred'>#define</font> <a href='../R/5281.html' title='Multiple refered from 4 places.'>Z_FIXED</a>               4
<a name='L196'><font color='darkred'>#define</font> <a href='../R/5276.html' title='Multiple refered from 5 places.'>Z_DEFAULT_STRATEGY</a>    0
<a name='L197'><i><font color='green'>/* compression strategy; see deflateInit2() below for details */</font></i>
<a name='L198'>
<a name='L199'><font color='darkred'>#define</font> <a href='../R/5270.html' title='Multiple refered from 2 places.'>Z_BINARY</a>   0
<a name='L200'><font color='darkred'>#define</font> <a href='../R/5297.html' title='Multiple refered from 3 places.'>Z_TEXT</a>     1
<a name='L201'><font color='darkred'>#define</font> Z_ASCII    <a href='../S/2769.html#L200' title='Defined at 200 in Modules/zlib/zlib.h.'>Z_TEXT</a>   <i><font color='green'>/* for compatibility with 1.2.2 and earlier */</font></i>
<a name='L202'><font color='darkred'>#define</font> <a href='../R/5299.html' title='Multiple refered from 2 places.'>Z_UNKNOWN</a>  2
<a name='L203'><i><font color='green'>/* Possible values of the data_type field (though see inflate()) */</font></i>
<a name='L204'>
<a name='L205'><font color='darkred'>#define</font> <a href='../R/5277.html' title='Multiple refered from 10 places.'>Z_DEFLATED</a>   8
<a name='L206'><i><font color='green'>/* The deflate compression method (the only one supported in this version) */</font></i>
<a name='L207'>
<a name='L208'><font color='darkred'>#define</font> <a href='../R/5289.html' title='Multiple refered from 146 places.'>Z_NULL</a>  0  <i><font color='green'>/* for initializing zalloc, zfree, opaque */</font></i>
<a name='L209'>
<a name='L210'><font color='darkred'>#define</font> zlib_version <a href='../D/12468.html' title='Multiple defined in 2 places.'>zlibVersion</a>()
<a name='L211'><i><font color='green'>/* for compatibility with versions &lt; 1.0.2 */</font></i>
<a name='L212'>
<a name='L213'>
<a name='L214'>                        <i><font color='green'>/* basic functions */</font></i>
<a name='L215'>
<a name='L216'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>const</b> <b>char</b> * <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/12468.html' title='Multiple defined in 2 places.'>zlibVersion</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>void</b>));
<a name='L217'><i><font color='green'>/* The application can compare zlibVersion and ZLIB_VERSION for consistency.</font></i>
<a name='L218'><i><font color='green'>   If the first character differs, the library code actually used is not</font></i>
<a name='L219'><i><font color='green'>   compatible with the zlib.h header file used by the application.  This check</font></i>
<a name='L220'><i><font color='green'>   is automatically made by deflateInit and inflateInit.</font></i>
<a name='L221'><i><font color='green'> */</font></i>
<a name='L222'>
<a name='L223'><i><font color='green'>/*</font></i>
<a name='L224'><i><font color='green'>ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));</font></i>
<a name='L225'><i><font color='green'></font></i>
<a name='L226'><i><font color='green'>     Initializes the internal stream state for compression.  The fields</font></i>
<a name='L227'><i><font color='green'>   zalloc, zfree and opaque must be initialized before by the caller.  If</font></i>
<a name='L228'><i><font color='green'>   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default</font></i>
<a name='L229'><i><font color='green'>   allocation functions.</font></i>
<a name='L230'><i><font color='green'></font></i>
<a name='L231'><i><font color='green'>     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:</font></i>
<a name='L232'><i><font color='green'>   1 gives best speed, 9 gives best compression, 0 gives no compression at all</font></i>
<a name='L233'><i><font color='green'>   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION</font></i>
<a name='L234'><i><font color='green'>   requests a default compromise between speed and compression (currently</font></i>
<a name='L235'><i><font color='green'>   equivalent to level 6).</font></i>
<a name='L236'><i><font color='green'></font></i>
<a name='L237'><i><font color='green'>     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</font></i>
<a name='L238'><i><font color='green'>   memory, Z_STREAM_ERROR if level is not a valid compression level, or</font></i>
<a name='L239'><i><font color='green'>   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible</font></i>
<a name='L240'><i><font color='green'>   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null</font></i>
<a name='L241'><i><font color='green'>   if there is no error message.  deflateInit does not perform any compression:</font></i>
<a name='L242'><i><font color='green'>   this will be done by deflate().</font></i>
<a name='L243'><i><font color='green'>*/</font></i>
<a name='L244'>
<a name='L245'>
<a name='L246'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8004.html' title='Multiple defined in 3 places.'>deflate</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b> flush));
<a name='L247'><i><font color='green'>/*</font></i>
<a name='L248'><i><font color='green'>    deflate compresses as much data as possible, and stops when the input</font></i>
<a name='L249'><i><font color='green'>  buffer becomes empty or the output buffer becomes full.  It may introduce</font></i>
<a name='L250'><i><font color='green'>  some output latency (reading input without producing any output) except when</font></i>
<a name='L251'><i><font color='green'>  forced to flush.</font></i>
<a name='L252'><i><font color='green'></font></i>
<a name='L253'><i><font color='green'>    The detailed semantics are as follows.  deflate performs one or both of the</font></i>
<a name='L254'><i><font color='green'>  following actions:</font></i>
<a name='L255'><i><font color='green'></font></i>
<a name='L256'><i><font color='green'>  - Compress more input starting at next_in and update next_in and avail_in</font></i>
<a name='L257'><i><font color='green'>    accordingly.  If not all input can be processed (because there is not</font></i>
<a name='L258'><i><font color='green'>    enough room in the output buffer), next_in and avail_in are updated and</font></i>
<a name='L259'><i><font color='green'>    processing will resume at this point for the next call of deflate().</font></i>
<a name='L260'><i><font color='green'></font></i>
<a name='L261'><i><font color='green'>  - Provide more output starting at next_out and update next_out and avail_out</font></i>
<a name='L262'><i><font color='green'>    accordingly.  This action is forced if the parameter flush is non zero.</font></i>
<a name='L263'><i><font color='green'>    Forcing flush frequently degrades the compression ratio, so this parameter</font></i>
<a name='L264'><i><font color='green'>    should be set only when necessary (in interactive applications).  Some</font></i>
<a name='L265'><i><font color='green'>    output may be provided even if flush is not set.</font></i>
<a name='L266'><i><font color='green'></font></i>
<a name='L267'><i><font color='green'>    Before the call of deflate(), the application should ensure that at least</font></i>
<a name='L268'><i><font color='green'>  one of the actions is possible, by providing more input and/or consuming more</font></i>
<a name='L269'><i><font color='green'>  output, and updating avail_in or avail_out accordingly; avail_out should</font></i>
<a name='L270'><i><font color='green'>  never be zero before the call.  The application can consume the compressed</font></i>
<a name='L271'><i><font color='green'>  output when it wants, for example when the output buffer is full (avail_out</font></i>
<a name='L272'><i><font color='green'>  == 0), or after each call of deflate().  If deflate returns Z_OK and with</font></i>
<a name='L273'><i><font color='green'>  zero avail_out, it must be called again after making room in the output</font></i>
<a name='L274'><i><font color='green'>  buffer because there might be more output pending.</font></i>
<a name='L275'><i><font color='green'></font></i>
<a name='L276'><i><font color='green'>    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to</font></i>
<a name='L277'><i><font color='green'>  decide how much data to accumulate before producing output, in order to</font></i>
<a name='L278'><i><font color='green'>  maximize compression.</font></i>
<a name='L279'><i><font color='green'></font></i>
<a name='L280'><i><font color='green'>    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</font></i>
<a name='L281'><i><font color='green'>  flushed to the output buffer and the output is aligned on a byte boundary, so</font></i>
<a name='L282'><i><font color='green'>  that the decompressor can get all input data available so far.  (In</font></i>
<a name='L283'><i><font color='green'>  particular avail_in is zero after the call if enough output space has been</font></i>
<a name='L284'><i><font color='green'>  provided before the call.) Flushing may degrade compression for some</font></i>
<a name='L285'><i><font color='green'>  compression algorithms and so it should be used only when necessary.  This</font></i>
<a name='L286'><i><font color='green'>  completes the current deflate block and follows it with an empty stored block</font></i>
<a name='L287'><i><font color='green'>  that is three bits plus filler bits to the next byte, followed by four bytes</font></i>
<a name='L288'><i><font color='green'>  (00 00 ff ff).</font></i>
<a name='L289'><i><font color='green'></font></i>
<a name='L290'><i><font color='green'>    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the</font></i>
<a name='L291'><i><font color='green'>  output buffer, but the output is not aligned to a byte boundary.  All of the</font></i>
<a name='L292'><i><font color='green'>  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.</font></i>
<a name='L293'><i><font color='green'>  This completes the current deflate block and follows it with an empty fixed</font></i>
<a name='L294'><i><font color='green'>  codes block that is 10 bits long.  This assures that enough bytes are output</font></i>
<a name='L295'><i><font color='green'>  in order for the decompressor to finish the block before the empty fixed code</font></i>
<a name='L296'><i><font color='green'>  block.</font></i>
<a name='L297'><i><font color='green'></font></i>
<a name='L298'><i><font color='green'>    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as</font></i>
<a name='L299'><i><font color='green'>  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to</font></i>
<a name='L300'><i><font color='green'>  seven bits of the current block are held to be written as the next byte after</font></i>
<a name='L301'><i><font color='green'>  the next deflate block is completed.  In this case, the decompressor may not</font></i>
<a name='L302'><i><font color='green'>  be provided enough bits at this point in order to complete decompression of</font></i>
<a name='L303'><i><font color='green'>  the data provided so far to the compressor.  It may need to wait for the next</font></i>
<a name='L304'><i><font color='green'>  block to be emitted.  This is for advanced applications that need to control</font></i>
<a name='L305'><i><font color='green'>  the emission of deflate blocks.</font></i>
<a name='L306'><i><font color='green'></font></i>
<a name='L307'><i><font color='green'>    If flush is set to Z_FULL_FLUSH, all output is flushed as with</font></i>
<a name='L308'><i><font color='green'>  Z_SYNC_FLUSH, and the compression state is reset so that decompression can</font></i>
<a name='L309'><i><font color='green'>  restart from this point if previous compressed data has been damaged or if</font></i>
<a name='L310'><i><font color='green'>  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade</font></i>
<a name='L311'><i><font color='green'>  compression.</font></i>
<a name='L312'><i><font color='green'></font></i>
<a name='L313'><i><font color='green'>    If deflate returns with avail_out == 0, this function must be called again</font></i>
<a name='L314'><i><font color='green'>  with the same value of the flush parameter and more output space (updated</font></i>
<a name='L315'><i><font color='green'>  avail_out), until the flush is complete (deflate returns with non-zero</font></i>
<a name='L316'><i><font color='green'>  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that</font></i>
<a name='L317'><i><font color='green'>  avail_out is greater than six to avoid repeated flush markers due to</font></i>
<a name='L318'><i><font color='green'>  avail_out == 0 on return.</font></i>
<a name='L319'><i><font color='green'></font></i>
<a name='L320'><i><font color='green'>    If the parameter flush is set to Z_FINISH, pending input is processed,</font></i>
<a name='L321'><i><font color='green'>  pending output is flushed and deflate returns with Z_STREAM_END if there was</font></i>
<a name='L322'><i><font color='green'>  enough output space; if deflate returns with Z_OK, this function must be</font></i>
<a name='L323'><i><font color='green'>  called again with Z_FINISH and more output space (updated avail_out) but no</font></i>
<a name='L324'><i><font color='green'>  more input data, until it returns with Z_STREAM_END or an error.  After</font></i>
<a name='L325'><i><font color='green'>  deflate has returned Z_STREAM_END, the only possible operations on the stream</font></i>
<a name='L326'><i><font color='green'>  are deflateReset or deflateEnd.</font></i>
<a name='L327'><i><font color='green'></font></i>
<a name='L328'><i><font color='green'>    Z_FINISH can be used immediately after deflateInit if all the compression</font></i>
<a name='L329'><i><font color='green'>  is to be done in a single step.  In this case, avail_out must be at least the</font></i>
<a name='L330'><i><font color='green'>  value returned by deflateBound (see below).  If deflate does not return</font></i>
<a name='L331'><i><font color='green'>  Z_STREAM_END, then it must be called again as described above.</font></i>
<a name='L332'><i><font color='green'></font></i>
<a name='L333'><i><font color='green'>    deflate() sets strm-&gt;adler to the adler32 checksum of all input read</font></i>
<a name='L334'><i><font color='green'>  so far (that is, total_in bytes).</font></i>
<a name='L335'><i><font color='green'></font></i>
<a name='L336'><i><font color='green'>    deflate() may update strm-&gt;data_type if it can make a good guess about</font></i>
<a name='L337'><i><font color='green'>  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered</font></i>
<a name='L338'><i><font color='green'>  binary.  This field is only for information purposes and does not affect the</font></i>
<a name='L339'><i><font color='green'>  compression algorithm in any manner.</font></i>
<a name='L340'><i><font color='green'></font></i>
<a name='L341'><i><font color='green'>    deflate() returns Z_OK if some progress has been made (more input</font></i>
<a name='L342'><i><font color='green'>  processed or more output produced), Z_STREAM_END if all input has been</font></i>
<a name='L343'><i><font color='green'>  consumed and all output has been produced (only when flush is set to</font></i>
<a name='L344'><i><font color='green'>  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</font></i>
<a name='L345'><i><font color='green'>  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible</font></i>
<a name='L346'><i><font color='green'>  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not</font></i>
<a name='L347'><i><font color='green'>  fatal, and deflate() can be called again with more input and more output</font></i>
<a name='L348'><i><font color='green'>  space to continue compressing.</font></i>
<a name='L349'><i><font color='green'>*/</font></i>
<a name='L350'>
<a name='L351'>
<a name='L352'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8007.html' title='Multiple defined in 3 places.'>deflateEnd</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L353'><i><font color='green'>/*</font></i>
<a name='L354'><i><font color='green'>     All dynamically allocated data structures for this stream are freed.</font></i>
<a name='L355'><i><font color='green'>   This function discards any unprocessed input and does not flush any pending</font></i>
<a name='L356'><i><font color='green'>   output.</font></i>
<a name='L357'><i><font color='green'></font></i>
<a name='L358'><i><font color='green'>     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</font></i>
<a name='L359'><i><font color='green'>   stream state was inconsistent, Z_DATA_ERROR if the stream was freed</font></i>
<a name='L360'><i><font color='green'>   prematurely (some input or output was discarded).  In the error case, msg</font></i>
<a name='L361'><i><font color='green'>   may be set but then points to a static string (which must not be</font></i>
<a name='L362'><i><font color='green'>   deallocated).</font></i>
<a name='L363'><i><font color='green'>*/</font></i>
<a name='L364'>
<a name='L365'>
<a name='L366'><i><font color='green'>/*</font></i>
<a name='L367'><i><font color='green'>ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));</font></i>
<a name='L368'><i><font color='green'></font></i>
<a name='L369'><i><font color='green'>     Initializes the internal stream state for decompression.  The fields</font></i>
<a name='L370'><i><font color='green'>   next_in, avail_in, zalloc, zfree and opaque must be initialized before by</font></i>
<a name='L371'><i><font color='green'>   the caller.  If next_in is not Z_NULL and avail_in is large enough (the</font></i>
<a name='L372'><i><font color='green'>   exact value depends on the compression method), inflateInit determines the</font></i>
<a name='L373'><i><font color='green'>   compression method from the zlib header and allocates all data structures</font></i>
<a name='L374'><i><font color='green'>   accordingly; otherwise the allocation will be deferred to the first call of</font></i>
<a name='L375'><i><font color='green'>   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to</font></i>
<a name='L376'><i><font color='green'>   use default allocation functions.</font></i>
<a name='L377'><i><font color='green'></font></i>
<a name='L378'><i><font color='green'>     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</font></i>
<a name='L379'><i><font color='green'>   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</font></i>
<a name='L380'><i><font color='green'>   version assumed by the caller, or Z_STREAM_ERROR if the parameters are</font></i>
<a name='L381'><i><font color='green'>   invalid, such as a null pointer to the structure.  msg is set to null if</font></i>
<a name='L382'><i><font color='green'>   there is no error message.  inflateInit does not perform any decompression</font></i>
<a name='L383'><i><font color='green'>   apart from possibly reading the zlib header if present: actual decompression</font></i>
<a name='L384'><i><font color='green'>   will be done by inflate().  (So next_in and avail_in may be modified, but</font></i>
<a name='L385'><i><font color='green'>   next_out and avail_out are unused and unchanged.) The current implementation</font></i>
<a name='L386'><i><font color='green'>   of inflateInit() does not process any header information -- that is deferred</font></i>
<a name='L387'><i><font color='green'>   until inflate() is called.</font></i>
<a name='L388'><i><font color='green'>*/</font></i>
<a name='L389'>
<a name='L390'>
<a name='L391'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9156.html' title='Multiple defined in 3 places.'>inflate</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b> flush));
<a name='L392'><i><font color='green'>/*</font></i>
<a name='L393'><i><font color='green'>    inflate decompresses as much data as possible, and stops when the input</font></i>
<a name='L394'><i><font color='green'>  buffer becomes empty or the output buffer becomes full.  It may introduce</font></i>
<a name='L395'><i><font color='green'>  some output latency (reading input without producing any output) except when</font></i>
<a name='L396'><i><font color='green'>  forced to flush.</font></i>
<a name='L397'><i><font color='green'></font></i>
<a name='L398'><i><font color='green'>  The detailed semantics are as follows.  inflate performs one or both of the</font></i>
<a name='L399'><i><font color='green'>  following actions:</font></i>
<a name='L400'><i><font color='green'></font></i>
<a name='L401'><i><font color='green'>  - Decompress more input starting at next_in and update next_in and avail_in</font></i>
<a name='L402'><i><font color='green'>    accordingly.  If not all input can be processed (because there is not</font></i>
<a name='L403'><i><font color='green'>    enough room in the output buffer), next_in is updated and processing will</font></i>
<a name='L404'><i><font color='green'>    resume at this point for the next call of inflate().</font></i>
<a name='L405'><i><font color='green'></font></i>
<a name='L406'><i><font color='green'>  - Provide more output starting at next_out and update next_out and avail_out</font></i>
<a name='L407'><i><font color='green'>    accordingly.  inflate() provides as much output as possible, until there is</font></i>
<a name='L408'><i><font color='green'>    no more input data or no more space in the output buffer (see below about</font></i>
<a name='L409'><i><font color='green'>    the flush parameter).</font></i>
<a name='L410'><i><font color='green'></font></i>
<a name='L411'><i><font color='green'>    Before the call of inflate(), the application should ensure that at least</font></i>
<a name='L412'><i><font color='green'>  one of the actions is possible, by providing more input and/or consuming more</font></i>
<a name='L413'><i><font color='green'>  output, and updating the next_* and avail_* values accordingly.  The</font></i>
<a name='L414'><i><font color='green'>  application can consume the uncompressed output when it wants, for example</font></i>
<a name='L415'><i><font color='green'>  when the output buffer is full (avail_out == 0), or after each call of</font></i>
<a name='L416'><i><font color='green'>  inflate().  If inflate returns Z_OK and with zero avail_out, it must be</font></i>
<a name='L417'><i><font color='green'>  called again after making room in the output buffer because there might be</font></i>
<a name='L418'><i><font color='green'>  more output pending.</font></i>
<a name='L419'><i><font color='green'></font></i>
<a name='L420'><i><font color='green'>    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,</font></i>
<a name='L421'><i><font color='green'>  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much</font></i>
<a name='L422'><i><font color='green'>  output as possible to the output buffer.  Z_BLOCK requests that inflate()</font></i>
<a name='L423'><i><font color='green'>  stop if and when it gets to the next deflate block boundary.  When decoding</font></i>
<a name='L424'><i><font color='green'>  the zlib or gzip format, this will cause inflate() to return immediately</font></i>
<a name='L425'><i><font color='green'>  after the header and before the first block.  When doing a raw inflate,</font></i>
<a name='L426'><i><font color='green'>  inflate() will go ahead and process the first block, and will return when it</font></i>
<a name='L427'><i><font color='green'>  gets to the end of that block, or when it runs out of data.</font></i>
<a name='L428'><i><font color='green'></font></i>
<a name='L429'><i><font color='green'>    The Z_BLOCK option assists in appending to or combining deflate streams.</font></i>
<a name='L430'><i><font color='green'>  Also to assist in this, on return inflate() will set strm-&gt;data_type to the</font></i>
<a name='L431'><i><font color='green'>  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64 if</font></i>
<a name='L432'><i><font color='green'>  inflate() is currently decoding the last block in the deflate stream, plus</font></i>
<a name='L433'><i><font color='green'>  128 if inflate() returned immediately after decoding an end-of-block code or</font></i>
<a name='L434'><i><font color='green'>  decoding the complete header up to just before the first byte of the deflate</font></i>
<a name='L435'><i><font color='green'>  stream.  The end-of-block will not be indicated until all of the uncompressed</font></i>
<a name='L436'><i><font color='green'>  data from that block has been written to strm-&gt;next_out.  The number of</font></i>
<a name='L437'><i><font color='green'>  unused bits may in general be greater than seven, except when bit 7 of</font></i>
<a name='L438'><i><font color='green'>  data_type is set, in which case the number of unused bits will be less than</font></i>
<a name='L439'><i><font color='green'>  eight.  data_type is set as noted here every time inflate() returns for all</font></i>
<a name='L440'><i><font color='green'>  flush options, and so can be used to determine the amount of currently</font></i>
<a name='L441'><i><font color='green'>  consumed input in bits.</font></i>
<a name='L442'><i><font color='green'></font></i>
<a name='L443'><i><font color='green'>    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the</font></i>
<a name='L444'><i><font color='green'>  end of each deflate block header is reached, before any actual data in that</font></i>
<a name='L445'><i><font color='green'>  block is decoded.  This allows the caller to determine the length of the</font></i>
<a name='L446'><i><font color='green'>  deflate block header for later use in random access within a deflate block.</font></i>
<a name='L447'><i><font color='green'>  256 is added to the value of strm-&gt;data_type when inflate() returns</font></i>
<a name='L448'><i><font color='green'>  immediately after reaching the end of the deflate block header.</font></i>
<a name='L449'><i><font color='green'></font></i>
<a name='L450'><i><font color='green'>    inflate() should normally be called until it returns Z_STREAM_END or an</font></i>
<a name='L451'><i><font color='green'>  error.  However if all decompression is to be performed in a single step (a</font></i>
<a name='L452'><i><font color='green'>  single call of inflate), the parameter flush should be set to Z_FINISH.  In</font></i>
<a name='L453'><i><font color='green'>  this case all pending input is processed and all pending output is flushed;</font></i>
<a name='L454'><i><font color='green'>  avail_out must be large enough to hold all the uncompressed data.  (The size</font></i>
<a name='L455'><i><font color='green'>  of the uncompressed data may have been saved by the compressor for this</font></i>
<a name='L456'><i><font color='green'>  purpose.) The next operation on this stream must be inflateEnd to deallocate</font></i>
<a name='L457'><i><font color='green'>  the decompression state.  The use of Z_FINISH is never required, but can be</font></i>
<a name='L458'><i><font color='green'>  used to inform inflate that a faster approach may be used for the single</font></i>
<a name='L459'><i><font color='green'>  inflate() call.</font></i>
<a name='L460'><i><font color='green'></font></i>
<a name='L461'><i><font color='green'>     In this implementation, inflate() always flushes as much output as</font></i>
<a name='L462'><i><font color='green'>  possible to the output buffer, and always uses the faster approach on the</font></i>
<a name='L463'><i><font color='green'>  first call.  So the only effect of the flush parameter in this implementation</font></i>
<a name='L464'><i><font color='green'>  is on the return value of inflate(), as noted below, or when it returns early</font></i>
<a name='L465'><i><font color='green'>  because Z_BLOCK or Z_TREES is used.</font></i>
<a name='L466'><i><font color='green'></font></i>
<a name='L467'><i><font color='green'>     If a preset dictionary is needed after this call (see inflateSetDictionary</font></i>
<a name='L468'><i><font color='green'>  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary</font></i>
<a name='L469'><i><font color='green'>  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets</font></i>
<a name='L470'><i><font color='green'>  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,</font></i>
<a name='L471'><i><font color='green'>  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described</font></i>
<a name='L472'><i><font color='green'>  below.  At the end of the stream, inflate() checks that its computed adler32</font></i>
<a name='L473'><i><font color='green'>  checksum is equal to that saved by the compressor and returns Z_STREAM_END</font></i>
<a name='L474'><i><font color='green'>  only if the checksum is correct.</font></i>
<a name='L475'><i><font color='green'></font></i>
<a name='L476'><i><font color='green'>    inflate() can decompress and check either zlib-wrapped or gzip-wrapped</font></i>
<a name='L477'><i><font color='green'>  deflate data.  The header type is detected automatically, if requested when</font></i>
<a name='L478'><i><font color='green'>  initializing with inflateInit2().  Any information contained in the gzip</font></i>
<a name='L479'><i><font color='green'>  header is not retained, so applications that need that information should</font></i>
<a name='L480'><i><font color='green'>  instead use raw inflate, see inflateInit2() below, or inflateBack() and</font></i>
<a name='L481'><i><font color='green'>  perform their own processing of the gzip header and trailer.</font></i>
<a name='L482'><i><font color='green'></font></i>
<a name='L483'><i><font color='green'>    inflate() returns Z_OK if some progress has been made (more input processed</font></i>
<a name='L484'><i><font color='green'>  or more output produced), Z_STREAM_END if the end of the compressed data has</font></i>
<a name='L485'><i><font color='green'>  been reached and all uncompressed output has been produced, Z_NEED_DICT if a</font></i>
<a name='L486'><i><font color='green'>  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</font></i>
<a name='L487'><i><font color='green'>  corrupted (input stream not conforming to the zlib format or incorrect check</font></i>
<a name='L488'><i><font color='green'>  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example</font></i>
<a name='L489'><i><font color='green'>  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,</font></i>
<a name='L490'><i><font color='green'>  Z_BUF_ERROR if no progress is possible or if there was not enough room in the</font></i>
<a name='L491'><i><font color='green'>  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and</font></i>
<a name='L492'><i><font color='green'>  inflate() can be called again with more input and more output space to</font></i>
<a name='L493'><i><font color='green'>  continue decompressing.  If Z_DATA_ERROR is returned, the application may</font></i>
<a name='L494'><i><font color='green'>  then call inflateSync() to look for a good compression block if a partial</font></i>
<a name='L495'><i><font color='green'>  recovery of the data is desired.</font></i>
<a name='L496'><i><font color='green'>*/</font></i>
<a name='L497'>
<a name='L498'>
<a name='L499'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9162.html' title='Multiple defined in 3 places.'>inflateEnd</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L500'><i><font color='green'>/*</font></i>
<a name='L501'><i><font color='green'>     All dynamically allocated data structures for this stream are freed.</font></i>
<a name='L502'><i><font color='green'>   This function discards any unprocessed input and does not flush any pending</font></i>
<a name='L503'><i><font color='green'>   output.</font></i>
<a name='L504'><i><font color='green'></font></i>
<a name='L505'><i><font color='green'>     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state</font></i>
<a name='L506'><i><font color='green'>   was inconsistent.  In the error case, msg may be set but then points to a</font></i>
<a name='L507'><i><font color='green'>   static string (which must not be deallocated).</font></i>
<a name='L508'><i><font color='green'>*/</font></i>
<a name='L509'>
<a name='L510'>
<a name='L511'>                        <i><font color='green'>/* Advanced functions */</font></i>
<a name='L512'>
<a name='L513'><i><font color='green'>/*</font></i>
<a name='L514'><i><font color='green'>    The following functions are needed only in some special applications.</font></i>
<a name='L515'><i><font color='green'>*/</font></i>
<a name='L516'>
<a name='L517'><i><font color='green'>/*</font></i>
<a name='L518'><i><font color='green'>ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,</font></i>
<a name='L519'><i><font color='green'>                                     int  level,</font></i>
<a name='L520'><i><font color='green'>                                     int  method,</font></i>
<a name='L521'><i><font color='green'>                                     int  windowBits,</font></i>
<a name='L522'><i><font color='green'>                                     int  memLevel,</font></i>
<a name='L523'><i><font color='green'>                                     int  strategy));</font></i>
<a name='L524'><i><font color='green'></font></i>
<a name='L525'><i><font color='green'>     This is another version of deflateInit with more compression options.  The</font></i>
<a name='L526'><i><font color='green'>   fields next_in, zalloc, zfree and opaque must be initialized before by the</font></i>
<a name='L527'><i><font color='green'>   caller.</font></i>
<a name='L528'><i><font color='green'></font></i>
<a name='L529'><i><font color='green'>     The method parameter is the compression method.  It must be Z_DEFLATED in</font></i>
<a name='L530'><i><font color='green'>   this version of the library.</font></i>
<a name='L531'><i><font color='green'></font></i>
<a name='L532'><i><font color='green'>     The windowBits parameter is the base two logarithm of the window size</font></i>
<a name='L533'><i><font color='green'>   (the size of the history buffer).  It should be in the range 8..15 for this</font></i>
<a name='L534'><i><font color='green'>   version of the library.  Larger values of this parameter result in better</font></i>
<a name='L535'><i><font color='green'>   compression at the expense of memory usage.  The default value is 15 if</font></i>
<a name='L536'><i><font color='green'>   deflateInit is used instead.</font></i>
<a name='L537'><i><font color='green'></font></i>
<a name='L538'><i><font color='green'>     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits</font></i>
<a name='L539'><i><font color='green'>   determines the window size.  deflate() will then generate raw deflate data</font></i>
<a name='L540'><i><font color='green'>   with no zlib header or trailer, and will not compute an adler32 check value.</font></i>
<a name='L541'><i><font color='green'></font></i>
<a name='L542'><i><font color='green'>     windowBits can also be greater than 15 for optional gzip encoding.  Add</font></i>
<a name='L543'><i><font color='green'>   16 to windowBits to write a simple gzip header and trailer around the</font></i>
<a name='L544'><i><font color='green'>   compressed data instead of a zlib wrapper.  The gzip header will have no</font></i>
<a name='L545'><i><font color='green'>   file name, no extra data, no comment, no modification time (set to zero), no</font></i>
<a name='L546'><i><font color='green'>   header crc, and the operating system will be set to 255 (unknown).  If a</font></i>
<a name='L547'><i><font color='green'>   gzip stream is being written, strm-&gt;adler is a crc32 instead of an adler32.</font></i>
<a name='L548'><i><font color='green'></font></i>
<a name='L549'><i><font color='green'>     The memLevel parameter specifies how much memory should be allocated</font></i>
<a name='L550'><i><font color='green'>   for the internal compression state.  memLevel=1 uses minimum memory but is</font></i>
<a name='L551'><i><font color='green'>   slow and reduces compression ratio; memLevel=9 uses maximum memory for</font></i>
<a name='L552'><i><font color='green'>   optimal speed.  The default value is 8.  See zconf.h for total memory usage</font></i>
<a name='L553'><i><font color='green'>   as a function of windowBits and memLevel.</font></i>
<a name='L554'><i><font color='green'></font></i>
<a name='L555'><i><font color='green'>     The strategy parameter is used to tune the compression algorithm.  Use the</font></i>
<a name='L556'><i><font color='green'>   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</font></i>
<a name='L557'><i><font color='green'>   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no</font></i>
<a name='L558'><i><font color='green'>   string match), or Z_RLE to limit match distances to one (run-length</font></i>
<a name='L559'><i><font color='green'>   encoding).  Filtered data consists mostly of small values with a somewhat</font></i>
<a name='L560'><i><font color='green'>   random distribution.  In this case, the compression algorithm is tuned to</font></i>
<a name='L561'><i><font color='green'>   compress them better.  The effect of Z_FILTERED is to force more Huffman</font></i>
<a name='L562'><i><font color='green'>   coding and less string matching; it is somewhat intermediate between</font></i>
<a name='L563'><i><font color='green'>   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as</font></i>
<a name='L564'><i><font color='green'>   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The</font></i>
<a name='L565'><i><font color='green'>   strategy parameter only affects the compression ratio but not the</font></i>
<a name='L566'><i><font color='green'>   correctness of the compressed output even if it is not set appropriately.</font></i>
<a name='L567'><i><font color='green'>   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler</font></i>
<a name='L568'><i><font color='green'>   decoder for special applications.</font></i>
<a name='L569'><i><font color='green'></font></i>
<a name='L570'><i><font color='green'>     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</font></i>
<a name='L571'><i><font color='green'>   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid</font></i>
<a name='L572'><i><font color='green'>   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is</font></i>
<a name='L573'><i><font color='green'>   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is</font></i>
<a name='L574'><i><font color='green'>   set to null if there is no error message.  deflateInit2 does not perform any</font></i>
<a name='L575'><i><font color='green'>   compression: this will be done by deflate().</font></i>
<a name='L576'><i><font color='green'>*/</font></i>
<a name='L577'>
<a name='L578'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8015.html' title='Multiple defined in 3 places.'>deflateSetDictionary</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L579'>                                             <b>const</b> Bytef *dictionary,
<a name='L580'>                                             uInt  dictLength));
<a name='L581'><i><font color='green'>/*</font></i>
<a name='L582'><i><font color='green'>     Initializes the compression dictionary from the given byte sequence</font></i>
<a name='L583'><i><font color='green'>   without producing any compressed output.  This function must be called</font></i>
<a name='L584'><i><font color='green'>   immediately after deflateInit, deflateInit2 or deflateReset, before any call</font></i>
<a name='L585'><i><font color='green'>   of deflate.  The compressor and decompressor must use exactly the same</font></i>
<a name='L586'><i><font color='green'>   dictionary (see inflateSetDictionary).</font></i>
<a name='L587'><i><font color='green'></font></i>
<a name='L588'><i><font color='green'>     The dictionary should consist of strings (byte sequences) that are likely</font></i>
<a name='L589'><i><font color='green'>   to be encountered later in the data to be compressed, with the most commonly</font></i>
<a name='L590'><i><font color='green'>   used strings preferably put towards the end of the dictionary.  Using a</font></i>
<a name='L591'><i><font color='green'>   dictionary is most useful when the data to be compressed is short and can be</font></i>
<a name='L592'><i><font color='green'>   predicted with good accuracy; the data can then be compressed better than</font></i>
<a name='L593'><i><font color='green'>   with the default empty dictionary.</font></i>
<a name='L594'><i><font color='green'></font></i>
<a name='L595'><i><font color='green'>     Depending on the size of the compression data structures selected by</font></i>
<a name='L596'><i><font color='green'>   deflateInit or deflateInit2, a part of the dictionary may in effect be</font></i>
<a name='L597'><i><font color='green'>   discarded, for example if the dictionary is larger than the window size</font></i>
<a name='L598'><i><font color='green'>   provided in deflateInit or deflateInit2.  Thus the strings most likely to be</font></i>
<a name='L599'><i><font color='green'>   useful should be put at the end of the dictionary, not at the front.  In</font></i>
<a name='L600'><i><font color='green'>   addition, the current implementation of deflate will use at most the window</font></i>
<a name='L601'><i><font color='green'>   size minus 262 bytes of the provided dictionary.</font></i>
<a name='L602'><i><font color='green'></font></i>
<a name='L603'><i><font color='green'>     Upon return of this function, strm-&gt;adler is set to the adler32 value</font></i>
<a name='L604'><i><font color='green'>   of the dictionary; the decompressor may later use this value to determine</font></i>
<a name='L605'><i><font color='green'>   which dictionary has been used by the compressor.  (The adler32 value</font></i>
<a name='L606'><i><font color='green'>   applies to the whole dictionary even if only a subset of the dictionary is</font></i>
<a name='L607'><i><font color='green'>   actually used by the compressor.) If a raw deflate was requested, then the</font></i>
<a name='L608'><i><font color='green'>   adler32 value is not computed and strm-&gt;adler is not set.</font></i>
<a name='L609'><i><font color='green'></font></i>
<a name='L610'><i><font color='green'>     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a</font></i>
<a name='L611'><i><font color='green'>   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is</font></i>
<a name='L612'><i><font color='green'>   inconsistent (for example if deflate has already been called for this stream</font></i>
<a name='L613'><i><font color='green'>   or if the compression method is bsort).  deflateSetDictionary does not</font></i>
<a name='L614'><i><font color='green'>   perform any compression: this will be done by deflate().</font></i>
<a name='L615'><i><font color='green'>*/</font></i>
<a name='L616'>
<a name='L617'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8006.html' title='Multiple defined in 3 places.'>deflateCopy</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp dest,
<a name='L618'>                                    z_streamp source));
<a name='L619'><i><font color='green'>/*</font></i>
<a name='L620'><i><font color='green'>     Sets the destination stream as a complete copy of the source stream.</font></i>
<a name='L621'><i><font color='green'></font></i>
<a name='L622'><i><font color='green'>     This function can be useful when several compression strategies will be</font></i>
<a name='L623'><i><font color='green'>   tried, for example when there are several ways of pre-processing the input</font></i>
<a name='L624'><i><font color='green'>   data with a filter.  The streams that will be discarded should then be freed</font></i>
<a name='L625'><i><font color='green'>   by calling deflateEnd.  Note that deflateCopy duplicates the internal</font></i>
<a name='L626'><i><font color='green'>   compression state which can be quite large, so this strategy is slow and can</font></i>
<a name='L627'><i><font color='green'>   consume lots of memory.</font></i>
<a name='L628'><i><font color='green'></font></i>
<a name='L629'><i><font color='green'>     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</font></i>
<a name='L630'><i><font color='green'>   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</font></i>
<a name='L631'><i><font color='green'>   (such as zalloc being Z_NULL).  msg is left unchanged in both source and</font></i>
<a name='L632'><i><font color='green'>   destination.</font></i>
<a name='L633'><i><font color='green'>*/</font></i>
<a name='L634'>
<a name='L635'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8014.html' title='Multiple defined in 3 places.'>deflateReset</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L636'><i><font color='green'>/*</font></i>
<a name='L637'><i><font color='green'>     This function is equivalent to deflateEnd followed by deflateInit,</font></i>
<a name='L638'><i><font color='green'>   but does not free and reallocate all the internal compression state.  The</font></i>
<a name='L639'><i><font color='green'>   stream will keep the same compression level and any other attributes that</font></i>
<a name='L640'><i><font color='green'>   may have been set by deflateInit2.</font></i>
<a name='L641'><i><font color='green'></font></i>
<a name='L642'><i><font color='green'>     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L643'><i><font color='green'>   stream state was inconsistent (such as zalloc or state being Z_NULL).</font></i>
<a name='L644'><i><font color='green'>*/</font></i>
<a name='L645'>
<a name='L646'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8012.html' title='Multiple defined in 3 places.'>deflateParams</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L647'>                                      <b>int</b> level,
<a name='L648'>                                      <b>int</b> strategy));
<a name='L649'><i><font color='green'>/*</font></i>
<a name='L650'><i><font color='green'>     Dynamically update the compression level and compression strategy.  The</font></i>
<a name='L651'><i><font color='green'>   interpretation of level and strategy is as in deflateInit2.  This can be</font></i>
<a name='L652'><i><font color='green'>   used to switch between compression and straight copy of the input data, or</font></i>
<a name='L653'><i><font color='green'>   to switch to a different kind of input data requiring a different strategy.</font></i>
<a name='L654'><i><font color='green'>   If the compression level is changed, the input available so far is</font></i>
<a name='L655'><i><font color='green'>   compressed with the old level (and may be flushed); the new level will take</font></i>
<a name='L656'><i><font color='green'>   effect only at the next call of deflate().</font></i>
<a name='L657'><i><font color='green'></font></i>
<a name='L658'><i><font color='green'>     Before the call of deflateParams, the stream state must be set as for</font></i>
<a name='L659'><i><font color='green'>   a call of deflate(), since the currently available input may have to be</font></i>
<a name='L660'><i><font color='green'>   compressed and flushed.  In particular, strm-&gt;avail_out must be non-zero.</font></i>
<a name='L661'><i><font color='green'></font></i>
<a name='L662'><i><font color='green'>     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source</font></i>
<a name='L663'><i><font color='green'>   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if</font></i>
<a name='L664'><i><font color='green'>   strm-&gt;avail_out was zero.</font></i>
<a name='L665'><i><font color='green'>*/</font></i>
<a name='L666'>
<a name='L667'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8017.html' title='Multiple defined in 2 places.'>deflateTune</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L668'>                                    <b>int</b> good_length,
<a name='L669'>                                    <b>int</b> max_lazy,
<a name='L670'>                                    <b>int</b> nice_length,
<a name='L671'>                                    <b>int</b> max_chain));
<a name='L672'><i><font color='green'>/*</font></i>
<a name='L673'><i><font color='green'>     Fine tune deflate's internal compression parameters.  This should only be</font></i>
<a name='L674'><i><font color='green'>   used by someone who understands the algorithm used by zlib's deflate for</font></i>
<a name='L675'><i><font color='green'>   searching for the best matching string, and even then only by the most</font></i>
<a name='L676'><i><font color='green'>   fanatic optimizer trying to squeeze out the last compressed bit for their</font></i>
<a name='L677'><i><font color='green'>   specific input data.  Read the deflate.c source code for the meaning of the</font></i>
<a name='L678'><i><font color='green'>   max_lazy, good_length, nice_length, and max_chain parameters.</font></i>
<a name='L679'><i><font color='green'></font></i>
<a name='L680'><i><font color='green'>     deflateTune() can be called after deflateInit() or deflateInit2(), and</font></i>
<a name='L681'><i><font color='green'>   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.</font></i>
<a name='L682'><i><font color='green'> */</font></i>
<a name='L683'>
<a name='L684'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8005.html' title='Multiple defined in 3 places.'>deflateBound</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L685'>                                       uLong sourceLen));
<a name='L686'><i><font color='green'>/*</font></i>
<a name='L687'><i><font color='green'>     deflateBound() returns an upper bound on the compressed size after</font></i>
<a name='L688'><i><font color='green'>   deflation of sourceLen bytes.  It must be called after deflateInit() or</font></i>
<a name='L689'><i><font color='green'>   deflateInit2(), and after deflateSetHeader(), if used.  This would be used</font></i>
<a name='L690'><i><font color='green'>   to allocate an output buffer for deflation in a single pass, and so would be</font></i>
<a name='L691'><i><font color='green'>   called before deflate().</font></i>
<a name='L692'><i><font color='green'>*/</font></i>
<a name='L693'>
<a name='L694'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8013.html' title='Multiple defined in 3 places.'>deflatePrime</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L695'>                                     <b>int</b> bits,
<a name='L696'>                                     <b>int</b> value));
<a name='L697'><i><font color='green'>/*</font></i>
<a name='L698'><i><font color='green'>     deflatePrime() inserts bits in the deflate output stream.  The intent</font></i>
<a name='L699'><i><font color='green'>   is that this function is used to start off the deflate output with the bits</font></i>
<a name='L700'><i><font color='green'>   leftover from a previous deflate stream when appending to it.  As such, this</font></i>
<a name='L701'><i><font color='green'>   function can only be used for raw deflate, and must be used before the first</font></i>
<a name='L702'><i><font color='green'>   deflate() call after a deflateInit2() or deflateReset().  bits must be less</font></i>
<a name='L703'><i><font color='green'>   than or equal to 16, and that many of the least significant bits of value</font></i>
<a name='L704'><i><font color='green'>   will be inserted in the output.</font></i>
<a name='L705'><i><font color='green'></font></i>
<a name='L706'><i><font color='green'>     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L707'><i><font color='green'>   stream state was inconsistent.</font></i>
<a name='L708'><i><font color='green'>*/</font></i>
<a name='L709'>
<a name='L710'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8016.html' title='Multiple defined in 2 places.'>deflateSetHeader</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L711'>                                         gz_headerp head));
<a name='L712'><i><font color='green'>/*</font></i>
<a name='L713'><i><font color='green'>     deflateSetHeader() provides gzip header information for when a gzip</font></i>
<a name='L714'><i><font color='green'>   stream is requested by deflateInit2().  deflateSetHeader() may be called</font></i>
<a name='L715'><i><font color='green'>   after deflateInit2() or deflateReset() and before the first call of</font></i>
<a name='L716'><i><font color='green'>   deflate().  The text, time, os, extra field, name, and comment information</font></i>
<a name='L717'><i><font color='green'>   in the provided gz_header structure are written to the gzip header (xflag is</font></i>
<a name='L718'><i><font color='green'>   ignored -- the extra flags are set according to the compression level).  The</font></i>
<a name='L719'><i><font color='green'>   caller must assure that, if not Z_NULL, name and comment are terminated with</font></i>
<a name='L720'><i><font color='green'>   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are</font></i>
<a name='L721'><i><font color='green'>   available there.  If hcrc is true, a gzip header crc is included.  Note that</font></i>
<a name='L722'><i><font color='green'>   the current versions of the command-line version of gzip (up through version</font></i>
<a name='L723'><i><font color='green'>   1.3.x) do not support header crc's, and will report that it is a "multi-part</font></i>
<a name='L724'><i><font color='green'>   gzip file" and give up.</font></i>
<a name='L725'><i><font color='green'></font></i>
<a name='L726'><i><font color='green'>     If deflateSetHeader is not used, the default gzip header has text false,</font></i>
<a name='L727'><i><font color='green'>   the time set to zero, and os set to 255, with no extra, name, or comment</font></i>
<a name='L728'><i><font color='green'>   fields.  The gzip header is returned to the default state by deflateReset().</font></i>
<a name='L729'><i><font color='green'></font></i>
<a name='L730'><i><font color='green'>     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L731'><i><font color='green'>   stream state was inconsistent.</font></i>
<a name='L732'><i><font color='green'>*/</font></i>
<a name='L733'>
<a name='L734'><i><font color='green'>/*</font></i>
<a name='L735'><i><font color='green'>ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,</font></i>
<a name='L736'><i><font color='green'>                                     int  windowBits));</font></i>
<a name='L737'><i><font color='green'></font></i>
<a name='L738'><i><font color='green'>     This is another version of inflateInit with an extra parameter.  The</font></i>
<a name='L739'><i><font color='green'>   fields next_in, avail_in, zalloc, zfree and opaque must be initialized</font></i>
<a name='L740'><i><font color='green'>   before by the caller.</font></i>
<a name='L741'><i><font color='green'></font></i>
<a name='L742'><i><font color='green'>     The windowBits parameter is the base two logarithm of the maximum window</font></i>
<a name='L743'><i><font color='green'>   size (the size of the history buffer).  It should be in the range 8..15 for</font></i>
<a name='L744'><i><font color='green'>   this version of the library.  The default value is 15 if inflateInit is used</font></i>
<a name='L745'><i><font color='green'>   instead.  windowBits must be greater than or equal to the windowBits value</font></i>
<a name='L746'><i><font color='green'>   provided to deflateInit2() while compressing, or it must be equal to 15 if</font></i>
<a name='L747'><i><font color='green'>   deflateInit2() was not used.  If a compressed stream with a larger window</font></i>
<a name='L748'><i><font color='green'>   size is given as input, inflate() will return with the error code</font></i>
<a name='L749'><i><font color='green'>   Z_DATA_ERROR instead of trying to allocate a larger window.</font></i>
<a name='L750'><i><font color='green'></font></i>
<a name='L751'><i><font color='green'>     windowBits can also be zero to request that inflate use the window size in</font></i>
<a name='L752'><i><font color='green'>   the zlib header of the compressed stream.</font></i>
<a name='L753'><i><font color='green'></font></i>
<a name='L754'><i><font color='green'>     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits</font></i>
<a name='L755'><i><font color='green'>   determines the window size.  inflate() will then process raw deflate data,</font></i>
<a name='L756'><i><font color='green'>   not looking for a zlib or gzip header, not generating a check value, and not</font></i>
<a name='L757'><i><font color='green'>   looking for any check values for comparison at the end of the stream.  This</font></i>
<a name='L758'><i><font color='green'>   is for use with other formats that use the deflate compressed data format</font></i>
<a name='L759'><i><font color='green'>   such as zip.  Those formats provide their own check values.  If a custom</font></i>
<a name='L760'><i><font color='green'>   format is developed using the raw deflate format for compressed data, it is</font></i>
<a name='L761'><i><font color='green'>   recommended that a check value such as an adler32 or a crc32 be applied to</font></i>
<a name='L762'><i><font color='green'>   the uncompressed data as is done in the zlib, gzip, and zip formats.  For</font></i>
<a name='L763'><i><font color='green'>   most applications, the zlib format should be used as is.  Note that comments</font></i>
<a name='L764'><i><font color='green'>   above on the use in deflateInit2() applies to the magnitude of windowBits.</font></i>
<a name='L765'><i><font color='green'></font></i>
<a name='L766'><i><font color='green'>     windowBits can also be greater than 15 for optional gzip decoding.  Add</font></i>
<a name='L767'><i><font color='green'>   32 to windowBits to enable zlib and gzip decoding with automatic header</font></i>
<a name='L768'><i><font color='green'>   detection, or add 16 to decode only the gzip format (the zlib format will</font></i>
<a name='L769'><i><font color='green'>   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is a</font></i>
<a name='L770'><i><font color='green'>   crc32 instead of an adler32.</font></i>
<a name='L771'><i><font color='green'></font></i>
<a name='L772'><i><font color='green'>     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</font></i>
<a name='L773'><i><font color='green'>   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</font></i>
<a name='L774'><i><font color='green'>   version assumed by the caller, or Z_STREAM_ERROR if the parameters are</font></i>
<a name='L775'><i><font color='green'>   invalid, such as a null pointer to the structure.  msg is set to null if</font></i>
<a name='L776'><i><font color='green'>   there is no error message.  inflateInit2 does not perform any decompression</font></i>
<a name='L777'><i><font color='green'>   apart from possibly reading the zlib header if present: actual decompression</font></i>
<a name='L778'><i><font color='green'>   will be done by inflate().  (So next_in and avail_in may be modified, but</font></i>
<a name='L779'><i><font color='green'>   next_out and avail_out are unused and unchanged.) The current implementation</font></i>
<a name='L780'><i><font color='green'>   of inflateInit2() does not process any header information -- that is</font></i>
<a name='L781'><i><font color='green'>   deferred until inflate() is called.</font></i>
<a name='L782'><i><font color='green'>*/</font></i>
<a name='L783'>
<a name='L784'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9172.html' title='Multiple defined in 3 places.'>inflateSetDictionary</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L785'>                                             <b>const</b> Bytef *dictionary,
<a name='L786'>                                             uInt  dictLength));
<a name='L787'><i><font color='green'>/*</font></i>
<a name='L788'><i><font color='green'>     Initializes the decompression dictionary from the given uncompressed byte</font></i>
<a name='L789'><i><font color='green'>   sequence.  This function must be called immediately after a call of inflate,</font></i>
<a name='L790'><i><font color='green'>   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor</font></i>
<a name='L791'><i><font color='green'>   can be determined from the adler32 value returned by that call of inflate.</font></i>
<a name='L792'><i><font color='green'>   The compressor and decompressor must use exactly the same dictionary (see</font></i>
<a name='L793'><i><font color='green'>   deflateSetDictionary).  For raw inflate, this function can be called</font></i>
<a name='L794'><i><font color='green'>   immediately after inflateInit2() or inflateReset() and before any call of</font></i>
<a name='L795'><i><font color='green'>   inflate() to set the dictionary.  The application must insure that the</font></i>
<a name='L796'><i><font color='green'>   dictionary that was used for compression is provided.</font></i>
<a name='L797'><i><font color='green'></font></i>
<a name='L798'><i><font color='green'>     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a</font></i>
<a name='L799'><i><font color='green'>   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is</font></i>
<a name='L800'><i><font color='green'>   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the</font></i>
<a name='L801'><i><font color='green'>   expected one (incorrect adler32 value).  inflateSetDictionary does not</font></i>
<a name='L802'><i><font color='green'>   perform any decompression: this will be done by subsequent calls of</font></i>
<a name='L803'><i><font color='green'>   inflate().</font></i>
<a name='L804'><i><font color='green'>*/</font></i>
<a name='L805'>
<a name='L806'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9173.html' title='Multiple defined in 3 places.'>inflateSync</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L807'><i><font color='green'>/*</font></i>
<a name='L808'><i><font color='green'>     Skips invalid compressed data until a full flush point (see above the</font></i>
<a name='L809'><i><font color='green'>   description of deflate with Z_FULL_FLUSH) can be found, or until all</font></i>
<a name='L810'><i><font color='green'>   available input is skipped.  No output is provided.</font></i>
<a name='L811'><i><font color='green'></font></i>
<a name='L812'><i><font color='green'>     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR</font></i>
<a name='L813'><i><font color='green'>   if no more input was provided, Z_DATA_ERROR if no flush point has been</font></i>
<a name='L814'><i><font color='green'>   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the</font></i>
<a name='L815'><i><font color='green'>   success case, the application may save the current current value of total_in</font></i>
<a name='L816'><i><font color='green'>   which indicates where valid compressed data was found.  In the error case,</font></i>
<a name='L817'><i><font color='green'>   the application may repeatedly call inflateSync, providing more input each</font></i>
<a name='L818'><i><font color='green'>   time, until success or end of the input data.</font></i>
<a name='L819'><i><font color='green'>*/</font></i>
<a name='L820'>
<a name='L821'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9161.html' title='Multiple defined in 3 places.'>inflateCopy</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp dest,
<a name='L822'>                                    z_streamp source));
<a name='L823'><i><font color='green'>/*</font></i>
<a name='L824'><i><font color='green'>     Sets the destination stream as a complete copy of the source stream.</font></i>
<a name='L825'><i><font color='green'></font></i>
<a name='L826'><i><font color='green'>     This function can be useful when randomly accessing a large stream.  The</font></i>
<a name='L827'><i><font color='green'>   first pass through the stream can periodically record the inflate state,</font></i>
<a name='L828'><i><font color='green'>   allowing restarting inflate at those points when randomly accessing the</font></i>
<a name='L829'><i><font color='green'>   stream.</font></i>
<a name='L830'><i><font color='green'></font></i>
<a name='L831'><i><font color='green'>     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</font></i>
<a name='L832'><i><font color='green'>   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</font></i>
<a name='L833'><i><font color='green'>   (such as zalloc being Z_NULL).  msg is left unchanged in both source and</font></i>
<a name='L834'><i><font color='green'>   destination.</font></i>
<a name='L835'><i><font color='green'>*/</font></i>
<a name='L836'>
<a name='L837'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9170.html' title='Multiple defined in 3 places.'>inflateReset</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L838'><i><font color='green'>/*</font></i>
<a name='L839'><i><font color='green'>     This function is equivalent to inflateEnd followed by inflateInit,</font></i>
<a name='L840'><i><font color='green'>   but does not free and reallocate all the internal decompression state.  The</font></i>
<a name='L841'><i><font color='green'>   stream will keep attributes that may have been set by inflateInit2.</font></i>
<a name='L842'><i><font color='green'></font></i>
<a name='L843'><i><font color='green'>     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L844'><i><font color='green'>   stream state was inconsistent (such as zalloc or state being Z_NULL).</font></i>
<a name='L845'><i><font color='green'>*/</font></i>
<a name='L846'>
<a name='L847'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9171.html' title='Multiple defined in 2 places.'>inflateReset2</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L848'>                                      <b>int</b> windowBits));
<a name='L849'><i><font color='green'>/*</font></i>
<a name='L850'><i><font color='green'>     This function is the same as inflateReset, but it also permits changing</font></i>
<a name='L851'><i><font color='green'>   the wrap and window size requests.  The windowBits parameter is interpreted</font></i>
<a name='L852'><i><font color='green'>   the same as it is for inflateInit2.</font></i>
<a name='L853'><i><font color='green'></font></i>
<a name='L854'><i><font color='green'>     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L855'><i><font color='green'>   stream state was inconsistent (such as zalloc or state being Z_NULL), or if</font></i>
<a name='L856'><i><font color='green'>   the windowBits parameter is invalid.</font></i>
<a name='L857'><i><font color='green'>*/</font></i>
<a name='L858'>
<a name='L859'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9169.html' title='Multiple defined in 2 places.'>inflatePrime</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L860'>                                     <b>int</b> bits,
<a name='L861'>                                     <b>int</b> value));
<a name='L862'><i><font color='green'>/*</font></i>
<a name='L863'><i><font color='green'>     This function inserts bits in the inflate input stream.  The intent is</font></i>
<a name='L864'><i><font color='green'>   that this function is used to start inflating at a bit position in the</font></i>
<a name='L865'><i><font color='green'>   middle of a byte.  The provided bits will be used before any bytes are used</font></i>
<a name='L866'><i><font color='green'>   from next_in.  This function should only be used with raw inflate, and</font></i>
<a name='L867'><i><font color='green'>   should be used before the first inflate() call after inflateInit2() or</font></i>
<a name='L868'><i><font color='green'>   inflateReset().  bits must be less than or equal to 16, and that many of the</font></i>
<a name='L869'><i><font color='green'>   least significant bits of value will be inserted in the input.</font></i>
<a name='L870'><i><font color='green'></font></i>
<a name='L871'><i><font color='green'>     If bits is negative, then the input stream bit buffer is emptied.  Then</font></i>
<a name='L872'><i><font color='green'>   inflatePrime() can be called again to put bits in the buffer.  This is used</font></i>
<a name='L873'><i><font color='green'>   to clear out bits leftover after feeding inflate a block description prior</font></i>
<a name='L874'><i><font color='green'>   to feeding inflate codes.</font></i>
<a name='L875'><i><font color='green'></font></i>
<a name='L876'><i><font color='green'>     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L877'><i><font color='green'>   stream state was inconsistent.</font></i>
<a name='L878'><i><font color='green'>*/</font></i>
<a name='L879'>
<a name='L880'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>long</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9168.html' title='Multiple defined in 2 places.'>inflateMark</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L881'><i><font color='green'>/*</font></i>
<a name='L882'><i><font color='green'>     This function returns two values, one in the lower 16 bits of the return</font></i>
<a name='L883'><i><font color='green'>   value, and the other in the remaining upper bits, obtained by shifting the</font></i>
<a name='L884'><i><font color='green'>   return value down 16 bits.  If the upper value is -1 and the lower value is</font></i>
<a name='L885'><i><font color='green'>   zero, then inflate() is currently decoding information outside of a block.</font></i>
<a name='L886'><i><font color='green'>   If the upper value is -1 and the lower value is non-zero, then inflate is in</font></i>
<a name='L887'><i><font color='green'>   the middle of a stored block, with the lower value equaling the number of</font></i>
<a name='L888'><i><font color='green'>   bytes from the input remaining to copy.  If the upper value is not -1, then</font></i>
<a name='L889'><i><font color='green'>   it is the number of bits back from the current bit position in the input of</font></i>
<a name='L890'><i><font color='green'>   the code (literal or length/distance pair) currently being processed.  In</font></i>
<a name='L891'><i><font color='green'>   that case the lower value is the number of bytes already emitted for that</font></i>
<a name='L892'><i><font color='green'>   code.</font></i>
<a name='L893'><i><font color='green'></font></i>
<a name='L894'><i><font color='green'>     A code is being processed if inflate is waiting for more input to complete</font></i>
<a name='L895'><i><font color='green'>   decoding of the code, or if it has completed decoding but is waiting for</font></i>
<a name='L896'><i><font color='green'>   more output space to write the literal or match data.</font></i>
<a name='L897'><i><font color='green'></font></i>
<a name='L898'><i><font color='green'>     inflateMark() is used to mark locations in the input data for random</font></i>
<a name='L899'><i><font color='green'>   access, which may be at bit positions, and to note those cases where the</font></i>
<a name='L900'><i><font color='green'>   output of a code may span boundaries of random access blocks.  The current</font></i>
<a name='L901'><i><font color='green'>   location in the input stream can be determined from avail_in and data_type</font></i>
<a name='L902'><i><font color='green'>   as noted in the description for the Z_BLOCK flush parameter for inflate.</font></i>
<a name='L903'><i><font color='green'></font></i>
<a name='L904'><i><font color='green'>     inflateMark returns the value noted above or -1 &lt;&lt; 16 if the provided</font></i>
<a name='L905'><i><font color='green'>   source stream state was inconsistent.</font></i>
<a name='L906'><i><font color='green'>*/</font></i>
<a name='L907'>
<a name='L908'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9163.html' title='Multiple defined in 2 places.'>inflateGetHeader</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L909'>                                         gz_headerp head));
<a name='L910'><i><font color='green'>/*</font></i>
<a name='L911'><i><font color='green'>     inflateGetHeader() requests that gzip header information be stored in the</font></i>
<a name='L912'><i><font color='green'>   provided gz_header structure.  inflateGetHeader() may be called after</font></i>
<a name='L913'><i><font color='green'>   inflateInit2() or inflateReset(), and before the first call of inflate().</font></i>
<a name='L914'><i><font color='green'>   As inflate() processes the gzip stream, head-&gt;done is zero until the header</font></i>
<a name='L915'><i><font color='green'>   is completed, at which time head-&gt;done is set to one.  If a zlib stream is</font></i>
<a name='L916'><i><font color='green'>   being decoded, then head-&gt;done is set to -1 to indicate that there will be</font></i>
<a name='L917'><i><font color='green'>   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be</font></i>
<a name='L918'><i><font color='green'>   used to force inflate() to return immediately after header processing is</font></i>
<a name='L919'><i><font color='green'>   complete and before any actual data is decompressed.</font></i>
<a name='L920'><i><font color='green'></font></i>
<a name='L921'><i><font color='green'>     The text, time, xflags, and os fields are filled in with the gzip header</font></i>
<a name='L922'><i><font color='green'>   contents.  hcrc is set to true if there is a header CRC.  (The header CRC</font></i>
<a name='L923'><i><font color='green'>   was valid if done is set to one.) If extra is not Z_NULL, then extra_max</font></i>
<a name='L924'><i><font color='green'>   contains the maximum number of bytes to write to extra.  Once done is true,</font></i>
<a name='L925'><i><font color='green'>   extra_len contains the actual extra field length, and extra contains the</font></i>
<a name='L926'><i><font color='green'>   extra field, or that field truncated if extra_max is less than extra_len.</font></i>
<a name='L927'><i><font color='green'>   If name is not Z_NULL, then up to name_max characters are written there,</font></i>
<a name='L928'><i><font color='green'>   terminated with a zero unless the length is greater than name_max.  If</font></i>
<a name='L929'><i><font color='green'>   comment is not Z_NULL, then up to comm_max characters are written there,</font></i>
<a name='L930'><i><font color='green'>   terminated with a zero unless the length is greater than comm_max.  When any</font></i>
<a name='L931'><i><font color='green'>   of extra, name, or comment are not Z_NULL and the respective field is not</font></i>
<a name='L932'><i><font color='green'>   present in the header, then that field is set to Z_NULL to signal its</font></i>
<a name='L933'><i><font color='green'>   absence.  This allows the use of deflateSetHeader() with the returned</font></i>
<a name='L934'><i><font color='green'>   structure to duplicate the header.  However if those fields are set to</font></i>
<a name='L935'><i><font color='green'>   allocated memory, then the application will need to save those pointers</font></i>
<a name='L936'><i><font color='green'>   elsewhere so that they can be eventually freed.</font></i>
<a name='L937'><i><font color='green'></font></i>
<a name='L938'><i><font color='green'>     If inflateGetHeader is not used, then the header information is simply</font></i>
<a name='L939'><i><font color='green'>   discarded.  The header is always checked for validity, including the header</font></i>
<a name='L940'><i><font color='green'>   CRC if present.  inflateReset() will reset the process to discard the header</font></i>
<a name='L941'><i><font color='green'>   information.  The application would need to call inflateGetHeader() again to</font></i>
<a name='L942'><i><font color='green'>   retrieve the header from the next gzip stream.</font></i>
<a name='L943'><i><font color='green'></font></i>
<a name='L944'><i><font color='green'>     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source</font></i>
<a name='L945'><i><font color='green'>   stream state was inconsistent.</font></i>
<a name='L946'><i><font color='green'>*/</font></i>
<a name='L947'>
<a name='L948'><i><font color='green'>/*</font></i>
<a name='L949'><i><font color='green'>ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,</font></i>
<a name='L950'><i><font color='green'>                                        unsigned char FAR *window));</font></i>
<a name='L951'><i><font color='green'></font></i>
<a name='L952'><i><font color='green'>     Initialize the internal stream state for decompression using inflateBack()</font></i>
<a name='L953'><i><font color='green'>   calls.  The fields zalloc, zfree and opaque in strm must be initialized</font></i>
<a name='L954'><i><font color='green'>   before the call.  If zalloc and zfree are Z_NULL, then the default library-</font></i>
<a name='L955'><i><font color='green'>   derived memory allocation routines are used.  windowBits is the base two</font></i>
<a name='L956'><i><font color='green'>   logarithm of the window size, in the range 8..15.  window is a caller</font></i>
<a name='L957'><i><font color='green'>   supplied buffer of that size.  Except for special applications where it is</font></i>
<a name='L958'><i><font color='green'>   assured that deflate was used with small window sizes, windowBits must be 15</font></i>
<a name='L959'><i><font color='green'>   and a 32K byte window must be supplied to be able to decompress general</font></i>
<a name='L960'><i><font color='green'>   deflate streams.</font></i>
<a name='L961'><i><font color='green'></font></i>
<a name='L962'><i><font color='green'>     See inflateBack() for the usage of these routines.</font></i>
<a name='L963'><i><font color='green'></font></i>
<a name='L964'><i><font color='green'>     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of</font></i>
<a name='L965'><i><font color='green'>   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be</font></i>
<a name='L966'><i><font color='green'>   allocated, or Z_VERSION_ERROR if the version of the library does not match</font></i>
<a name='L967'><i><font color='green'>   the version of the header file.</font></i>
<a name='L968'><i><font color='green'>*/</font></i>
<a name='L969'>
<a name='L970'><b>typedef</b> <b>unsigned</b> (*in_func) <a href='../R/2174.html' title='Multiple refered from 189 places.'>OF</a>((<b>void</b> FAR *, <b>unsigned</b> <b>char</b> FAR * FAR *));
<a name='L971'><b>typedef</b> <b>int</b> (*out_func) <a href='../R/2174.html' title='Multiple refered from 189 places.'>OF</a>((<b>void</b> FAR *, <b>unsigned</b> <b>char</b> FAR *, <b>unsigned</b>));
<a name='L972'>
<a name='L973'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9157.html' title='Multiple defined in 3 places.'>inflateBack</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L974'>                                    in_func in, <b>void</b> <a href='../D/1088.html' title='Multiple defined in 13 places.'>FAR</a> *in_desc,
<a name='L975'>                                    out_func out, <b>void</b> <a href='../D/1088.html' title='Multiple defined in 13 places.'>FAR</a> *out_desc));
<a name='L976'><i><font color='green'>/*</font></i>
<a name='L977'><i><font color='green'>     inflateBack() does a raw inflate with a single call using a call-back</font></i>
<a name='L978'><i><font color='green'>   interface for input and output.  This is more efficient than inflate() for</font></i>
<a name='L979'><i><font color='green'>   file i/o applications in that it avoids copying between the output and the</font></i>
<a name='L980'><i><font color='green'>   sliding window by simply making the window itself the output buffer.  This</font></i>
<a name='L981'><i><font color='green'>   function trusts the application to not change the output buffer passed by</font></i>
<a name='L982'><i><font color='green'>   the output function, at least until inflateBack() returns.</font></i>
<a name='L983'><i><font color='green'></font></i>
<a name='L984'><i><font color='green'>     inflateBackInit() must be called first to allocate the internal state</font></i>
<a name='L985'><i><font color='green'>   and to initialize the state with the user-provided window buffer.</font></i>
<a name='L986'><i><font color='green'>   inflateBack() may then be used multiple times to inflate a complete, raw</font></i>
<a name='L987'><i><font color='green'>   deflate stream with each call.  inflateBackEnd() is then called to free the</font></i>
<a name='L988'><i><font color='green'>   allocated state.</font></i>
<a name='L989'><i><font color='green'></font></i>
<a name='L990'><i><font color='green'>     A raw deflate stream is one with no zlib or gzip header or trailer.</font></i>
<a name='L991'><i><font color='green'>   This routine would normally be used in a utility that reads zip or gzip</font></i>
<a name='L992'><i><font color='green'>   files and writes out uncompressed files.  The utility would decode the</font></i>
<a name='L993'><i><font color='green'>   header and process the trailer on its own, hence this routine expects only</font></i>
<a name='L994'><i><font color='green'>   the raw deflate stream to decompress.  This is different from the normal</font></i>
<a name='L995'><i><font color='green'>   behavior of inflate(), which expects either a zlib or gzip header and</font></i>
<a name='L996'><i><font color='green'>   trailer around the deflate stream.</font></i>
<a name='L997'><i><font color='green'></font></i>
<a name='L998'><i><font color='green'>     inflateBack() uses two subroutines supplied by the caller that are then</font></i>
<a name='L999'><i><font color='green'>   called by inflateBack() for input and output.  inflateBack() calls those</font></i>
<a name='L1000'><i><font color='green'>   routines until it reads a complete deflate stream and writes out all of the</font></i>
<a name='L1001'><i><font color='green'>   uncompressed data, or until it encounters an error.  The function's</font></i>
<a name='L1002'><i><font color='green'>   parameters and return types are defined above in the in_func and out_func</font></i>
<a name='L1003'><i><font color='green'>   typedefs.  inflateBack() will call in(in_desc, &amp;buf) which should return the</font></i>
<a name='L1004'><i><font color='green'>   number of bytes of provided input, and a pointer to that input in buf.  If</font></i>
<a name='L1005'><i><font color='green'>   there is no input available, in() must return zero--buf is ignored in that</font></i>
<a name='L1006'><i><font color='green'>   case--and inflateBack() will return a buffer error.  inflateBack() will call</font></i>
<a name='L1007'><i><font color='green'>   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()</font></i>
<a name='L1008'><i><font color='green'>   should return zero on success, or non-zero on failure.  If out() returns</font></i>
<a name='L1009'><i><font color='green'>   non-zero, inflateBack() will return with an error.  Neither in() nor out()</font></i>
<a name='L1010'><i><font color='green'>   are permitted to change the contents of the window provided to</font></i>
<a name='L1011'><i><font color='green'>   inflateBackInit(), which is also the buffer that out() uses to write from.</font></i>
<a name='L1012'><i><font color='green'>   The length written by out() will be at most the window size.  Any non-zero</font></i>
<a name='L1013'><i><font color='green'>   amount of input may be provided by in().</font></i>
<a name='L1014'><i><font color='green'></font></i>
<a name='L1015'><i><font color='green'>     For convenience, inflateBack() can be provided input on the first call by</font></i>
<a name='L1016'><i><font color='green'>   setting strm-&gt;next_in and strm-&gt;avail_in.  If that input is exhausted, then</font></i>
<a name='L1017'><i><font color='green'>   in() will be called.  Therefore strm-&gt;next_in must be initialized before</font></i>
<a name='L1018'><i><font color='green'>   calling inflateBack().  If strm-&gt;next_in is Z_NULL, then in() will be called</font></i>
<a name='L1019'><i><font color='green'>   immediately for input.  If strm-&gt;next_in is not Z_NULL, then strm-&gt;avail_in</font></i>
<a name='L1020'><i><font color='green'>   must also be initialized, and then if strm-&gt;avail_in is not zero, input will</font></i>
<a name='L1021'><i><font color='green'>   initially be taken from strm-&gt;next_in[0 ..  strm-&gt;avail_in - 1].</font></i>
<a name='L1022'><i><font color='green'></font></i>
<a name='L1023'><i><font color='green'>     The in_desc and out_desc parameters of inflateBack() is passed as the</font></i>
<a name='L1024'><i><font color='green'>   first parameter of in() and out() respectively when they are called.  These</font></i>
<a name='L1025'><i><font color='green'>   descriptors can be optionally used to pass any information that the caller-</font></i>
<a name='L1026'><i><font color='green'>   supplied in() and out() functions need to do their job.</font></i>
<a name='L1027'><i><font color='green'></font></i>
<a name='L1028'><i><font color='green'>     On return, inflateBack() will set strm-&gt;next_in and strm-&gt;avail_in to</font></i>
<a name='L1029'><i><font color='green'>   pass back any unused input that was provided by the last in() call.  The</font></i>
<a name='L1030'><i><font color='green'>   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR</font></i>
<a name='L1031'><i><font color='green'>   if in() or out() returned an error, Z_DATA_ERROR if there was a format error</font></i>
<a name='L1032'><i><font color='green'>   in the deflate stream (in which case strm-&gt;msg is set to indicate the nature</font></i>
<a name='L1033'><i><font color='green'>   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.</font></i>
<a name='L1034'><i><font color='green'>   In the case of Z_BUF_ERROR, an input or output error can be distinguished</font></i>
<a name='L1035'><i><font color='green'>   using strm-&gt;next_in which will be Z_NULL only if in() returned an error.  If</font></i>
<a name='L1036'><i><font color='green'>   strm-&gt;next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning</font></i>
<a name='L1037'><i><font color='green'>   non-zero.  (in() will always be called before out(), so strm-&gt;next_in is</font></i>
<a name='L1038'><i><font color='green'>   assured to be defined if out() returns non-zero.) Note that inflateBack()</font></i>
<a name='L1039'><i><font color='green'>   cannot return Z_OK.</font></i>
<a name='L1040'><i><font color='green'>*/</font></i>
<a name='L1041'>
<a name='L1042'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9158.html' title='Multiple defined in 3 places.'>inflateBackEnd</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm));
<a name='L1043'><i><font color='green'>/*</font></i>
<a name='L1044'><i><font color='green'>     All memory allocated by inflateBackInit() is freed.</font></i>
<a name='L1045'><i><font color='green'></font></i>
<a name='L1046'><i><font color='green'>     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream</font></i>
<a name='L1047'><i><font color='green'>   state was inconsistent.</font></i>
<a name='L1048'><i><font color='green'>*/</font></i>
<a name='L1049'>
<a name='L1050'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/12467.html' title='Multiple defined in 2 places.'>zlibCompileFlags</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>void</b>));
<a name='L1051'><i><font color='green'>/* Return flags indicating compile-time options.</font></i>
<a name='L1052'><i><font color='green'></font></i>
<a name='L1053'><i><font color='green'>    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:</font></i>
<a name='L1054'><i><font color='green'>     1.0: size of uInt</font></i>
<a name='L1055'><i><font color='green'>     3.2: size of uLong</font></i>
<a name='L1056'><i><font color='green'>     5.4: size of voidpf (pointer)</font></i>
<a name='L1057'><i><font color='green'>     7.6: size of z_off_t</font></i>
<a name='L1058'><i><font color='green'></font></i>
<a name='L1059'><i><font color='green'>    Compiler, assembler, and debug options:</font></i>
<a name='L1060'><i><font color='green'>     8: DEBUG</font></i>
<a name='L1061'><i><font color='green'>     9: ASMV or ASMINF -- use ASM code</font></i>
<a name='L1062'><i><font color='green'>     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention</font></i>
<a name='L1063'><i><font color='green'>     11: 0 (reserved)</font></i>
<a name='L1064'><i><font color='green'></font></i>
<a name='L1065'><i><font color='green'>    One-time table building (smaller code, but not thread-safe if true):</font></i>
<a name='L1066'><i><font color='green'>     12: BUILDFIXED -- build static block decoding tables when needed</font></i>
<a name='L1067'><i><font color='green'>     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed</font></i>
<a name='L1068'><i><font color='green'>     14,15: 0 (reserved)</font></i>
<a name='L1069'><i><font color='green'></font></i>
<a name='L1070'><i><font color='green'>    Library content (indicates missing functionality):</font></i>
<a name='L1071'><i><font color='green'>     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking</font></i>
<a name='L1072'><i><font color='green'>                          deflate code when not needed)</font></i>
<a name='L1073'><i><font color='green'>     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect</font></i>
<a name='L1074'><i><font color='green'>                    and decode gzip streams (to avoid linking crc code)</font></i>
<a name='L1075'><i><font color='green'>     18-19: 0 (reserved)</font></i>
<a name='L1076'><i><font color='green'></font></i>
<a name='L1077'><i><font color='green'>    Operation variations (changes in library functionality):</font></i>
<a name='L1078'><i><font color='green'>     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate</font></i>
<a name='L1079'><i><font color='green'>     21: FASTEST -- deflate algorithm with only one, lowest compression level</font></i>
<a name='L1080'><i><font color='green'>     22,23: 0 (reserved)</font></i>
<a name='L1081'><i><font color='green'></font></i>
<a name='L1082'><i><font color='green'>    The sprintf variant used by gzprintf (zero is best):</font></i>
<a name='L1083'><i><font color='green'>     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format</font></i>
<a name='L1084'><i><font color='green'>     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!</font></i>
<a name='L1085'><i><font color='green'>     26: 0 = returns value, 1 = void -- 1 means inferred string length returned</font></i>
<a name='L1086'><i><font color='green'></font></i>
<a name='L1087'><i><font color='green'>    Remainder:</font></i>
<a name='L1088'><i><font color='green'>     27-31: 0 (reserved)</font></i>
<a name='L1089'><i><font color='green'> */</font></i>
<a name='L1090'>
<a name='L1091'>
<a name='L1092'>                        <i><font color='green'>/* utility functions */</font></i>
<a name='L1093'>
<a name='L1094'><i><font color='green'>/*</font></i>
<a name='L1095'><i><font color='green'>     The following utility functions are implemented on top of the basic</font></i>
<a name='L1096'><i><font color='green'>   stream-oriented functions.  To simplify the interface, some default options</font></i>
<a name='L1097'><i><font color='green'>   are assumed (compression level and memory usage, standard memory allocation</font></i>
<a name='L1098'><i><font color='green'>   functions).  The source code of these utility functions can be modified if</font></i>
<a name='L1099'><i><font color='green'>   you need special options.</font></i>
<a name='L1100'><i><font color='green'>*/</font></i>
<a name='L1101'>
<a name='L1102'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7719.html' title='Multiple defined in 3 places.'>compress</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((Bytef *dest,   uLongf *destLen,
<a name='L1103'>                                 <b>const</b> Bytef *source, uLong sourceLen));
<a name='L1104'><i><font color='green'>/*</font></i>
<a name='L1105'><i><font color='green'>     Compresses the source buffer into the destination buffer.  sourceLen is</font></i>
<a name='L1106'><i><font color='green'>   the byte length of the source buffer.  Upon entry, destLen is the total size</font></i>
<a name='L1107'><i><font color='green'>   of the destination buffer, which must be at least the value returned by</font></i>
<a name='L1108'><i><font color='green'>   compressBound(sourceLen).  Upon exit, destLen is the actual size of the</font></i>
<a name='L1109'><i><font color='green'>   compressed buffer.</font></i>
<a name='L1110'><i><font color='green'></font></i>
<a name='L1111'><i><font color='green'>     compress returns Z_OK if success, Z_MEM_ERROR if there was not</font></i>
<a name='L1112'><i><font color='green'>   enough memory, Z_BUF_ERROR if there was not enough room in the output</font></i>
<a name='L1113'><i><font color='green'>   buffer.</font></i>
<a name='L1114'><i><font color='green'>*/</font></i>
<a name='L1115'>
<a name='L1116'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7720.html' title='Multiple defined in 3 places.'>compress2</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((Bytef *dest,   uLongf *destLen,
<a name='L1117'>                                  <b>const</b> Bytef *source, uLong sourceLen,
<a name='L1118'>                                  <b>int</b> level));
<a name='L1119'><i><font color='green'>/*</font></i>
<a name='L1120'><i><font color='green'>     Compresses the source buffer into the destination buffer.  The level</font></i>
<a name='L1121'><i><font color='green'>   parameter has the same meaning as in deflateInit.  sourceLen is the byte</font></i>
<a name='L1122'><i><font color='green'>   length of the source buffer.  Upon entry, destLen is the total size of the</font></i>
<a name='L1123'><i><font color='green'>   destination buffer, which must be at least the value returned by</font></i>
<a name='L1124'><i><font color='green'>   compressBound(sourceLen).  Upon exit, destLen is the actual size of the</font></i>
<a name='L1125'><i><font color='green'>   compressed buffer.</font></i>
<a name='L1126'><i><font color='green'></font></i>
<a name='L1127'><i><font color='green'>     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</font></i>
<a name='L1128'><i><font color='green'>   memory, Z_BUF_ERROR if there was not enough room in the output buffer,</font></i>
<a name='L1129'><i><font color='green'>   Z_STREAM_ERROR if the level parameter is invalid.</font></i>
<a name='L1130'><i><font color='green'>*/</font></i>
<a name='L1131'>
<a name='L1132'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7721.html' title='Multiple defined in 3 places.'>compressBound</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong sourceLen));
<a name='L1133'><i><font color='green'>/*</font></i>
<a name='L1134'><i><font color='green'>     compressBound() returns an upper bound on the compressed size after</font></i>
<a name='L1135'><i><font color='green'>   compress() or compress2() on sourceLen bytes.  It would be used before a</font></i>
<a name='L1136'><i><font color='green'>   compress() or compress2() call to allocate the destination buffer.</font></i>
<a name='L1137'><i><font color='green'>*/</font></i>
<a name='L1138'>
<a name='L1139'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/11944.html' title='Multiple defined in 3 places.'>uncompress</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((Bytef *dest,   uLongf *destLen,
<a name='L1140'>                                   <b>const</b> Bytef *source, uLong sourceLen));
<a name='L1141'><i><font color='green'>/*</font></i>
<a name='L1142'><i><font color='green'>     Decompresses the source buffer into the destination buffer.  sourceLen is</font></i>
<a name='L1143'><i><font color='green'>   the byte length of the source buffer.  Upon entry, destLen is the total size</font></i>
<a name='L1144'><i><font color='green'>   of the destination buffer, which must be large enough to hold the entire</font></i>
<a name='L1145'><i><font color='green'>   uncompressed data.  (The size of the uncompressed data must have been saved</font></i>
<a name='L1146'><i><font color='green'>   previously by the compressor and transmitted to the decompressor by some</font></i>
<a name='L1147'><i><font color='green'>   mechanism outside the scope of this compression library.) Upon exit, destLen</font></i>
<a name='L1148'><i><font color='green'>   is the actual size of the uncompressed buffer.</font></i>
<a name='L1149'><i><font color='green'></font></i>
<a name='L1150'><i><font color='green'>     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not</font></i>
<a name='L1151'><i><font color='green'>   enough memory, Z_BUF_ERROR if there was not enough room in the output</font></i>
<a name='L1152'><i><font color='green'>   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.</font></i>
<a name='L1153'><i><font color='green'>*/</font></i>
<a name='L1154'>
<a name='L1155'>
<a name='L1156'>                        <i><font color='green'>/* gzip file access functions */</font></i>
<a name='L1157'>
<a name='L1158'><i><font color='green'>/*</font></i>
<a name='L1159'><i><font color='green'>     This library supports reading and writing files in gzip (.gz) format with</font></i>
<a name='L1160'><i><font color='green'>   an interface similar to that of stdio, using the functions that start with</font></i>
<a name='L1161'><i><font color='green'>   "gz".  The gzip format is different from the zlib format.  gzip is a gzip</font></i>
<a name='L1162'><i><font color='green'>   wrapper, documented in RFC 1952, wrapped around a deflate stream.</font></i>
<a name='L1163'><i><font color='green'>*/</font></i>
<a name='L1164'>
<a name='L1165'><b>typedef</b> <a href='../D/12265.html' title='Multiple defined in 6 places.'>voidp</a> <a href='../R/8191.html' title='Multiple refered from 27 places.'>gzFile</a>;       <i><font color='green'>/* opaque gzip file descriptor */</font></i>
<a name='L1166'>
<a name='L1167'><i><font color='green'>/*</font></i>
<a name='L1168'><i><font color='green'>ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));</font></i>
<a name='L1169'><i><font color='green'></font></i>
<a name='L1170'><i><font color='green'>     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as</font></i>
<a name='L1171'><i><font color='green'>   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or</font></i>
<a name='L1172'><i><font color='green'>   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only</font></i>
<a name='L1173'><i><font color='green'>   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'</font></i>
<a name='L1174'><i><font color='green'>   for fixed code compression as in "wb9F".  (See the description of</font></i>
<a name='L1175'><i><font color='green'>   deflateInit2 for more information about the strategy parameter.) Also "a"</font></i>
<a name='L1176'><i><font color='green'>   can be used instead of "w" to request that the gzip stream that will be</font></i>
<a name='L1177'><i><font color='green'>   written be appended to the file.  "+" will result in an error, since reading</font></i>
<a name='L1178'><i><font color='green'>   and writing to the same gzip file is not supported.</font></i>
<a name='L1179'><i><font color='green'></font></i>
<a name='L1180'><i><font color='green'>     gzopen can be used to read a file which is not in gzip format; in this</font></i>
<a name='L1181'><i><font color='green'>   case gzread will directly read from the file without decompression.</font></i>
<a name='L1182'><i><font color='green'></font></i>
<a name='L1183'><i><font color='green'>     gzopen returns NULL if the file could not be opened, if there was</font></i>
<a name='L1184'><i><font color='green'>   insufficient memory to allocate the gzFile state, or if an invalid mode was</font></i>
<a name='L1185'><i><font color='green'>   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).</font></i>
<a name='L1186'><i><font color='green'>   errno can be checked to determine if the reason gzopen failed was that the</font></i>
<a name='L1187'><i><font color='green'>   file could not be opened.</font></i>
<a name='L1188'><i><font color='green'>*/</font></i>
<a name='L1189'>
<a name='L1190'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/8993.html' title='Multiple defined in 2 places.'>gzFile</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9024.html' title='Multiple defined in 3 places.'>gzdopen</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>int</b> fd, <b>const</b> <b>char</b> *mode));
<a name='L1191'><i><font color='green'>/*</font></i>
<a name='L1192'><i><font color='green'>     gzdopen associates a gzFile with the file descriptor fd.  File descriptors</font></i>
<a name='L1193'><i><font color='green'>   are obtained from calls like open, dup, creat, pipe or fileno (if the file</font></i>
<a name='L1194'><i><font color='green'>   has been previously opened with fopen).  The mode parameter is as in gzopen.</font></i>
<a name='L1195'><i><font color='green'></font></i>
<a name='L1196'><i><font color='green'>     The next call of gzclose on the returned gzFile will also close the file</font></i>
<a name='L1197'><i><font color='green'>   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor</font></i>
<a name='L1198'><i><font color='green'>   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,</font></i>
<a name='L1199'><i><font color='green'>   mode);.  The duplicated descriptor should be saved to avoid a leak, since</font></i>
<a name='L1200'><i><font color='green'>   gzdopen does not close fd if it fails.</font></i>
<a name='L1201'><i><font color='green'></font></i>
<a name='L1202'><i><font color='green'>     gzdopen returns NULL if there was insufficient memory to allocate the</font></i>
<a name='L1203'><i><font color='green'>   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not</font></i>
<a name='L1204'><i><font color='green'>   provided, or '+' was provided), or if fd is -1.  The file descriptor is not</font></i>
<a name='L1205'><i><font color='green'>   used until the next gz* read, write, seek, or close operation, so gzdopen</font></i>
<a name='L1206'><i><font color='green'>   will not detect if fd is invalid (unless fd is -1).</font></i>
<a name='L1207'><i><font color='green'>*/</font></i>
<a name='L1208'>
<a name='L1209'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9018.html' title='Multiple defined in 2 places.'>gzbuffer</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>unsigned</b> size));
<a name='L1210'><i><font color='green'>/*</font></i>
<a name='L1211'><i><font color='green'>     Set the internal buffer size used by this library's functions.  The</font></i>
<a name='L1212'><i><font color='green'>   default buffer size is 8192 bytes.  This function must be called after</font></i>
<a name='L1213'><i><font color='green'>   gzopen() or gzdopen(), and before any other calls that read or write the</font></i>
<a name='L1214'><i><font color='green'>   file.  The buffer memory allocation is always deferred to the first read or</font></i>
<a name='L1215'><i><font color='green'>   write.  Two buffers are allocated, either both of the specified size when</font></i>
<a name='L1216'><i><font color='green'>   writing, or one of the specified size and the other twice that size when</font></i>
<a name='L1217'><i><font color='green'>   reading.  A larger buffer size of, for example, 64K or 128K bytes will</font></i>
<a name='L1218'><i><font color='green'>   noticeably increase the speed of decompression (reading).</font></i>
<a name='L1219'><i><font color='green'></font></i>
<a name='L1220'><i><font color='green'>     The new buffer size also affects the maximum length for gzprintf().</font></i>
<a name='L1221'><i><font color='green'></font></i>
<a name='L1222'><i><font color='green'>     gzbuffer() returns 0 on success, or -1 on failure, such as being called</font></i>
<a name='L1223'><i><font color='green'>   too late.</font></i>
<a name='L1224'><i><font color='green'>*/</font></i>
<a name='L1225'>
<a name='L1226'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9041.html' title='Multiple defined in 3 places.'>gzsetparams</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>int</b> level, <b>int</b> strategy));
<a name='L1227'><i><font color='green'>/*</font></i>
<a name='L1228'><i><font color='green'>     Dynamically update the compression level or strategy.  See the description</font></i>
<a name='L1229'><i><font color='green'>   of deflateInit2 for the meaning of these parameters.</font></i>
<a name='L1230'><i><font color='green'></font></i>
<a name='L1231'><i><font color='green'>     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not</font></i>
<a name='L1232'><i><font color='green'>   opened for writing.</font></i>
<a name='L1233'><i><font color='green'>*/</font></i>
<a name='L1234'>
<a name='L1235'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9037.html' title='Multiple defined in 3 places.'>gzread</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, voidp buf, <b>unsigned</b> len));
<a name='L1236'><i><font color='green'>/*</font></i>
<a name='L1237'><i><font color='green'>     Reads the given number of uncompressed bytes from the compressed file.  If</font></i>
<a name='L1238'><i><font color='green'>   the input file was not in gzip format, gzread copies the given number of</font></i>
<a name='L1239'><i><font color='green'>   bytes into the buffer.</font></i>
<a name='L1240'><i><font color='green'></font></i>
<a name='L1241'><i><font color='green'>     After reaching the end of a gzip stream in the input, gzread will continue</font></i>
<a name='L1242'><i><font color='green'>   to read, looking for another gzip stream, or failing that, reading the rest</font></i>
<a name='L1243'><i><font color='green'>   of the input file directly without decompression.  The entire input file</font></i>
<a name='L1244'><i><font color='green'>   will be read if gzread is called until it returns less than the requested</font></i>
<a name='L1245'><i><font color='green'>   len.</font></i>
<a name='L1246'><i><font color='green'></font></i>
<a name='L1247'><i><font color='green'>     gzread returns the number of uncompressed bytes actually read, less than</font></i>
<a name='L1248'><i><font color='green'>   len for end of file, or -1 for error.</font></i>
<a name='L1249'><i><font color='green'>*/</font></i>
<a name='L1250'>
<a name='L1251'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9045.html' title='Multiple defined in 3 places.'>gzwrite</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file,
<a name='L1252'>                                voidpc buf, <b>unsigned</b> len));
<a name='L1253'><i><font color='green'>/*</font></i>
<a name='L1254'><i><font color='green'>     Writes the given number of uncompressed bytes into the compressed file.</font></i>
<a name='L1255'><i><font color='green'>   gzwrite returns the number of uncompressed bytes written or 0 in case of</font></i>
<a name='L1256'><i><font color='green'>   error.</font></i>
<a name='L1257'><i><font color='green'>*/</font></i>
<a name='L1258'>
<a name='L1259'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5923.html' title='Multiple defined in 10 places.'>ZEXPORTVA</a> <a href='../D/9034.html' title='Multiple defined in 5 places.'>gzprintf</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>const</b> <b>char</b> *format, ...));
<a name='L1260'><i><font color='green'>/*</font></i>
<a name='L1261'><i><font color='green'>     Converts, formats, and writes the arguments to the compressed file under</font></i>
<a name='L1262'><i><font color='green'>   control of the format string, as in fprintf.  gzprintf returns the number of</font></i>
<a name='L1263'><i><font color='green'>   uncompressed bytes actually written, or 0 in case of error.  The number of</font></i>
<a name='L1264'><i><font color='green'>   uncompressed bytes written is limited to 8191, or one less than the buffer</font></i>
<a name='L1265'><i><font color='green'>   size given to gzbuffer().  The caller should assure that this limit is not</font></i>
<a name='L1266'><i><font color='green'>   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with</font></i>
<a name='L1267'><i><font color='green'>   nothing written.  In this case, there may also be a buffer overflow with</font></i>
<a name='L1268'><i><font color='green'>   unpredictable consequences, which is possible only if zlib was compiled with</font></i>
<a name='L1269'><i><font color='green'>   the insecure functions sprintf() or vsprintf() because the secure snprintf()</font></i>
<a name='L1270'><i><font color='green'>   or vsnprintf() functions were not available.  This can be determined using</font></i>
<a name='L1271'><i><font color='green'>   zlibCompileFlags().</font></i>
<a name='L1272'><i><font color='green'>*/</font></i>
<a name='L1273'>
<a name='L1274'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9036.html' title='Multiple defined in 3 places.'>gzputs</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>const</b> <b>char</b> *s));
<a name='L1275'><i><font color='green'>/*</font></i>
<a name='L1276'><i><font color='green'>     Writes the given null-terminated string to the compressed file, excluding</font></i>
<a name='L1277'><i><font color='green'>   the terminating null character.</font></i>
<a name='L1278'><i><font color='green'></font></i>
<a name='L1279'><i><font color='green'>     gzputs returns the number of characters written, or -1 in case of error.</font></i>
<a name='L1280'><i><font color='green'>*/</font></i>
<a name='L1281'>
<a name='L1282'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>char</b> * <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9029.html' title='Multiple defined in 3 places.'>gzgets</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>char</b> *buf, <b>int</b> len));
<a name='L1283'><i><font color='green'>/*</font></i>
<a name='L1284'><i><font color='green'>     Reads bytes from the compressed file until len-1 characters are read, or a</font></i>
<a name='L1285'><i><font color='green'>   newline character is read and transferred to buf, or an end-of-file</font></i>
<a name='L1286'><i><font color='green'>   condition is encountered.  If any characters are read or if len == 1, the</font></i>
<a name='L1287'><i><font color='green'>   string is terminated with a null character.  If no characters are read due</font></i>
<a name='L1288'><i><font color='green'>   to an end-of-file or len &lt; 1, then the buffer is left untouched.</font></i>
<a name='L1289'><i><font color='green'></font></i>
<a name='L1290'><i><font color='green'>     gzgets returns buf which is a null-terminated string, or it returns NULL</font></i>
<a name='L1291'><i><font color='green'>   for end-of-file or in case of error.  If there was an error, the contents at</font></i>
<a name='L1292'><i><font color='green'>   buf are indeterminate.</font></i>
<a name='L1293'><i><font color='green'>*/</font></i>
<a name='L1294'>
<a name='L1295'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9035.html' title='Multiple defined in 3 places.'>gzputc</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>int</b> c));
<a name='L1296'><i><font color='green'>/*</font></i>
<a name='L1297'><i><font color='green'>     Writes c, converted to an unsigned char, into the compressed file.  gzputc</font></i>
<a name='L1298'><i><font color='green'>   returns the value that was written, or -1 in case of error.</font></i>
<a name='L1299'><i><font color='green'>*/</font></i>
<a name='L1300'>
<a name='L1301'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9028.html' title='Multiple defined in 3 places.'>gzgetc</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1302'><i><font color='green'>/*</font></i>
<a name='L1303'><i><font color='green'>     Reads one byte from the compressed file.  gzgetc returns this byte or -1</font></i>
<a name='L1304'><i><font color='green'>   in case of end of file or error.</font></i>
<a name='L1305'><i><font color='green'>*/</font></i>
<a name='L1306'>
<a name='L1307'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9044.html' title='Multiple defined in 3 places.'>gzungetc</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>int</b> c, gzFile file));
<a name='L1308'><i><font color='green'>/*</font></i>
<a name='L1309'><i><font color='green'>     Push one character back onto the stream to be read as the first character</font></i>
<a name='L1310'><i><font color='green'>   on the next read.  At least one character of push-back is allowed.</font></i>
<a name='L1311'><i><font color='green'>   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will</font></i>
<a name='L1312'><i><font color='green'>   fail if c is -1, and may fail if a character has been pushed but not read</font></i>
<a name='L1313'><i><font color='green'>   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the</font></i>
<a name='L1314'><i><font color='green'>   output buffer size of pushed characters is allowed.  (See gzbuffer above.)</font></i>
<a name='L1315'><i><font color='green'>   The pushed character will be discarded if the stream is repositioned with</font></i>
<a name='L1316'><i><font color='green'>   gzseek() or gzrewind().</font></i>
<a name='L1317'><i><font color='green'>*/</font></i>
<a name='L1318'>
<a name='L1319'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9027.html' title='Multiple defined in 3 places.'>gzflush</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>int</b> flush));
<a name='L1320'><i><font color='green'>/*</font></i>
<a name='L1321'><i><font color='green'>     Flushes all pending output into the compressed file.  The parameter flush</font></i>
<a name='L1322'><i><font color='green'>   is as in the deflate() function.  The return value is the zlib error number</font></i>
<a name='L1323'><i><font color='green'>   (see function gzerror below).  gzflush is only permitted when writing.</font></i>
<a name='L1324'><i><font color='green'></font></i>
<a name='L1325'><i><font color='green'>     If the flush parameter is Z_FINISH, the remaining data is written and the</font></i>
<a name='L1326'><i><font color='green'>   gzip stream is completed in the output.  If gzwrite() is called again, a new</font></i>
<a name='L1327'><i><font color='green'>   gzip stream will be started in the output.  gzread() is able to read such</font></i>
<a name='L1328'><i><font color='green'>   concatented gzip streams.</font></i>
<a name='L1329'><i><font color='green'></font></i>
<a name='L1330'><i><font color='green'>     gzflush should be called only when strictly necessary because it will</font></i>
<a name='L1331'><i><font color='green'>   degrade compression if called too often.</font></i>
<a name='L1332'><i><font color='green'>*/</font></i>
<a name='L1333'>
<a name='L1334'><i><font color='green'>/*</font></i>
<a name='L1335'><i><font color='green'>ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,</font></i>
<a name='L1336'><i><font color='green'>                                   z_off_t offset, int whence));</font></i>
<a name='L1337'><i><font color='green'></font></i>
<a name='L1338'><i><font color='green'>     Sets the starting position for the next gzread or gzwrite on the given</font></i>
<a name='L1339'><i><font color='green'>   compressed file.  The offset represents a number of bytes in the</font></i>
<a name='L1340'><i><font color='green'>   uncompressed data stream.  The whence parameter is defined as in lseek(2);</font></i>
<a name='L1341'><i><font color='green'>   the value SEEK_END is not supported.</font></i>
<a name='L1342'><i><font color='green'></font></i>
<a name='L1343'><i><font color='green'>     If the file is opened for reading, this function is emulated but can be</font></i>
<a name='L1344'><i><font color='green'>   extremely slow.  If the file is opened for writing, only forward seeks are</font></i>
<a name='L1345'><i><font color='green'>   supported; gzseek then compresses a sequence of zeroes up to the new</font></i>
<a name='L1346'><i><font color='green'>   starting position.</font></i>
<a name='L1347'><i><font color='green'></font></i>
<a name='L1348'><i><font color='green'>     gzseek returns the resulting offset location as measured in bytes from</font></i>
<a name='L1349'><i><font color='green'>   the beginning of the uncompressed stream, or -1 in case of error, in</font></i>
<a name='L1350'><i><font color='green'>   particular if the file is opened for writing and the new starting position</font></i>
<a name='L1351'><i><font color='green'>   would be before the current position.</font></i>
<a name='L1352'><i><font color='green'>*/</font></i>
<a name='L1353'>
<a name='L1354'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a>    <a href='../D/9038.html' title='Multiple defined in 3 places.'>gzrewind</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1355'><i><font color='green'>/*</font></i>
<a name='L1356'><i><font color='green'>     Rewinds the given file. This function is supported only for reading.</font></i>
<a name='L1357'><i><font color='green'></font></i>
<a name='L1358'><i><font color='green'>     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)</font></i>
<a name='L1359'><i><font color='green'>*/</font></i>
<a name='L1360'>
<a name='L1361'><i><font color='green'>/*</font></i>
<a name='L1362'><i><font color='green'>ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));</font></i>
<a name='L1363'><i><font color='green'></font></i>
<a name='L1364'><i><font color='green'>     Returns the starting position for the next gzread or gzwrite on the given</font></i>
<a name='L1365'><i><font color='green'>   compressed file.  This position represents a number of bytes in the</font></i>
<a name='L1366'><i><font color='green'>   uncompressed data stream, and is zero when starting, even if appending or</font></i>
<a name='L1367'><i><font color='green'>   reading a gzip stream from the middle of a file using gzdopen().</font></i>
<a name='L1368'><i><font color='green'></font></i>
<a name='L1369'><i><font color='green'>     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)</font></i>
<a name='L1370'><i><font color='green'>*/</font></i>
<a name='L1371'>
<a name='L1372'><i><font color='green'>/*</font></i>
<a name='L1373'><i><font color='green'>ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));</font></i>
<a name='L1374'><i><font color='green'></font></i>
<a name='L1375'><i><font color='green'>     Returns the current offset in the file being read or written.  This offset</font></i>
<a name='L1376'><i><font color='green'>   includes the count of bytes that precede the gzip stream, for example when</font></i>
<a name='L1377'><i><font color='green'>   appending or when using gzdopen() for reading.  When reading, the offset</font></i>
<a name='L1378'><i><font color='green'>   does not include as yet unused buffered input.  This information can be used</font></i>
<a name='L1379'><i><font color='green'>   for a progress indicator.  On error, gzoffset() returns -1.</font></i>
<a name='L1380'><i><font color='green'>*/</font></i>
<a name='L1381'>
<a name='L1382'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9025.html' title='Multiple defined in 3 places.'>gzeof</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1383'><i><font color='green'>/*</font></i>
<a name='L1384'><i><font color='green'>     Returns true (1) if the end-of-file indicator has been set while reading,</font></i>
<a name='L1385'><i><font color='green'>   false (0) otherwise.  Note that the end-of-file indicator is set only if the</font></i>
<a name='L1386'><i><font color='green'>   read tried to go past the end of the input, but came up short.  Therefore,</font></i>
<a name='L1387'><i><font color='green'>   just like feof(), gzeof() may return false even if there is no more data to</font></i>
<a name='L1388'><i><font color='green'>   read, in the event that the last read request was for the exact number of</font></i>
<a name='L1389'><i><font color='green'>   bytes remaining in the input file.  This will happen if the input file size</font></i>
<a name='L1390'><i><font color='green'>   is an exact multiple of the buffer size.</font></i>
<a name='L1391'><i><font color='green'></font></i>
<a name='L1392'><i><font color='green'>     If gzeof() returns true, then the read functions will return no more data,</font></i>
<a name='L1393'><i><font color='green'>   unless the end-of-file indicator is reset by gzclearerr() and the input file</font></i>
<a name='L1394'><i><font color='green'>   has grown since the previous end of file was detected.</font></i>
<a name='L1395'><i><font color='green'>*/</font></i>
<a name='L1396'>
<a name='L1397'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9023.html' title='Multiple defined in 3 places.'>gzdirect</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1398'><i><font color='green'>/*</font></i>
<a name='L1399'><i><font color='green'>     Returns true (1) if file is being copied directly while reading, or false</font></i>
<a name='L1400'><i><font color='green'>   (0) if file is a gzip stream being decompressed.  This state can change from</font></i>
<a name='L1401'><i><font color='green'>   false to true while reading the input file if the end of a gzip stream is</font></i>
<a name='L1402'><i><font color='green'>   reached, but is followed by data that is not another gzip stream.</font></i>
<a name='L1403'><i><font color='green'></font></i>
<a name='L1404'><i><font color='green'>     If the input file is empty, gzdirect() will return true, since the input</font></i>
<a name='L1405'><i><font color='green'>   does not contain a gzip stream.</font></i>
<a name='L1406'><i><font color='green'></font></i>
<a name='L1407'><i><font color='green'>     If gzdirect() is used immediately after gzopen() or gzdopen() it will</font></i>
<a name='L1408'><i><font color='green'>   cause buffers to be allocated to allow reading the file to determine if it</font></i>
<a name='L1409'><i><font color='green'>   is a gzip file.  Therefore if gzbuffer() is used, it should be called before</font></i>
<a name='L1410'><i><font color='green'>   gzdirect().</font></i>
<a name='L1411'><i><font color='green'>*/</font></i>
<a name='L1412'>
<a name='L1413'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a>    <a href='../D/9020.html' title='Multiple defined in 3 places.'>gzclose</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1414'><i><font color='green'>/*</font></i>
<a name='L1415'><i><font color='green'>     Flushes all pending output if necessary, closes the compressed file and</font></i>
<a name='L1416'><i><font color='green'>   deallocates the (de)compression state.  Note that once file is closed, you</font></i>
<a name='L1417'><i><font color='green'>   cannot call gzerror with file, since its structures have been deallocated.</font></i>
<a name='L1418'><i><font color='green'>   gzclose must not be called more than once on the same file, just as free</font></i>
<a name='L1419'><i><font color='green'>   must not be called more than once on the same allocation.</font></i>
<a name='L1420'><i><font color='green'></font></i>
<a name='L1421'><i><font color='green'>     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a</font></i>
<a name='L1422'><i><font color='green'>   file operation error, or Z_OK on success.</font></i>
<a name='L1423'><i><font color='green'>*/</font></i>
<a name='L1424'>
<a name='L1425'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9021.html' title='Multiple defined in 2 places.'>gzclose_r</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1426'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9022.html' title='Multiple defined in 2 places.'>gzclose_w</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1427'><i><font color='green'>/*</font></i>
<a name='L1428'><i><font color='green'>     Same as gzclose(), but gzclose_r() is only for use when reading, and</font></i>
<a name='L1429'><i><font color='green'>   gzclose_w() is only for use when writing or appending.  The advantage to</font></i>
<a name='L1430'><i><font color='green'>   using these instead of gzclose() is that they avoid linking in zlib</font></i>
<a name='L1431'><i><font color='green'>   compression or decompression code that is not used when only reading or only</font></i>
<a name='L1432'><i><font color='green'>   writing respectively.  If gzclose() is used, then both compression and</font></i>
<a name='L1433'><i><font color='green'>   decompression code will be included the application when linking to a static</font></i>
<a name='L1434'><i><font color='green'>   zlib library.</font></i>
<a name='L1435'><i><font color='green'>*/</font></i>
<a name='L1436'>
<a name='L1437'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>const</b> <b>char</b> * <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9026.html' title='Multiple defined in 3 places.'>gzerror</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file, <b>int</b> *errnum));
<a name='L1438'><i><font color='green'>/*</font></i>
<a name='L1439'><i><font color='green'>     Returns the error message for the last error which occurred on the given</font></i>
<a name='L1440'><i><font color='green'>   compressed file.  errnum is set to zlib error number.  If an error occurred</font></i>
<a name='L1441'><i><font color='green'>   in the file system and not in the compression library, errnum is set to</font></i>
<a name='L1442'><i><font color='green'>   Z_ERRNO and the application may consult errno to get the exact error code.</font></i>
<a name='L1443'><i><font color='green'></font></i>
<a name='L1444'><i><font color='green'>     The application must not modify the returned string.  Future calls to</font></i>
<a name='L1445'><i><font color='green'>   this function may invalidate the previously returned string.  If file is</font></i>
<a name='L1446'><i><font color='green'>   closed, then the string previously returned by gzerror will no longer be</font></i>
<a name='L1447'><i><font color='green'>   available.</font></i>
<a name='L1448'><i><font color='green'></font></i>
<a name='L1449'><i><font color='green'>     gzerror() should be used to distinguish errors from end-of-file for those</font></i>
<a name='L1450'><i><font color='green'>   functions above that do not distinguish those cases in their return values.</font></i>
<a name='L1451'><i><font color='green'>*/</font></i>
<a name='L1452'>
<a name='L1453'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>void</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9019.html' title='Multiple defined in 3 places.'>gzclearerr</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile file));
<a name='L1454'><i><font color='green'>/*</font></i>
<a name='L1455'><i><font color='green'>     Clears the error and end-of-file flags for file.  This is analogous to the</font></i>
<a name='L1456'><i><font color='green'>   clearerr() function in stdio.  This is useful for continuing to read a gzip</font></i>
<a name='L1457'><i><font color='green'>   file that is being written concurrently.</font></i>
<a name='L1458'><i><font color='green'>*/</font></i>
<a name='L1459'>
<a name='L1460'>
<a name='L1461'>                        <i><font color='green'>/* checksum functions */</font></i>
<a name='L1462'>
<a name='L1463'><i><font color='green'>/*</font></i>
<a name='L1464'><i><font color='green'>     These functions are not related to compression but are exported</font></i>
<a name='L1465'><i><font color='green'>   anyway because they might be useful in applications using the compression</font></i>
<a name='L1466'><i><font color='green'>   library.</font></i>
<a name='L1467'><i><font color='green'>*/</font></i>
<a name='L1468'>
<a name='L1469'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/6692.html' title='Multiple defined in 3 places.'>adler32</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong adler, <b>const</b> Bytef *buf, uInt len));
<a name='L1470'><i><font color='green'>/*</font></i>
<a name='L1471'><i><font color='green'>     Update a running Adler-32 checksum with the bytes buf[0..len-1] and</font></i>
<a name='L1472'><i><font color='green'>   return the updated checksum.  If buf is Z_NULL, this function returns the</font></i>
<a name='L1473'><i><font color='green'>   required initial value for the checksum.</font></i>
<a name='L1474'><i><font color='green'></font></i>
<a name='L1475'><i><font color='green'>     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed</font></i>
<a name='L1476'><i><font color='green'>   much faster.</font></i>
<a name='L1477'><i><font color='green'></font></i>
<a name='L1478'><i><font color='green'>   Usage example:</font></i>
<a name='L1479'><i><font color='green'></font></i>
<a name='L1480'><i><font color='green'>     uLong adler = adler32(0L, Z_NULL, 0);</font></i>
<a name='L1481'><i><font color='green'></font></i>
<a name='L1482'><i><font color='green'>     while (read_buffer(buffer, length) != EOF) {</font></i>
<a name='L1483'><i><font color='green'>       adler = adler32(adler, buffer, length);</font></i>
<a name='L1484'><i><font color='green'>     }</font></i>
<a name='L1485'><i><font color='green'>     if (adler != original_adler) error();</font></i>
<a name='L1486'><i><font color='green'>*/</font></i>
<a name='L1487'>
<a name='L1488'><i><font color='green'>/*</font></i>
<a name='L1489'><i><font color='green'>ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,</font></i>
<a name='L1490'><i><font color='green'>                                          z_off_t len2));</font></i>
<a name='L1491'><i><font color='green'></font></i>
<a name='L1492'><i><font color='green'>     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1</font></i>
<a name='L1493'><i><font color='green'>   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for</font></i>
<a name='L1494'><i><font color='green'>   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of</font></i>
<a name='L1495'><i><font color='green'>   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.</font></i>
<a name='L1496'><i><font color='green'>*/</font></i>
<a name='L1497'>
<a name='L1498'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7813.html' title='Multiple defined in 3 places.'>crc32</a>   <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong crc, <b>const</b> Bytef *buf, uInt len));
<a name='L1499'><i><font color='green'>/*</font></i>
<a name='L1500'><i><font color='green'>     Update a running CRC-32 with the bytes buf[0..len-1] and return the</font></i>
<a name='L1501'><i><font color='green'>   updated CRC-32.  If buf is Z_NULL, this function returns the required</font></i>
<a name='L1502'><i><font color='green'>   initial value for the for the crc.  Pre- and post-conditioning (one's</font></i>
<a name='L1503'><i><font color='green'>   complement) is performed within this function so it shouldn't be done by the</font></i>
<a name='L1504'><i><font color='green'>   application.</font></i>
<a name='L1505'><i><font color='green'></font></i>
<a name='L1506'><i><font color='green'>   Usage example:</font></i>
<a name='L1507'><i><font color='green'></font></i>
<a name='L1508'><i><font color='green'>     uLong crc = crc32(0L, Z_NULL, 0);</font></i>
<a name='L1509'><i><font color='green'></font></i>
<a name='L1510'><i><font color='green'>     while (read_buffer(buffer, length) != EOF) {</font></i>
<a name='L1511'><i><font color='green'>       crc = crc32(crc, buffer, length);</font></i>
<a name='L1512'><i><font color='green'>     }</font></i>
<a name='L1513'><i><font color='green'>     if (crc != original_crc) error();</font></i>
<a name='L1514'><i><font color='green'>*/</font></i>
<a name='L1515'>
<a name='L1516'><i><font color='green'>/*</font></i>
<a name='L1517'><i><font color='green'>ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));</font></i>
<a name='L1518'><i><font color='green'></font></i>
<a name='L1519'><i><font color='green'>     Combine two CRC-32 check values into one.  For two sequences of bytes,</font></i>
<a name='L1520'><i><font color='green'>   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were</font></i>
<a name='L1521'><i><font color='green'>   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32</font></i>
<a name='L1522'><i><font color='green'>   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and</font></i>
<a name='L1523'><i><font color='green'>   len2.</font></i>
<a name='L1524'><i><font color='green'>*/</font></i>
<a name='L1525'>
<a name='L1526'>
<a name='L1527'>                        <i><font color='green'>/* various hacks, don't look :) */</font></i>
<a name='L1528'>
<a name='L1529'><i><font color='green'>/* deflateInit and inflateInit are macros to allow checking the zlib version</font></i>
<a name='L1530'><i><font color='green'> * and the compiler's view of z_stream:</font></i>
<a name='L1531'><i><font color='green'> */</font></i>
<a name='L1532'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8011.html' title='Multiple defined in 3 places.'>deflateInit_</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b> level,
<a name='L1533'>                                     <b>const</b> <b>char</b> *version, <b>int</b> stream_size));
<a name='L1534'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9167.html' title='Multiple defined in 3 places.'>inflateInit_</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm,
<a name='L1535'>                                     <b>const</b> <b>char</b> *version, <b>int</b> stream_size));
<a name='L1536'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8010.html' title='Multiple defined in 3 places.'>deflateInit2_</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b>  level, <b>int</b>  method,
<a name='L1537'>                                      <b>int</b> windowBits, <b>int</b> memLevel,
<a name='L1538'>                                      <b>int</b> strategy, <b>const</b> <b>char</b> *version,
<a name='L1539'>                                      <b>int</b> stream_size));
<a name='L1540'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9166.html' title='Multiple defined in 3 places.'>inflateInit2_</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b>  windowBits,
<a name='L1541'>                                      <b>const</b> <b>char</b> *version, <b>int</b> stream_size));
<a name='L1542'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9160.html' title='Multiple defined in 2 places.'>inflateBackInit_</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp strm, <b>int</b> windowBits,
<a name='L1543'>                                         <b>unsigned</b> <b>char</b> <a href='../D/1088.html' title='Multiple defined in 13 places.'>FAR</a> *window,
<a name='L1544'>                                         <b>const</b> <b>char</b> *version,
<a name='L1545'>                                         <b>int</b> stream_size));
<a name='L1546'><font color='darkred'>#define</font> <a href='../R/7228.html' title='Multiple refered from 6 places.'>deflateInit</a>(strm, level) \
<a name='L1547'>        <a href='../D/8011.html' title='Multiple defined in 3 places.'>deflateInit_</a>((strm), (level),       <a href='../S/2769.html#L40' title='Defined at 40 in Modules/zlib/zlib.h.'>ZLIB_VERSION</a>, <b>sizeof</b>(<a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a>))
<a name='L1548'><font color='darkred'>#define</font> <a href='../R/8355.html' title='Multiple refered from 5 places.'>inflateInit</a>(strm) \
<a name='L1549'>        <a href='../D/9167.html' title='Multiple defined in 3 places.'>inflateInit_</a>((strm),                <a href='../S/2769.html#L40' title='Defined at 40 in Modules/zlib/zlib.h.'>ZLIB_VERSION</a>, <b>sizeof</b>(<a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a>))
<a name='L1550'><font color='darkred'>#define</font> <a href='../R/7229.html' title='Multiple refered from 3 places.'>deflateInit2</a>(strm, level, method, windowBits, memLevel, strategy) \
<a name='L1551'>        <a href='../D/8010.html' title='Multiple defined in 3 places.'>deflateInit2_</a>((strm),(level),(method),(windowBits),(memLevel),\
<a name='L1552'>                      (strategy),           <a href='../S/2769.html#L40' title='Defined at 40 in Modules/zlib/zlib.h.'>ZLIB_VERSION</a>, <b>sizeof</b>(<a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a>))
<a name='L1553'><font color='darkred'>#define</font> <a href='../R/8356.html' title='Multiple refered from 5 places.'>inflateInit2</a>(strm, windowBits) \
<a name='L1554'>        <a href='../D/9166.html' title='Multiple defined in 3 places.'>inflateInit2_</a>((strm), (windowBits), <a href='../S/2769.html#L40' title='Defined at 40 in Modules/zlib/zlib.h.'>ZLIB_VERSION</a>, <b>sizeof</b>(<a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a>))
<a name='L1555'><font color='darkred'>#define</font> inflateBackInit(strm, windowBits, window) \
<a name='L1556'>        <a href='../D/9160.html' title='Multiple defined in 2 places.'>inflateBackInit_</a>((strm), (windowBits), (window), \
<a name='L1557'>                                            <a href='../S/2769.html#L40' title='Defined at 40 in Modules/zlib/zlib.h.'>ZLIB_VERSION</a>, <b>sizeof</b>(<a href='../S/2769.html#L104' title='Defined at 104 in Modules/zlib/zlib.h.'>z_stream</a>))
<a name='L1558'>
<a name='L1559'><i><font color='green'>/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or</font></i>
<a name='L1560'><i><font color='green'> * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if</font></i>
<a name='L1561'><i><font color='green'> * both are true, the application gets the *64 functions, and the regular</font></i>
<a name='L1562'><i><font color='green'> * functions are changed to 64 bits) -- in case these are set on systems</font></i>
<a name='L1563'><i><font color='green'> * without large file support, _LFS64_LARGEFILE must also be true</font></i>
<a name='L1564'><i><font color='green'> */</font></i>
<a name='L1565'><font color='darkred'>#if</font> <b>defined</b>(<a href='../S/2764.html#L374' title='Defined at 374 in Modules/zlib/zconf.h.'>_LARGEFILE64_SOURCE</a>) &amp;&amp; _LFS64_LARGEFILE-0
<a name='L1566'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/8993.html' title='Multiple defined in 2 places.'>gzFile</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9033.html' title='Multiple defined in 2 places.'>gzopen64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>const</b> <b>char</b> *, <b>const</b> <b>char</b> *));
<a name='L1567'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9040.html' title='Multiple defined in 2 places.'>gzseek64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile, <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a>, <b>int</b>));
<a name='L1568'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9043.html' title='Multiple defined in 2 places.'>gztell64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1569'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9031.html' title='Multiple defined in 2 places.'>gzoffset64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1570'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/6694.html' title='Multiple defined in 2 places.'>adler32_combine64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a>));
<a name='L1571'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7816.html' title='Multiple defined in 2 places.'>crc32_combine64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12436.html' title='Multiple defined in 2 places.'>z_off64_t</a>));
<a name='L1572'><font color='darkred'>#endif</font>
<a name='L1573'>
<a name='L1574'><font color='darkred'>#if</font> !<b>defined</b>(<a href='../D/5928.html' title='Multiple defined in 6 places.'>ZLIB_INTERNAL</a>) &amp;&amp; <a href='../S/2742.html#L11' title='Defined at 11 in Modules/zlib/gzguts.h.'>_FILE_OFFSET_BITS</a>-0 == 64 &amp;&amp; _LFS64_LARGEFILE-0
<a name='L1575'><font color='darkred'>#  define</font> <a href='../R/8229.html' title='Multiple refered from 6 places.'>gzopen</a> <a href='../D/9033.html' title='Multiple defined in 2 places.'>gzopen64</a>
<a name='L1576'><font color='darkred'>#  define</font> <a href='../R/8236.html' title='Multiple refered from 4 places.'>gzseek</a> <a href='../D/9040.html' title='Multiple defined in 2 places.'>gzseek64</a>
<a name='L1577'><font color='darkred'>#  define</font> <a href='../R/8239.html' title='Multiple refered from 3 places.'>gztell</a> <a href='../D/9043.html' title='Multiple defined in 2 places.'>gztell64</a>
<a name='L1578'><font color='darkred'>#  define</font> <a href='../S/2769.html#L1593' title='Refered from 1593 in Modules/zlib/zlib.h.'>gzoffset</a> <a href='../D/9031.html' title='Multiple defined in 2 places.'>gzoffset64</a>
<a name='L1579'><font color='darkred'>#  define</font> <a href='../S/2769.html#L1594' title='Refered from 1594 in Modules/zlib/zlib.h.'>adler32_combine</a> <a href='../D/6694.html' title='Multiple defined in 2 places.'>adler32_combine64</a>
<a name='L1580'><font color='darkred'>#  define</font> <a href='../S/2769.html#L1595' title='Refered from 1595 in Modules/zlib/zlib.h.'>crc32_combine</a> <a href='../D/7816.html' title='Multiple defined in 2 places.'>crc32_combine64</a>
<a name='L1581'><font color='darkred'>#  ifdef</font> <a href='../S/2764.html#L374' title='Defined at 374 in Modules/zlib/zconf.h.'>_LARGEFILE64_SOURCE</a>
<a name='L1582'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/8993.html' title='Multiple defined in 2 places.'>gzFile</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9033.html' title='Multiple defined in 2 places.'>gzopen64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>const</b> <b>char</b> *, <b>const</b> <b>char</b> *));
<a name='L1583'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9040.html' title='Multiple defined in 2 places.'>gzseek64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>, <b>int</b>));
<a name='L1584'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9043.html' title='Multiple defined in 2 places.'>gztell64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1585'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9031.html' title='Multiple defined in 2 places.'>gzoffset64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1586'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/6694.html' title='Multiple defined in 2 places.'>adler32_combine64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>));
<a name='L1587'>     <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7816.html' title='Multiple defined in 2 places.'>crc32_combine64</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>));
<a name='L1588'><font color='darkred'>#  endif</font>
<a name='L1589'><font color='darkred'>#else</font>
<a name='L1590'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/8993.html' title='Multiple defined in 2 places.'>gzFile</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9032.html' title='Multiple defined in 4 places.'>gzopen</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>const</b> <b>char</b> *, <b>const</b> <b>char</b> *));
<a name='L1591'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9039.html' title='Multiple defined in 4 places.'>gzseek</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>, <b>int</b>));
<a name='L1592'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9042.html' title='Multiple defined in 4 places.'>gztell</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1593'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9030.html' title='Multiple defined in 3 places.'>gzoffset</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((gzFile));
<a name='L1594'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/6693.html' title='Multiple defined in 3 places.'>adler32_combine</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>));
<a name='L1595'>   <a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <a href='../D/11920.html' title='Multiple defined in 4 places.'>uLong</a> <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/7815.html' title='Multiple defined in 3 places.'>crc32_combine</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((uLong, uLong, <a href='../D/12437.html' title='Multiple defined in 4 places.'>z_off_t</a>));
<a name='L1596'><font color='darkred'>#endif</font>
<a name='L1597'>
<a name='L1598'><i><font color='green'>/* hack for buggy compilers */</font></i>
<a name='L1599'><font color='darkred'>#if</font> !<b>defined</b>(<a href='../S/2773.html#L14' title='Defined at 14 in Modules/zlib/zutil.h.'>ZUTIL_H</a>) &amp;&amp; !<b>defined</b>(<a href='../D/2327.html' title='Multiple defined in 2 places.'>NO_DUMMY_DECL</a>)
<a name='L1600'>    <b>struct</b> <a href='../R/8457.html' title='Multiple refered from 7 places.'>internal_state</a> <font color='red'>{</font><b>int</b> dummy;<font color='red'>}</font>;
<a name='L1601'><font color='darkred'>#endif</font>
<a name='L1602'>
<a name='L1603'><i><font color='green'>/* undocumented functions */</font></i>
<a name='L1604'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>const</b> <b>char</b>   * <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/12433.html' title='Multiple defined in 3 places.'>zError</a>           <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>int</b>));
<a name='L1605'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b>            <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9174.html' title='Multiple defined in 3 places.'>inflateSyncPoint</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp));
<a name='L1606'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>const</b> <a href='../D/11921.html' title='Multiple defined in 4 places.'>uLongf</a> * <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/8843.html' title='Multiple defined in 3 places.'>get_crc_table</a>    <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((<b>void</b>));
<a name='L1607'><a href='../D/5924.html' title='Multiple defined in 6 places.'>ZEXTERN</a> <b>int</b>            <a href='../D/5922.html' title='Multiple defined in 8 places.'>ZEXPORT</a> <a href='../D/9175.html' title='Multiple defined in 2 places.'>inflateUndermine</a> <a href='../D/2401.html' title='Multiple defined in 9 places.'>OF</a>((z_streamp, <b>int</b>));
<a name='L1608'>
<a name='L1609'><font color='darkred'>#ifdef</font> __cplusplus
<a name='L1610'><font color='red'>}</font>
<a name='L1611'><font color='darkred'>#endif</font>
<a name='L1612'>
<a name='L1613'><font color='darkred'>#endif</font> <i><font color='green'>/* ZLIB_H */</font></i>
</pre>
<hr>
<a name='BOTTOM'>
<i><font color='green'>/* [&lt;][&gt;][^][v]<a href='#TOP'>[top]</a>[bottom]<a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
</body>
</html>
