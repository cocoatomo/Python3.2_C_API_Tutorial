

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Unicode Objects and Codecs &mdash; Python v3.2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.2 documentation" href="../index.html" />
    <link rel="up" title="Concrete Objects Layer" href="concrete.html" />
    <link rel="next" title="Tuple Objects" href="tuple.html" />
    <link rel="prev" title="Byte Array Objects" href="bytearray.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuple Objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="Byte Array Objects"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="concrete.html" accesskey="U">Concrete Objects Layer</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="unicode-objects-and-codecs">
<span id="unicodeobjects"></span><h1>Unicode Objects and Codecs<a class="headerlink" href="#unicode-objects-and-codecs" title="Permalink to this headline">¶</a></h1>
<div class="section" id="unicode-objects">
<h2>Unicode Objects<a class="headerlink" href="#unicode-objects" title="Permalink to this headline">¶</a></h2>
<div class="section" id="unicode-type">
<h3>Unicode Type<a class="headerlink" href="#unicode-type" title="Permalink to this headline">¶</a></h3>
<p>These are the basic Unicode object types used for the Unicode implementation in
Python:</p>
<dl class="type">
<dt id="Py_UNICODE">
<tt class="descname">Py_UNICODE</tt><a class="headerlink" href="#Py_UNICODE" title="Permalink to this definition">¶</a></dt>
<dd><p>This type represents the storage type which is used by Python internally as
basis for holding Unicode ordinals.  Python&#8217;s default builds use a 16-bit type
for <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> and store Unicode values internally as UCS2. It is also
possible to build a UCS4 version of Python (most recent Linux distributions come
with UCS4 builds of Python). These builds then use a 32-bit type for
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> and store Unicode data internally as UCS4. On platforms
where <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> is available and compatible with the chosen Python
Unicode build variant, <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> is a typedef alias for
<tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> to enhance native platform compatibility. On all other
platforms, <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> is a typedef alias for either <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span>
<span class="pre">short</span></tt> (UCS2) or <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> (UCS4).</p>
</dd></dl>

<p>Note that UCS2 and UCS4 Python builds are not binary compatible. Please keep
this in mind when writing extensions or interfaces.</p>
<dl class="type">
<dt id="PyUnicodeObject">
<tt class="descname">PyUnicodeObject</tt><a class="headerlink" href="#PyUnicodeObject" title="Permalink to this definition">¶</a></dt>
<dd><p>This subtype of <a class="reference internal" href="structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject</span></tt></a> represents a Python Unicode object.</p>
</dd></dl>

<dl class="var">
<dt id="PyUnicode_Type">
<a class="reference internal" href="type.html#PyTypeObject" title="PyTypeObject">PyTypeObject</a> <tt class="descname">PyUnicode_Type</tt><a class="headerlink" href="#PyUnicode_Type" title="Permalink to this definition">¶</a></dt>
<dd><p>This instance of <a class="reference internal" href="type.html#PyTypeObject" title="PyTypeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></tt></a> represents the Python Unicode type.  It
is exposed to Python code as <tt class="docutils literal"><span class="pre">str</span></tt>.</p>
</dd></dl>

<p>The following APIs are really C macros and can be used to do fast checks and to
access internal read-only data of Unicode objects:</p>
<dl class="function">
<dt id="PyUnicode_Check">
int <tt class="descname">PyUnicode_Check</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_Check" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object or an instance of a Unicode
subtype.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_CheckExact">
int <tt class="descname">PyUnicode_CheckExact</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_CheckExact" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object, but not an instance of a
subtype.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_GET_SIZE">
Py_ssize_t <tt class="descname">PyUnicode_GET_SIZE</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_GET_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the object.  <em>o</em> has to be a <a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyUnicodeObject</span></tt></a> (not
checked).</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_GET_DATA_SIZE">
Py_ssize_t <tt class="descname">PyUnicode_GET_DATA_SIZE</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_GET_DATA_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the object&#8217;s internal buffer in bytes.  <em>o</em> has to be a
<a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyUnicodeObject</span></tt></a> (not checked).</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AS_UNICODE">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <tt class="descname">PyUnicode_AS_UNICODE</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_AS_UNICODE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer to the internal <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the object.  <em>o</em>
has to be a <a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyUnicodeObject</span></tt></a> (not checked).</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AS_DATA">
const char* <tt class="descname">PyUnicode_AS_DATA</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><big>)</big><a class="headerlink" href="#PyUnicode_AS_DATA" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer to the internal buffer of the object. <em>o</em> has to be a
<a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyUnicodeObject</span></tt></a> (not checked).</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_ClearFreeList">
int <tt class="descname">PyUnicode_ClearFreeList</tt><big>(</big><big>)</big><a class="headerlink" href="#PyUnicode_ClearFreeList" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the free list. Return the total number of freed items.</p>
</dd></dl>

</div>
<div class="section" id="unicode-character-properties">
<h3>Unicode Character Properties<a class="headerlink" href="#unicode-character-properties" title="Permalink to this headline">¶</a></h3>
<p>Unicode provides many different character properties. The most often needed ones
are available through these macros which are mapped to C functions depending on
the Python configuration.</p>
<dl class="function">
<dt id="Py_UNICODE_ISSPACE">
int <tt class="descname">Py_UNICODE_ISSPACE</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISSPACE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a whitespace character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISLOWER">
int <tt class="descname">Py_UNICODE_ISLOWER</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISLOWER" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a lowercase character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISUPPER">
int <tt class="descname">Py_UNICODE_ISUPPER</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISUPPER" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is an uppercase character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISTITLE">
int <tt class="descname">Py_UNICODE_ISTITLE</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISTITLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a titlecase character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISLINEBREAK">
int <tt class="descname">Py_UNICODE_ISLINEBREAK</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISLINEBREAK" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a linebreak character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISDECIMAL">
int <tt class="descname">Py_UNICODE_ISDECIMAL</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISDECIMAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a decimal character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISDIGIT">
int <tt class="descname">Py_UNICODE_ISDIGIT</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISDIGIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a digit character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISNUMERIC">
int <tt class="descname">Py_UNICODE_ISNUMERIC</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISNUMERIC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a numeric character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISALPHA">
int <tt class="descname">Py_UNICODE_ISALPHA</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISALPHA" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is an alphabetic character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISALNUM">
int <tt class="descname">Py_UNICODE_ISALNUM</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISALNUM" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is an alphanumeric character.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_ISPRINTABLE">
int <tt class="descname">Py_UNICODE_ISPRINTABLE</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_ISPRINTABLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 or 0 depending on whether <em>ch</em> is a printable character.
Nonprintable characters are those characters defined in the Unicode character
database as &#8220;Other&#8221; or &#8220;Separator&#8221;, excepting the ASCII space (0x20) which is
considered printable.  (Note that printable characters in this context are
those which should not be escaped when <a class="reference internal" href="../library/functions.html#repr" title="repr"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> is invoked on a string.
It has no bearing on the handling of strings written to <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><tt class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></tt></a> or
<a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><tt class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></tt></a>.)</p>
</dd></dl>

<p>These APIs can be used for fast direct character conversions:</p>
<dl class="function">
<dt id="Py_UNICODE_TOLOWER">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <tt class="descname">Py_UNICODE_TOLOWER</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TOLOWER" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to lower case.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_TOUPPER">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <tt class="descname">Py_UNICODE_TOUPPER</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TOUPPER" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to upper case.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_TOTITLE">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <tt class="descname">Py_UNICODE_TOTITLE</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TOTITLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to title case.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_TODECIMAL">
int <tt class="descname">Py_UNICODE_TODECIMAL</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TODECIMAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a decimal positive integer.  Return
<tt class="docutils literal"><span class="pre">-1</span></tt> if this is not possible.  This macro does not raise exceptions.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_TODIGIT">
int <tt class="descname">Py_UNICODE_TODIGIT</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TODIGIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a single digit integer. Return <tt class="docutils literal"><span class="pre">-1</span></tt> if
this is not possible.  This macro does not raise exceptions.</p>
</dd></dl>

<dl class="function">
<dt id="Py_UNICODE_TONUMERIC">
double <tt class="descname">Py_UNICODE_TONUMERIC</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;ch</em><big>)</big><a class="headerlink" href="#Py_UNICODE_TONUMERIC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character <em>ch</em> converted to a double. Return <tt class="docutils literal"><span class="pre">-1.0</span></tt> if this is not
possible.  This macro does not raise exceptions.</p>
</dd></dl>

</div>
<div class="section" id="plain-py-unicode">
<h3>Plain Py_UNICODE<a class="headerlink" href="#plain-py-unicode" title="Permalink to this headline">¶</a></h3>
<p>To create Unicode objects and access their basic sequence properties, use these
APIs:</p>
<dl class="function">
<dt id="PyUnicode_FromUnicode">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromUnicode</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*u</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_FromUnicode" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the Py_UNICODE buffer <em>u</em> of the given size. <em>u</em>
may be <em>NULL</em> which causes the contents to be undefined. It is the user&#8217;s
responsibility to fill in the needed data.  The buffer is copied into the new
object. If the buffer is not <em>NULL</em>, the return value might be a shared object.
Therefore, modification of the resulting Unicode object is only allowed when <em>u</em>
is <em>NULL</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromStringAndSize">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromStringAndSize</tt><big>(</big>const char<em>&nbsp;*u</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_FromStringAndSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Unicode object from the char buffer <em>u</em>.  The bytes will be interpreted
as being UTF-8 encoded.  <em>u</em> may also be <em>NULL</em> which
causes the contents to be undefined. It is the user&#8217;s responsibility to fill in
the needed data.  The buffer is copied into the new object. If the buffer is not
<em>NULL</em>, the return value might be a shared object. Therefore, modification of
the resulting Unicode object is only allowed when <em>u</em> is <em>NULL</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a> *<tt class="descname">PyUnicode_FromString</tt><big>(</big>const char<em>&nbsp;*u</em><big>)</big><a class="headerlink" href="#PyUnicode_FromString" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Unicode object from an UTF-8 encoded null-terminated char buffer
<em>u</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromFormat">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromFormat</tt><big>(</big>const char<em>&nbsp;*format</em>, ...<big>)</big><a class="headerlink" href="#PyUnicode_FromFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a C <tt class="xref c c-func docutils literal"><span class="pre">printf()</span></tt>-style <em>format</em> string and a variable number of
arguments, calculate the size of the resulting Python unicode string and return
a string with the values formatted into it.  The variable arguments must be C
types and must correspond exactly to the format characters in the <em>format</em>
ASCII-encoded string. The following format characters are allowed:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="29%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Format Characters</th>
<th class="head">Type</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%%</span></tt></td>
<td><em>n/a</em></td>
<td>The literal % character.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%c</span></tt></td>
<td>int</td>
<td>A single character,
represented as an C int.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%d</span></tt></td>
<td>int</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%d&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%u</span></tt></td>
<td>unsigned int</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%u&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%ld</span></tt></td>
<td>long</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%ld&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%lu</span></tt></td>
<td>unsigned long</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%lu&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%lld</span></tt></td>
<td>long long</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%lld&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%llu</span></tt></td>
<td>unsigned long long</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%llu&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%zd</span></tt></td>
<td>Py_ssize_t</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%zd&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%zu</span></tt></td>
<td>size_t</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%zu&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%i</span></tt></td>
<td>int</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%i&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%x</span></tt></td>
<td>int</td>
<td>Exactly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%x&quot;)</span></tt>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%s</span></tt></td>
<td>char*</td>
<td>A null-terminated C character
array.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%p</span></tt></td>
<td>void*</td>
<td>The hex representation of a C
pointer. Mostly equivalent to
<tt class="docutils literal"><span class="pre">printf(&quot;%p&quot;)</span></tt> except that
it is guaranteed to start with
the literal <tt class="docutils literal"><span class="pre">0x</span></tt> regardless
of what the platform&#8217;s
<tt class="docutils literal"><span class="pre">printf</span></tt> yields.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%A</span></tt></td>
<td>PyObject*</td>
<td>The result of calling
<a class="reference internal" href="../library/functions.html#ascii" title="ascii"><tt class="xref py py-func docutils literal"><span class="pre">ascii()</span></tt></a>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%U</span></tt></td>
<td>PyObject*</td>
<td>A unicode object.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%V</span></tt></td>
<td>PyObject*, char *</td>
<td>A unicode object (which may be
<em>NULL</em>) and a null-terminated
C character array as a second
parameter (which will be used,
if the first parameter is
<em>NULL</em>).</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%S</span></tt></td>
<td>PyObject*</td>
<td>The result of calling
<a class="reference internal" href="object.html#PyObject_Str" title="PyObject_Str"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_Str()</span></tt></a>.</td>
</tr>
<tr><td><tt class="xref py py-attr docutils literal"><span class="pre">%R</span></tt></td>
<td>PyObject*</td>
<td>The result of calling
<a class="reference internal" href="object.html#PyObject_Repr" title="PyObject_Repr"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_Repr()</span></tt></a>.</td>
</tr>
</tbody>
</table>
<p>An unrecognized format character causes all the rest of the format string to be
copied as-is to the result string, and any extra arguments discarded.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>&#8220;%lld&#8221;</cite> and <cite>&#8220;%llu&#8221;</cite> format specifiers are only available
when <tt class="xref py py-const docutils literal"><span class="pre">HAVE_LONG_LONG</span></tt> is defined.</p>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.2: </span>Support for <tt class="docutils literal"><span class="pre">&quot;%lld&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;%llu&quot;</span></tt> added.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromFormatV">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromFormatV</tt><big>(</big>const char<em>&nbsp;*format</em>, va_list<em>&nbsp;vargs</em><big>)</big><a class="headerlink" href="#PyUnicode_FromFormatV" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#PyUnicode_FromFormat" title="PyUnicode_FromFormat"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FromFormat()</span></tt></a> except that it takes exactly two
arguments.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_TransformDecimalToASCII">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_TransformDecimalToASCII</tt><big>(</big><a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_TransformDecimalToASCII" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Unicode object by replacing all decimal digits in
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size by ASCII digits 0&#8211;9
according to their decimal value.  Return <em>NULL</em> if an exception
occurs.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUnicode">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <tt class="descname">PyUnicode_AsUnicode</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUnicode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a read-only pointer to the Unicode object&#8217;s internal <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a>
buffer, <em>NULL</em> if <em>unicode</em> is not a Unicode object.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUnicodeCopy">
<a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <tt class="descname">PyUnicode_AsUnicodeCopy</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUnicodeCopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of a unicode string ending with a nul character. Return <em>NULL</em>
and raise a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><tt class="xref py py-exc docutils literal"><span class="pre">MemoryError</span></tt></a> exception on memory allocation failure,
otherwise return a new allocated buffer (use <a class="reference internal" href="memory.html#PyMem_Free" title="PyMem_Free"><tt class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></tt></a> to free the
buffer).</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_GetSize">
Py_ssize_t <tt class="descname">PyUnicode_GetSize</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_GetSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the Unicode object.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromEncodedObject">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromEncodedObject</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, const char<em>&nbsp;*encoding</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_FromEncodedObject" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Coerce an encoded object <em>obj</em> to an Unicode object and return a reference with
incremented refcount.</p>
<p><a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>, <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> and other char buffer compatible objects
are decoded according to the given encoding and using the error handling
defined by errors. Both can be <em>NULL</em> to have the interface use the default
values (see the next section for details).</p>
<p>All other objects, including Unicode objects, cause a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> to be
set.</p>
<p>The API returns <em>NULL</em> if there was an error.  The caller is responsible for
decref&#8217;ing the returned objects.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_FromObject">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromObject</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em><big>)</big><a class="headerlink" href="#PyUnicode_FromObject" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Shortcut for <tt class="docutils literal"><span class="pre">PyUnicode_FromEncodedObject(obj,</span> <span class="pre">NULL,</span> <span class="pre">&quot;strict&quot;)</span></tt> which is used
throughout the interpreter whenever coercion to Unicode is needed.</p>
</dd></dl>

<p>If the platform supports <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> and provides a header file wchar.h,
Python can interface directly to this type using the following functions.
Support is optimized if Python&#8217;s own <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> type is identical to
the system&#8217;s <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt>.</p>
</div>
<div class="section" id="file-system-encoding">
<h3>File System Encoding<a class="headerlink" href="#file-system-encoding" title="Permalink to this headline">¶</a></h3>
<p>To encode and decode file names and other environment strings,
<tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemEncoding</span></tt> should be used as the encoding, and
<tt class="docutils literal"><span class="pre">&quot;surrogateescape&quot;</span></tt> should be used as the error handler (<span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>). To
encode file names during argument parsing, the <tt class="docutils literal"><span class="pre">&quot;O&amp;&quot;</span></tt> converter should be
used, passing <a class="reference internal" href="#PyUnicode_FSConverter" title="PyUnicode_FSConverter"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FSConverter()</span></tt></a> as the conversion function:</p>
<dl class="function">
<dt id="PyUnicode_FSConverter">
int <tt class="descname">PyUnicode_FSConverter</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>*<em>&nbsp;obj</em>, void*<em>&nbsp;result</em><big>)</big><a class="headerlink" href="#PyUnicode_FSConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>ParseTuple converter: encode <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> objects to <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> using
<a class="reference internal" href="#PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_EncodeFSDefault()</span></tt></a>; <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> objects are output as-is.
<em>result</em> must be a <a class="reference internal" href="bytes.html#PyBytesObject" title="PyBytesObject"><tt class="xref c c-type docutils literal"><span class="pre">PyBytesObject*</span></tt></a> which must be released when it is
no longer used.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.1.</span></p>
</dd></dl>

<p>To decode file names during argument parsing, the <tt class="docutils literal"><span class="pre">&quot;O&amp;&quot;</span></tt> converter should be
used, passing <a class="reference internal" href="#PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FSDecoder()</span></tt></a> as the conversion function:</p>
<dl class="function">
<dt id="PyUnicode_FSDecoder">
int <tt class="descname">PyUnicode_FSDecoder</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>*<em>&nbsp;obj</em>, void*<em>&nbsp;result</em><big>)</big><a class="headerlink" href="#PyUnicode_FSDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>ParseTuple converter: decode <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> objects to <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> using
<a class="reference internal" href="#PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></tt></a>; <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> objects are output
as-is. <em>result</em> must be a <a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyUnicodeObject*</span></tt></a> which must be released
when it is no longer used.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeFSDefaultAndSize">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeFSDefaultAndSize</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeFSDefaultAndSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a string using <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> and the
<tt class="docutils literal"><span class="pre">'surrogateescape'</span></tt> error handler, or <tt class="docutils literal"><span class="pre">'strict'</span></tt> on Windows.</p>
<p>If <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> is not set, fall back to the
locale encoding.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.2: </span>Use <tt class="docutils literal"><span class="pre">'strict'</span></tt> error handler on Windows.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeFSDefault">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeFSDefault</tt><big>(</big>const char<em>&nbsp;*s</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeFSDefault" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a null-terminated string using <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt>
and the <tt class="docutils literal"><span class="pre">'surrogateescape'</span></tt> error handler, or <tt class="docutils literal"><span class="pre">'strict'</span></tt> on Windows.</p>
<p>If <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> is not set, fall back to the
locale encoding.</p>
<p>Use <a class="reference internal" href="#PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></tt></a> if you know the string length.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.2: </span>Use <tt class="docutils literal"><span class="pre">'strict'</span></tt> error handler on Windows.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeFSDefault">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeFSDefault</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeFSDefault" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode a Unicode object to <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> with the
<tt class="docutils literal"><span class="pre">'surrogateescape'</span></tt> error handler, or <tt class="docutils literal"><span class="pre">'strict'</span></tt> on Windows, and return
<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>.</p>
<p>If <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> is not set, fall back to the
locale encoding.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

</div>
<div class="section" id="wchar-t-support">
<h3>wchar_t Support<a class="headerlink" href="#wchar-t-support" title="Permalink to this headline">¶</a></h3>
<p>wchar_t support for platforms which support it:</p>
<dl class="function">
<dt id="PyUnicode_FromWideChar">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_FromWideChar</tt><big>(</big>const wchar_t<em>&nbsp;*w</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_FromWideChar" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> buffer <em>w</em> of the given size.
Passing -1 as the size indicates that the function must itself compute the length,
using wcslen.
Return <em>NULL</em> on failure.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsWideChar">
Py_ssize_t <tt class="descname">PyUnicode_AsWideChar</tt><big>(</big><a class="reference internal" href="#PyUnicodeObject" title="PyUnicodeObject">PyUnicodeObject</a><em>&nbsp;*unicode</em>, wchar_t<em>&nbsp;*w</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_AsWideChar" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the Unicode object contents into the <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> buffer <em>w</em>.  At most
<em>size</em> <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> characters are copied (excluding a possibly trailing
0-termination character).  Return the number of <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> characters
copied or -1 in case of an error.  Note that the resulting <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt>
string may or may not be 0-terminated.  It is the responsibility of the caller
to make sure that the <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> string is 0-terminated in case this is
required by the application.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsWideCharString">
wchar_t* <tt class="descname">PyUnicode_AsWideCharString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em>, Py_ssize_t<em>&nbsp;*size</em><big>)</big><a class="headerlink" href="#PyUnicode_AsWideCharString" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the Unicode object to a wide character string. The output string
always ends with a nul character. If <em>size</em> is not <em>NULL</em>, write the number
of wide characters (excluding the trailing 0-termination character) into
<em>*size</em>.</p>
<p>Returns a buffer allocated by <tt class="xref c c-func docutils literal"><span class="pre">PyMem_Alloc()</span></tt> (use <a class="reference internal" href="memory.html#PyMem_Free" title="PyMem_Free"><tt class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></tt></a>
to free it) on success. On error, returns <em>NULL</em>, <em>*size</em> is undefined and
raises a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><tt class="xref py py-exc docutils literal"><span class="pre">MemoryError</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

</div>
</div>
<div class="section" id="built-in-codecs">
<span id="builtincodecs"></span><h2>Built-in Codecs<a class="headerlink" href="#built-in-codecs" title="Permalink to this headline">¶</a></h2>
<p>Python provides a set of built-in codecs which are written in C for speed. All of
these codecs are directly usable via the following functions.</p>
<p>Many of the following APIs take two arguments encoding and errors. These
parameters encoding and errors have the same semantics as the ones of the
built-in <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> string object constructor.</p>
<p>Setting encoding to <em>NULL</em> causes the default encoding to be used
which is ASCII.  The file system calls should use
<a class="reference internal" href="#PyUnicode_FSConverter" title="PyUnicode_FSConverter"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FSConverter()</span></tt></a> for encoding file names. This uses the
variable <tt class="xref c c-data docutils literal"><span class="pre">Py_FileSystemDefaultEncoding</span></tt> internally. This
variable should be treated as read-only: On some systems, it will be a
pointer to a static string, on others, it will change at run-time
(such as when the application invokes setlocale).</p>
<p>Error handling is set by errors which may also be set to <em>NULL</em> meaning to use
the default handling defined for the codec.  Default error handling for all
built-in codecs is &#8220;strict&#8221; (<a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> is raised).</p>
<p>The codecs all use a similar interface.  Only deviation from the following
generic ones are documented for simplicity.</p>
<div class="section" id="generic-codecs">
<h3>Generic Codecs<a class="headerlink" href="#generic-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the generic codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_Decode">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Decode</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*encoding</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_Decode" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>s</em>.
<em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same name
in the <tt class="xref py py-func docutils literal"><span class="pre">unicode()</span></tt> built-in function.  The codec to be used is looked up
using the Python codec registry.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Encode">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Encode</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*encoding</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_Encode" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size and return a Python
bytes object.  <em>encoding</em> and <em>errors</em> have the same meaning as the
parameters of the same name in the Unicode <tt class="xref py py-meth docutils literal"><span class="pre">encode()</span></tt> method.  The codec
to be used is looked up using the Python codec registry.  Return <em>NULL</em> if an
exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsEncodedString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsEncodedString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em>, const char<em>&nbsp;*encoding</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_AsEncodedString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object and return the result as Python bytes object.
<em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same
name in the Unicode <tt class="xref py py-meth docutils literal"><span class="pre">encode()</span></tt> method. The codec to be used is looked up
using the Python codec registry. Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

</div>
<div class="section" id="utf-8-codecs">
<h3>UTF-8 Codecs<a class="headerlink" href="#utf-8-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the UTF-8 codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeUTF8">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF8</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF8" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-8 encoded string
<em>s</em>. Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeUTF8Stateful">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF8Stateful</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, Py_ssize_t<em>&nbsp;*consumed</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF8Stateful" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <em>NULL</em>, behave like <a class="reference internal" href="#PyUnicode_DecodeUTF8" title="PyUnicode_DecodeUTF8"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF8()</span></tt></a>. If
<em>consumed</em> is not <em>NULL</em>, trailing incomplete UTF-8 byte sequences will not be
treated as an error. Those bytes will not be decoded and the number of bytes
that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeUTF8">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeUTF8</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeUTF8" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using UTF-8 and
return a Python bytes object.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUTF8String">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsUTF8String</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUTF8String" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using UTF-8 and return the result as Python bytes
object.  Error handling is &#8220;strict&#8221;.  Return <em>NULL</em> if an exception was
raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="utf-32-codecs">
<h3>UTF-32 Codecs<a class="headerlink" href="#utf-32-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the UTF-32 codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeUTF32">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF32</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;*byteorder</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF32" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode <em>length</em> bytes from a UTF-32 encoded buffer string and return the
corresponding Unicode object.  <em>errors</em> (if non-<em>NULL</em>) defines the error
handling. It defaults to &#8220;strict&#8221;.</p>
<p>If <em>byteorder</em> is non-<em>NULL</em>, the decoder starts decoding using the given byte
order:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">*byteorder</span></tt> is zero, and the first four bytes of the input data are a
byte order mark (BOM), the decoder switches to this byte order and the BOM is
not copied into the resulting Unicode string.  If <tt class="docutils literal"><span class="pre">*byteorder</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt> or
<tt class="docutils literal"><span class="pre">1</span></tt>, any byte order mark is copied to the output.</p>
<p>After completion, <em>*byteorder</em> is set to the current byte order at the end
of input data.</p>
<p>In a narrow build codepoints outside the BMP will be decoded as surrogate pairs.</p>
<p>If <em>byteorder</em> is <em>NULL</em>, the codec starts in native order mode.</p>
<p>Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeUTF32Stateful">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF32Stateful</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;*byteorder</em>, Py_ssize_t<em>&nbsp;*consumed</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF32Stateful" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>consumed</em> is <em>NULL</em>, behave like <a class="reference internal" href="#PyUnicode_DecodeUTF32" title="PyUnicode_DecodeUTF32"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF32()</span></tt></a>. If
<em>consumed</em> is not <em>NULL</em>, <a class="reference internal" href="#PyUnicode_DecodeUTF32Stateful" title="PyUnicode_DecodeUTF32Stateful"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF32Stateful()</span></tt></a> will not treat
trailing incomplete UTF-32 byte sequences (such as a number of bytes not divisible
by four) as an error. Those bytes will not be decoded and the number of bytes
that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeUTF32">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeUTF32</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;byteorder</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeUTF32" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python bytes object holding the UTF-32 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <tt class="docutils literal"><span class="pre">0</span></tt>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <em>Py_UNICODE_WIDE</em> is not defined, surrogate pairs will be output
as a single codepoint.</p>
<p>Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUTF32String">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsUTF32String</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUTF32String" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python byte string using the UTF-32 encoding in native byte
order. The string always starts with a BOM mark.  Error handling is &#8220;strict&#8221;.
Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="utf-16-codecs">
<h3>UTF-16 Codecs<a class="headerlink" href="#utf-16-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the UTF-16 codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeUTF16">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF16</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;*byteorder</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF16" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode <em>length</em> bytes from a UTF-16 encoded buffer string and return the
corresponding Unicode object.  <em>errors</em> (if non-<em>NULL</em>) defines the error
handling. It defaults to &#8220;strict&#8221;.</p>
<p>If <em>byteorder</em> is non-<em>NULL</em>, the decoder starts decoding using the given byte
order:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">*byteorder</span></tt> is zero, and the first two bytes of the input data are a
byte order mark (BOM), the decoder switches to this byte order and the BOM is
not copied into the resulting Unicode string.  If <tt class="docutils literal"><span class="pre">*byteorder</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt> or
<tt class="docutils literal"><span class="pre">1</span></tt>, any byte order mark is copied to the output (where it will result in
either a <tt class="docutils literal"><span class="pre">\ufeff</span></tt> or a <tt class="docutils literal"><span class="pre">\ufffe</span></tt> character).</p>
<p>After completion, <em>*byteorder</em> is set to the current byte order at the end
of input data.</p>
<p>If <em>byteorder</em> is <em>NULL</em>, the codec starts in native order mode.</p>
<p>Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeUTF16Stateful">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF16Stateful</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;*byteorder</em>, Py_ssize_t<em>&nbsp;*consumed</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF16Stateful" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <em>NULL</em>, behave like <a class="reference internal" href="#PyUnicode_DecodeUTF16" title="PyUnicode_DecodeUTF16"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF16()</span></tt></a>. If
<em>consumed</em> is not <em>NULL</em>, <a class="reference internal" href="#PyUnicode_DecodeUTF16Stateful" title="PyUnicode_DecodeUTF16Stateful"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF16Stateful()</span></tt></a> will not treat
trailing incomplete UTF-16 byte sequences (such as an odd number of bytes or a
split surrogate pair) as an error. Those bytes will not be decoded and the
number of bytes that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeUTF16">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeUTF16</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;byteorder</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeUTF16" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python bytes object holding the UTF-16 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <tt class="docutils literal"><span class="pre">0</span></tt>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <em>Py_UNICODE_WIDE</em> is defined, a single <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> value may get
represented as a surrogate pair. If it is not defined, each <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a>
values is interpreted as an UCS-2 character.</p>
<p>Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUTF16String">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsUTF16String</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUTF16String" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python byte string using the UTF-16 encoding in native byte
order. The string always starts with a BOM mark.  Error handling is &#8220;strict&#8221;.
Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="utf-7-codecs">
<h3>UTF-7 Codecs<a class="headerlink" href="#utf-7-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the UTF-7 codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeUTF7">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF7</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF7" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-7 encoded string
<em>s</em>.  Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeUTF7Stateful">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUTF7Stateful</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, Py_ssize_t<em>&nbsp;*consumed</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUTF7Stateful" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>consumed</em> is <em>NULL</em>, behave like <a class="reference internal" href="#PyUnicode_DecodeUTF7" title="PyUnicode_DecodeUTF7"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeUTF7()</span></tt></a>.  If
<em>consumed</em> is not <em>NULL</em>, trailing incomplete UTF-7 base-64 sections will not
be treated as an error.  Those bytes will not be decoded and the number of
bytes that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeUTF7">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeUTF7</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, int<em>&nbsp;base64SetO</em>, int<em>&nbsp;base64WhiteSpace</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeUTF7" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using UTF-7 and
return a Python bytes object.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
<p>If <em>base64SetO</em> is nonzero, &#8220;Set O&#8221; (punctuation that has no otherwise
special meaning) will be encoded in base-64.  If <em>base64WhiteSpace</em> is
nonzero, whitespace will be encoded in base-64.  Both are set to zero for the
Python &#8220;utf-7&#8221; codec.</p>
</dd></dl>

</div>
<div class="section" id="unicode-escape-codecs">
<h3>Unicode-Escape Codecs<a class="headerlink" href="#unicode-escape-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the &#8220;Unicode Escape&#8221; codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeUnicodeEscape">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeUnicodeEscape</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeUnicodeEscape" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Unicode-Escape encoded
string <em>s</em>.  Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeUnicodeEscape">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeUnicodeEscape</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeUnicodeEscape" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using Unicode-Escape and
return a Python string object.  Return <em>NULL</em> if an exception was raised by the
codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsUnicodeEscapeString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsUnicodeEscapeString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsUnicodeEscapeString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Unicode-Escape and return the result as Python
string object.  Error handling is &#8220;strict&#8221;. Return <em>NULL</em> if an exception was
raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="raw-unicode-escape-codecs">
<h3>Raw-Unicode-Escape Codecs<a class="headerlink" href="#raw-unicode-escape-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the &#8220;Raw Unicode Escape&#8221; codec APIs:</p>
<dl class="function">
<dt id="PyUnicode_DecodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeRawUnicodeEscape</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeRawUnicodeEscape" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Raw-Unicode-Escape
encoded string <em>s</em>.  Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeRawUnicodeEscape</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeRawUnicodeEscape" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using Raw-Unicode-Escape
and return a Python string object.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsRawUnicodeEscapeString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsRawUnicodeEscapeString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsRawUnicodeEscapeString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Raw-Unicode-Escape and return the result as
Python string object. Error handling is &#8220;strict&#8221;. Return <em>NULL</em> if an exception
was raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="latin-1-codecs">
<h3>Latin-1 Codecs<a class="headerlink" href="#latin-1-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode
ordinals and only these are accepted by the codecs during encoding.</p>
<dl class="function">
<dt id="PyUnicode_DecodeLatin1">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeLatin1</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeLatin1" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Latin-1 encoded string
<em>s</em>.  Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeLatin1">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeLatin1</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeLatin1" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using Latin-1 and
return a Python bytes object.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsLatin1String">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsLatin1String</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsLatin1String" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Latin-1 and return the result as Python bytes
object.  Error handling is &#8220;strict&#8221;.  Return <em>NULL</em> if an exception was
raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="ascii-codecs">
<h3>ASCII Codecs<a class="headerlink" href="#ascii-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All other
codes generate errors.</p>
<dl class="function">
<dt id="PyUnicode_DecodeASCII">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeASCII</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeASCII" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the ASCII encoded string
<em>s</em>.  Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeASCII">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeASCII</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeASCII" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using ASCII and
return a Python bytes object.  Return <em>NULL</em> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsASCIIString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsASCIIString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsASCIIString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using ASCII and return the result as Python bytes
object.  Error handling is &#8220;strict&#8221;.  Return <em>NULL</em> if an exception was
raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="character-map-codecs">
<h3>Character Map Codecs<a class="headerlink" href="#character-map-codecs" title="Permalink to this headline">¶</a></h3>
<p>These are the mapping codec APIs:</p>
<p>This codec is special in that it can be used to implement many different codecs
(and this is in fact what was done to obtain most of the standard codecs
included in the <tt class="xref py py-mod docutils literal"><span class="pre">encodings</span></tt> package). The codec uses mapping to encode and
decode characters.</p>
<p>Decoding mappings must map single string characters to single Unicode
characters, integers (which are then interpreted as Unicode ordinals) or None
(meaning &#8220;undefined mapping&#8221; and causing an error).</p>
<p>Encoding mappings must map single Unicode characters to single string
characters, integers (which are then interpreted as Latin-1 ordinals) or None
(meaning &#8220;undefined mapping&#8221; and causing an error).</p>
<p>The mapping objects provided must only support the __getitem__ mapping
interface.</p>
<p>If a character lookup fails with a LookupError, the character is copied as-is
meaning that its ordinal value will be interpreted as Unicode or Latin-1 ordinal
resp. Because of this, mappings only need to contain those mappings which map
characters to different code points.</p>
<dl class="function">
<dt id="PyUnicode_DecodeCharmap">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeCharmap</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*mapping</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeCharmap" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>s</em> using
the given <em>mapping</em> object.  Return <em>NULL</em> if an exception was raised by the
codec. If <em>mapping</em> is <em>NULL</em> latin-1 decoding will be done. Else it can be a
dictionary mapping byte or a unicode string, which is treated as a lookup table.
Byte values greater that the length of the string and U+FFFE &#8220;characters&#8221; are
treated as &#8220;undefined mapping&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeCharmap">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeCharmap</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*mapping</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeCharmap" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using the given
<em>mapping</em> object and return a Python string object. Return <em>NULL</em> if an
exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsCharmapString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsCharmapString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*mapping</em><big>)</big><a class="headerlink" href="#PyUnicode_AsCharmapString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using the given <em>mapping</em> object and return the result
as Python string object.  Error handling is &#8220;strict&#8221;.  Return <em>NULL</em> if an
exception was raised by the codec.</p>
</dd></dl>

<p>The following codec API is special in that maps Unicode to Unicode.</p>
<dl class="function">
<dt id="PyUnicode_TranslateCharmap">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_TranslateCharmap</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*table</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_TranslateCharmap" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Translate a <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given length by applying a
character mapping <em>table</em> to it and return the resulting Unicode object.  Return
<em>NULL</em> when an exception was raised by the codec.</p>
<p>The <em>mapping</em> table must map Unicode ordinal integers to Unicode ordinal
integers or None (causing deletion of the character).</p>
<p>Mapping tables need only provide the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> interface; dictionaries
and sequences work well.  Unmapped character ordinals (ones which cause a
<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><tt class="xref py py-exc docutils literal"><span class="pre">LookupError</span></tt></a>) are left untouched and are copied as-is.</p>
</dd></dl>

<p>These are the MBCS codec APIs. They are currently only available on Windows and
use the Win32 MBCS converters to implement the conversions.  Note that MBCS (or
DBCS) is a class of encodings, not just one.  The target encoding is defined by
the user settings on the machine running the codec.</p>
</div>
<div class="section" id="mbcs-codecs-for-windows">
<h3>MBCS codecs for Windows<a class="headerlink" href="#mbcs-codecs-for-windows" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="PyUnicode_DecodeMBCS">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeMBCS</tt><big>(</big>const char<em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeMBCS" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the MBCS encoded string <em>s</em>.
Return <em>NULL</em> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_DecodeMBCSStateful">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_DecodeMBCSStateful</tt><big>(</big>const char<em>&nbsp;*s</em>, int<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em>, int<em>&nbsp;*consumed</em><big>)</big><a class="headerlink" href="#PyUnicode_DecodeMBCSStateful" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>consumed</em> is <em>NULL</em>, behave like <a class="reference internal" href="#PyUnicode_DecodeMBCS" title="PyUnicode_DecodeMBCS"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeMBCS()</span></tt></a>. If
<em>consumed</em> is not <em>NULL</em>, <a class="reference internal" href="#PyUnicode_DecodeMBCSStateful" title="PyUnicode_DecodeMBCSStateful"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_DecodeMBCSStateful()</span></tt></a> will not decode
trailing lead byte and the number of bytes that have been decoded will be stored
in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_EncodeMBCS">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_EncodeMBCS</tt><big>(</big>const <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em>&nbsp;*s</em>, Py_ssize_t<em>&nbsp;size</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_EncodeMBCS" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> buffer of the given size using MBCS and return
a Python bytes object.  Return <em>NULL</em> if an exception was raised by the
codec.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_AsMBCSString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_AsMBCSString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*unicode</em><big>)</big><a class="headerlink" href="#PyUnicode_AsMBCSString" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using MBCS and return the result as Python bytes
object.  Error handling is &#8220;strict&#8221;.  Return <em>NULL</em> if an exception was
raised by the codec.</p>
</dd></dl>

</div>
<div class="section" id="methods-slots">
<h3>Methods &amp; Slots<a class="headerlink" href="#methods-slots" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="methods-and-slot-functions">
<span id="unicodemethodsandslots"></span><h2>Methods and Slot Functions<a class="headerlink" href="#methods-and-slot-functions" title="Permalink to this headline">¶</a></h2>
<p>The following APIs are capable of handling Unicode objects and strings on input
(we refer to them as strings in the descriptions) and return Unicode objects or
integers as appropriate.</p>
<p>They all return <em>NULL</em> or <tt class="docutils literal"><span class="pre">-1</span></tt> if an exception occurs.</p>
<dl class="function">
<dt id="PyUnicode_Concat">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Concat</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*left</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*right</em><big>)</big><a class="headerlink" href="#PyUnicode_Concat" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Concat two strings giving a new Unicode string.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Split">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Split</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*s</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*sep</em>, Py_ssize_t<em>&nbsp;maxsplit</em><big>)</big><a class="headerlink" href="#PyUnicode_Split" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Split a string giving a list of Unicode strings.  If sep is <em>NULL</em>, splitting
will be done at all whitespace substrings.  Otherwise, splits occur at the given
separator.  At most <em>maxsplit</em> splits will be done.  If negative, no limit is
set.  Separators are not included in the resulting list.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Splitlines">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Splitlines</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*s</em>, int<em>&nbsp;keepend</em><big>)</big><a class="headerlink" href="#PyUnicode_Splitlines" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Split a Unicode string at line breaks, returning a list of Unicode strings.
CRLF is considered to be one line break.  If <em>keepend</em> is 0, the Line break
characters are not included in the resulting strings.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Translate">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Translate</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*str</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*table</em>, const char<em>&nbsp;*errors</em><big>)</big><a class="headerlink" href="#PyUnicode_Translate" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Translate a string by applying a character mapping table to it and return the
resulting Unicode object.</p>
<p>The mapping table must map Unicode ordinal integers to Unicode ordinal integers
or None (causing deletion of the character).</p>
<p>Mapping tables need only provide the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> interface; dictionaries
and sequences work well.  Unmapped character ordinals (ones which cause a
<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><tt class="xref py py-exc docutils literal"><span class="pre">LookupError</span></tt></a>) are left untouched and are copied as-is.</p>
<p><em>errors</em> has the usual meaning for codecs. It may be <em>NULL</em> which indicates to
use the default error handling.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Join">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Join</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*separator</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*seq</em><big>)</big><a class="headerlink" href="#PyUnicode_Join" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Join a sequence of strings using the given separator and return the resulting
Unicode string.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Tailmatch">
int <tt class="descname">PyUnicode_Tailmatch</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*str</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*substr</em>, Py_ssize_t<em>&nbsp;start</em>, Py_ssize_t<em>&nbsp;end</em>, int<em>&nbsp;direction</em><big>)</big><a class="headerlink" href="#PyUnicode_Tailmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 if <em>substr</em> matches <em>str*[*start</em>:<em>end</em>] at the given tail end
(<em>direction</em> == -1 means to do a prefix match, <em>direction</em> == 1 a suffix match),
0 otherwise. Return <tt class="docutils literal"><span class="pre">-1</span></tt> if an error occurred.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Find">
Py_ssize_t <tt class="descname">PyUnicode_Find</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*str</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*substr</em>, Py_ssize_t<em>&nbsp;start</em>, Py_ssize_t<em>&nbsp;end</em>, int<em>&nbsp;direction</em><big>)</big><a class="headerlink" href="#PyUnicode_Find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first position of <em>substr</em> in <em>str*[*start</em>:<em>end</em>] using the given
<em>direction</em> (<em>direction</em> == 1 means to do a forward search, <em>direction</em> == -1 a
backward search).  The return value is the index of the first match; a value of
<tt class="docutils literal"><span class="pre">-1</span></tt> indicates that no match was found, and <tt class="docutils literal"><span class="pre">-2</span></tt> indicates that an error
occurred and an exception has been set.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Count">
Py_ssize_t <tt class="descname">PyUnicode_Count</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*str</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*substr</em>, Py_ssize_t<em>&nbsp;start</em>, Py_ssize_t<em>&nbsp;end</em><big>)</big><a class="headerlink" href="#PyUnicode_Count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of non-overlapping occurrences of <em>substr</em> in
<tt class="docutils literal"><span class="pre">str[start:end]</span></tt>.  Return <tt class="docutils literal"><span class="pre">-1</span></tt> if an error occurred.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Replace">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Replace</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*str</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*substr</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*replstr</em>, Py_ssize_t<em>&nbsp;maxcount</em><big>)</big><a class="headerlink" href="#PyUnicode_Replace" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Replace at most <em>maxcount</em> occurrences of <em>substr</em> in <em>str</em> with <em>replstr</em> and
return the resulting Unicode object. <em>maxcount</em> == -1 means replace all
occurrences.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Compare">
int <tt class="descname">PyUnicode_Compare</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*left</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*right</em><big>)</big><a class="headerlink" href="#PyUnicode_Compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two strings and return -1, 0, 1 for less than, equal, and greater than,
respectively.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_CompareWithASCIIString">
int <tt class="descname">PyUnicode_CompareWithASCIIString</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*uni</em>, char<em>&nbsp;*string</em><big>)</big><a class="headerlink" href="#PyUnicode_CompareWithASCIIString" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare a unicode object, <em>uni</em>, with <em>string</em> and return -1, 0, 1 for less
than, equal, and greater than, respectively. It is best to pass only
ASCII-encoded strings, but the function interprets the input string as
ISO-8859-1 if it contains non-ASCII characters&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_RichCompare">
int <tt class="descname">PyUnicode_RichCompare</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*left</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*right</em>, int<em>&nbsp;op</em><big>)</big><a class="headerlink" href="#PyUnicode_RichCompare" title="Permalink to this definition">¶</a></dt>
<dd><p>Rich compare two unicode strings and return one of the following:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">NULL</span></tt> in case an exception was raised</li>
<li><tt class="xref py py-const docutils literal"><span class="pre">Py_True</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">Py_False</span></tt> for successful comparisons</li>
<li><tt class="xref py py-const docutils literal"><span class="pre">Py_NotImplemented</span></tt> in case the type combination is unknown</li>
</ul>
<p>Note that <tt class="xref py py-const docutils literal"><span class="pre">Py_EQ</span></tt> and <tt class="xref py py-const docutils literal"><span class="pre">Py_NE</span></tt> comparisons can cause a
<a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeWarning</span></tt></a> in case the conversion of the arguments to Unicode fails
with a <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></tt></a>.</p>
<p>Possible values for <em>op</em> are <tt class="xref py py-const docutils literal"><span class="pre">Py_GT</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">Py_GE</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">Py_EQ</span></tt>,
<tt class="xref py py-const docutils literal"><span class="pre">Py_NE</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">Py_LT</span></tt>, and <tt class="xref py py-const docutils literal"><span class="pre">Py_LE</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Format">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_Format</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*format</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em><big>)</big><a class="headerlink" href="#PyUnicode_Format" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a new string object from <em>format</em> and <em>args</em>; this is analogous to
<tt class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">args</span></tt>.  The <em>args</em> argument must be a tuple.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_Contains">
int <tt class="descname">PyUnicode_Contains</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*container</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*element</em><big>)</big><a class="headerlink" href="#PyUnicode_Contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <em>element</em> is contained in <em>container</em> and return true or false
accordingly.</p>
<p><em>element</em> has to coerce to a one element Unicode string. <tt class="docutils literal"><span class="pre">-1</span></tt> is returned if
there was an error.</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_InternInPlace">
void <tt class="descname">PyUnicode_InternInPlace</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;**string</em><big>)</big><a class="headerlink" href="#PyUnicode_InternInPlace" title="Permalink to this definition">¶</a></dt>
<dd><p>Intern the argument <em>*string</em> in place.  The argument must be the address of a
pointer variable pointing to a Python unicode string object.  If there is an
existing interned string that is the same as <em>*string</em>, it sets <em>*string</em> to
it (decrementing the reference count of the old string object and incrementing
the reference count of the interned string object), otherwise it leaves
<em>*string</em> alone and interns it (incrementing its reference count).
(Clarification: even though there is a lot of talk about reference counts, think
of this function as reference-count-neutral; you own the object after the call
if and only if you owned it before the call.)</p>
</dd></dl>

<dl class="function">
<dt id="PyUnicode_InternFromString">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyUnicode_InternFromString</tt><big>(</big>const char<em>&nbsp;*v</em><big>)</big><a class="headerlink" href="#PyUnicode_InternFromString" title="Permalink to this definition">¶</a></dt>
<dd><p>A combination of <a class="reference internal" href="#PyUnicode_FromString" title="PyUnicode_FromString"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FromString()</span></tt></a> and
<a class="reference internal" href="#PyUnicode_InternInPlace" title="PyUnicode_InternInPlace"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_InternInPlace()</span></tt></a>, returning either a new unicode string object
that has been interned, or a new (&#8220;owned&#8221;) reference to an earlier interned
string object with the same value.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unicode Objects and Codecs</a><ul>
<li><a class="reference internal" href="#unicode-objects">Unicode Objects</a><ul>
<li><a class="reference internal" href="#unicode-type">Unicode Type</a></li>
<li><a class="reference internal" href="#unicode-character-properties">Unicode Character Properties</a></li>
<li><a class="reference internal" href="#plain-py-unicode">Plain Py_UNICODE</a></li>
<li><a class="reference internal" href="#file-system-encoding">File System Encoding</a></li>
<li><a class="reference internal" href="#wchar-t-support">wchar_t Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-codecs">Built-in Codecs</a><ul>
<li><a class="reference internal" href="#generic-codecs">Generic Codecs</a></li>
<li><a class="reference internal" href="#utf-8-codecs">UTF-8 Codecs</a></li>
<li><a class="reference internal" href="#utf-32-codecs">UTF-32 Codecs</a></li>
<li><a class="reference internal" href="#utf-16-codecs">UTF-16 Codecs</a></li>
<li><a class="reference internal" href="#utf-7-codecs">UTF-7 Codecs</a></li>
<li><a class="reference internal" href="#unicode-escape-codecs">Unicode-Escape Codecs</a></li>
<li><a class="reference internal" href="#raw-unicode-escape-codecs">Raw-Unicode-Escape Codecs</a></li>
<li><a class="reference internal" href="#latin-1-codecs">Latin-1 Codecs</a></li>
<li><a class="reference internal" href="#ascii-codecs">ASCII Codecs</a></li>
<li><a class="reference internal" href="#character-map-codecs">Character Map Codecs</a></li>
<li><a class="reference internal" href="#mbcs-codecs-for-windows">MBCS codecs for Windows</a></li>
<li><a class="reference internal" href="#methods-slots">Methods &amp; Slots</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-and-slot-functions">Methods and Slot Functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="bytearray.html"
                        title="previous chapter">Byte Array Objects</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tuple.html"
                        title="next chapter">Tuple Objects</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/c-api/unicode.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuple Objects"
             >next</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="Byte Array Objects"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="concrete.html" >Concrete Objects Layer</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 27, 2011.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>