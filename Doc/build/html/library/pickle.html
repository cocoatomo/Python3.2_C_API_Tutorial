

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>11.1. pickle — Python object serialization &mdash; Python v3.2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.2 documentation" href="../index.html" />
    <link rel="up" title="11. Data Persistence" href="persistence.html" />
    <link rel="next" title="11.2. copyreg — Register pickle support functions" href="copyreg.html" />
    <link rel="prev" title="11. Data Persistence" href="persistence.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="11.2. copyreg — Register pickle support functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="11. Data Persistence"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" accesskey="U">11. Data Persistence</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pickle-python-object-serialization">
<h1>11.1. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> &#8212; Python object serialization<a class="headerlink" href="#pickle-python-object-serialization" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-pickle"><span id="index-0"></span></span><p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module implements a fundamental, but powerful algorithm for
serializing and de-serializing a Python object structure.  &#8220;Pickling&#8221; is the
process whereby a Python object hierarchy is converted into a byte stream, and
&#8220;unpickling&#8221; is the inverse operation, whereby a byte stream is converted back
into an object hierarchy.  Pickling (and unpickling) is alternatively known as
&#8220;serialization&#8221;, &#8220;marshalling,&#8221; <a class="footnote-reference" href="#id5" id="id1">[1]</a> or &#8220;flattening&#8221;, however, to avoid
confusion, the terms used here are &#8220;pickling&#8221; and &#8220;unpickling&#8221;..</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module is not intended to be secure against erroneous or
maliciously constructed data.  Never unpickle data received from an untrusted
or unauthenticated source.</p>
</div>
<div class="section" id="relationship-to-other-python-modules">
<h2>11.1.1. Relationship to other Python modules<a class="headerlink" href="#relationship-to-other-python-modules" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module has an transparent optimizer (<tt class="xref py py-mod docutils literal"><span class="pre">_pickle</span></tt>) written
in C.  It is used whenever available.  Otherwise the pure Python implementation is
used.</p>
<p>Python has a more primitive serialization module called <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a>, but in
general <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> should always be the preferred way to serialize Python
objects.  <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> exists primarily to support Python&#8217;s <tt class="file docutils literal"><span class="pre">.pyc</span></tt>
files.</p>
<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module differs from <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> in several significant ways:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module keeps track of the objects it has already serialized,
so that later references to the same object won&#8217;t be serialized again.
<a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> doesn&#8217;t do this.</p>
<p>This has implications both for recursive objects and object sharing.  Recursive
objects are objects that contain references to themselves.  These are not
handled by marshal, and in fact, attempting to marshal recursive objects will
crash your Python interpreter.  Object sharing happens when there are multiple
references to the same object in different places in the object hierarchy being
serialized.  <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> stores such objects only once, and ensures that all
other references point to the master copy.  Shared objects remain shared, which
can be very important for mutable objects.</p>
</li>
<li><p class="first"><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> cannot be used to serialize user-defined classes and their
instances.  <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> can save and restore class instances transparently,
however the class definition must be importable and live in the same module as
when the object was stored.</p>
</li>
<li><p class="first">The <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> serialization format is not guaranteed to be portable
across Python versions.  Because its primary job in life is to support
<tt class="file docutils literal"><span class="pre">.pyc</span></tt> files, the Python implementers reserve the right to change the
serialization format in non-backwards compatible ways should the need arise.
The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> serialization format is guaranteed to be backwards compatible
across Python releases.</p>
</li>
</ul>
<p>Note that serialization is a more primitive notion than persistence; although
<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> reads and writes file objects, it does not handle the issue of
naming persistent objects, nor the (even more complicated) issue of concurrent
access to persistent objects.  The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module can transform a complex
object into a byte stream and it can transform the byte stream into an object
with the same internal structure.  Perhaps the most obvious thing to do with
these byte streams is to write them onto a file, but it is also conceivable to
send them across a network or store them in a database.  The module
<a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><tt class="xref py py-mod docutils literal"><span class="pre">shelve</span></tt></a> provides a simple interface to pickle and unpickle objects on
DBM-style database files.</p>
</div>
<div class="section" id="data-stream-format">
<h2>11.1.2. Data stream format<a class="headerlink" href="#data-stream-format" title="Permalink to this headline">¶</a></h2>
<p id="index-1">The data format used by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards such as
XDR (which can&#8217;t represent pointer sharing); however it means that non-Python
programs may not be able to reconstruct pickled Python objects.</p>
<p>By default, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> data format uses a compact binary representation.
The module <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><tt class="xref py py-mod docutils literal"><span class="pre">pickletools</span></tt></a> contains tools for analyzing data streams
generated by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a>.</p>
<p>There are currently 4 different protocols which can be used for pickling.</p>
<ul class="simple">
<li>Protocol version 0 is the original human-readable protocol and is
backwards compatible with earlier versions of Python.</li>
<li>Protocol version 1 is the old binary format which is also compatible with
earlier versions of Python.</li>
<li>Protocol version 2 was introduced in Python 2.3.  It provides much more
efficient pickling of <a class="reference internal" href="../glossary.html#term-new-style-class"><em class="xref std std-term">new-style class</em></a>es.</li>
<li>Protocol version 3 was added in Python 3.0.  It has explicit support for
bytes and cannot be unpickled by Python 2.x pickle modules.  This is
the current recommended protocol, use it whenever it is possible.</li>
</ul>
<p>Refer to <span class="target" id="index-2"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> for information about improvements brought by
protocol 2.  See <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><tt class="xref py py-mod docutils literal"><span class="pre">pickletools</span></tt></a>&#8216;s source code for extensive
comments about opcodes used by pickle protocols.</p>
</div>
<div class="section" id="module-interface">
<h2>11.1.3. Module Interface<a class="headerlink" href="#module-interface" title="Permalink to this headline">¶</a></h2>
<p>To serialize an object hierarchy, you first create a pickler, then you call the
pickler&#8217;s <a class="reference internal" href="#pickle.dump" title="pickle.dump"><tt class="xref py py-meth docutils literal"><span class="pre">dump()</span></tt></a> method.  To de-serialize a data stream, you first create
an unpickler, then you call the unpickler&#8217;s <a class="reference internal" href="#pickle.load" title="pickle.load"><tt class="xref py py-meth docutils literal"><span class="pre">load()</span></tt></a> method.  The
<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module provides the following constant:</p>
<dl class="data">
<dt id="pickle.HIGHEST_PROTOCOL">
<tt class="descclassname">pickle.</tt><tt class="descname">HIGHEST_PROTOCOL</tt><a class="headerlink" href="#pickle.HIGHEST_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd><p>The highest protocol version available.  This value can be passed as a
<em>protocol</em> value.</p>
</dd></dl>

<dl class="data">
<dt id="pickle.DEFAULT_PROTOCOL">
<tt class="descclassname">pickle.</tt><tt class="descname">DEFAULT_PROTOCOL</tt><a class="headerlink" href="#pickle.DEFAULT_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd><p>The default protocol used for pickling.  May be less than HIGHEST_PROTOCOL.
Currently the default protocol is 3; a backward-incompatible protocol
designed for Python 3.0.</p>
</dd></dl>

<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module provides the following functions to make the pickling
process more convenient:</p>
<dl class="function">
<dt id="pickle.dump">
<tt class="descclassname">pickle.</tt><tt class="descname">dump</tt><big>(</big><em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>*</em>, <em>fix_imports=True</em><big>)</big><a class="headerlink" href="#pickle.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pickled representation of <em>obj</em> to the open <a class="reference internal" href="../glossary.html#term-file-object"><em class="xref std std-term">file object</em></a> <em>file</em>.
This is equivalent to <tt class="docutils literal"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></tt>.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
<p>The <em>file</em> argument must have a write() method that accepts a single bytes
argument.  It can thus be an on-disk file opened for binary writing, a
<a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><tt class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></tt></a> instance, or any other custom object that meets this
interface.</p>
<p>If <em>fix_imports</em> is True and <em>protocol</em> is less than 3, pickle will try to
map the new Python 3.x names to the old module names used in Python 2.x,
so that the pickle data stream is readable with Python 2.x.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.dumps">
<tt class="descclassname">pickle.</tt><tt class="descname">dumps</tt><big>(</big><em>obj</em>, <em>protocol=None</em>, <em>*</em>, <em>fix_imports=True</em><big>)</big><a class="headerlink" href="#pickle.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pickled representation of the object as a <a class="reference internal" href="functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>
object, instead of writing it to a file.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
<p>If <em>fix_imports</em> is True and <em>protocol</em> is less than 3, pickle will try to
map the new Python 3.x names to the old module names used in Python 2.x,
so that the pickle data stream is readable with Python 2.x.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.load">
<tt class="descclassname">pickle.</tt><tt class="descname">load</tt><big>(</big><em>file</em>, <em>*</em>, <em>fix_imports=True</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><big>)</big><a class="headerlink" href="#pickle.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object representation from the open <a class="reference internal" href="../glossary.html#term-file-object"><em class="xref std std-term">file object</em></a> <em>file</em>
and return the reconstituted object hierarchy specified therein.  This is
equivalent to <tt class="docutils literal"><span class="pre">Unpickler(file).load()</span></tt>.</p>
<p>The protocol version of the pickle is detected automatically, so no protocol
argument is needed.  Bytes past the pickled object&#8217;s representation are
ignored.</p>
<p>The argument <em>file</em> must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus <em>file</em> can be an on-disk file opened
for binary reading, a <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><tt class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></tt></a> object, or any other custom object
that meets this interface.</p>
<p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>,
which are used to control compatibility support for pickle stream generated
by Python 2.x.  If <em>fix_imports</em> is True, pickle will try to map the old
Python 2.x names to the new names used in Python 3.x.  The <em>encoding</em> and
<em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python
2.x; these default to &#8216;ASCII&#8217; and &#8216;strict&#8217;, respectively.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.loads">
<tt class="descclassname">pickle.</tt><tt class="descname">loads</tt><big>(</big><em>bytes_object</em>, <em>*</em>, <em>fix_imports=True</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><big>)</big><a class="headerlink" href="#pickle.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object hierarchy from a <a class="reference internal" href="functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> object and return the
reconstituted object hierarchy specified therein</p>
<p>The protocol version of the pickle is detected automatically, so no protocol
argument is needed.  Bytes past the pickled object&#8217;s representation are
ignored.</p>
<p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>,
which are used to control compatibility support for pickle stream generated
by Python 2.x.  If <em>fix_imports</em> is True, pickle will try to map the old
Python 2.x names to the new names used in Python 3.x.  The <em>encoding</em> and
<em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python
2.x; these default to &#8216;ASCII&#8217; and &#8216;strict&#8217;, respectively.</p>
</dd></dl>

<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module defines three exceptions:</p>
<dl class="exception">
<dt id="pickle.PickleError">
<em class="property">exception </em><tt class="descclassname">pickle.</tt><tt class="descname">PickleError</tt><a class="headerlink" href="#pickle.PickleError" title="Permalink to this definition">¶</a></dt>
<dd><p>Common base class for the other pickling exceptions.  It inherits
<a class="reference internal" href="exceptions.html#Exception" title="Exception"><tt class="xref py py-exc docutils literal"><span class="pre">Exception</span></tt></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="pickle.PicklingError">
<em class="property">exception </em><tt class="descclassname">pickle.</tt><tt class="descname">PicklingError</tt><a class="headerlink" href="#pickle.PicklingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error raised when an unpicklable object is encountered by <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><tt class="xref py py-class docutils literal"><span class="pre">Pickler</span></tt></a>.
It inherits <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><tt class="xref py py-exc docutils literal"><span class="pre">PickleError</span></tt></a>.</p>
<p>Refer to <a class="reference internal" href="#pickle-picklable"><em>What can be pickled and unpickled?</em></a> to learn what kinds of objects can be
pickled.</p>
</dd></dl>

<dl class="exception">
<dt id="pickle.UnpicklingError">
<em class="property">exception </em><tt class="descclassname">pickle.</tt><tt class="descname">UnpicklingError</tt><a class="headerlink" href="#pickle.UnpicklingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error raised when there a problem unpickling an object, such as a data
corruption or a security violation.  It inherits <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><tt class="xref py py-exc docutils literal"><span class="pre">PickleError</span></tt></a>.</p>
<p>Note that other exceptions may also be raised during unpickling, including
(but not necessarily limited to) AttributeError, EOFError, ImportError, and
IndexError.</p>
</dd></dl>

<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module exports two classes, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><tt class="xref py py-class docutils literal"><span class="pre">Pickler</span></tt></a> and
<a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><tt class="xref py py-class docutils literal"><span class="pre">Unpickler</span></tt></a>:</p>
<dl class="class">
<dt id="pickle.Pickler">
<em class="property">class </em><tt class="descclassname">pickle.</tt><tt class="descname">Pickler</tt><big>(</big><em>file</em>, <em>protocol=None</em>, <em>*</em>, <em>fix_imports=True</em><big>)</big><a class="headerlink" href="#pickle.Pickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a binary file for writing a pickle data stream.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
<p>The <em>file</em> argument must have a write() method that accepts a single bytes
argument.  It can thus be an on-disk file opened for binary writing, a
<a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><tt class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></tt></a> instance, or any other custom object that meets this interface.</p>
<p>If <em>fix_imports</em> is True and <em>protocol</em> is less than 3, pickle will try to
map the new Python 3.x names to the old module names used in Python 2.x,
so that the pickle data stream is readable with Python 2.x.</p>
<dl class="method">
<dt id="pickle.Pickler.dump">
<tt class="descname">dump</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pickle.Pickler.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pickled representation of <em>obj</em> to the open file object given in
the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.persistent_id">
<tt class="descname">persistent_id</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pickle.Pickler.persistent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing by default.  This exists so a subclass can override it.</p>
<p>If <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><tt class="xref py py-meth docutils literal"><span class="pre">persistent_id()</span></tt></a> returns <tt class="xref docutils literal"><span class="pre">None</span></tt>, <em>obj</em> is pickled as usual.  Any
other value causes <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><tt class="xref py py-class docutils literal"><span class="pre">Pickler</span></tt></a> to emit the returned value as a
persistent ID for <em>obj</em>.  The meaning of this persistent ID should be
defined by <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><tt class="xref py py-meth docutils literal"><span class="pre">Unpickler.persistent_load()</span></tt></a>.  Note that the value
returned by <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><tt class="xref py py-meth docutils literal"><span class="pre">persistent_id()</span></tt></a> cannot itself have a persistent ID.</p>
<p>See <a class="reference internal" href="#pickle-persistent"><em>Persistence of External Objects</em></a> for details and examples of uses.</p>
</dd></dl>

<dl class="attribute">
<dt id="pickle.Pickler.fast">
<tt class="descname">fast</tt><a class="headerlink" href="#pickle.Pickler.fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Enable fast mode if set to a true value.  The fast mode
disables the usage of memo, therefore speeding the pickling process by not
generating superfluous PUT opcodes.  It should not be used with
self-referential objects, doing otherwise will cause <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><tt class="xref py py-class docutils literal"><span class="pre">Pickler</span></tt></a> to
recurse infinitely.</p>
<p>Use <a class="reference internal" href="pickletools.html#pickletools.optimize" title="pickletools.optimize"><tt class="xref py py-func docutils literal"><span class="pre">pickletools.optimize()</span></tt></a> if you need more compact pickles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pickle.Unpickler">
<em class="property">class </em><tt class="descclassname">pickle.</tt><tt class="descname">Unpickler</tt><big>(</big><em>file</em>, <em>*</em>, <em>fix_imports=True</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><big>)</big><a class="headerlink" href="#pickle.Unpickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a binary file for reading a pickle data stream.</p>
<p>The protocol version of the pickle is detected automatically, so no
protocol argument is needed.</p>
<p>The argument <em>file</em> must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus <em>file</em> can be an on-disk file object opened
for binary reading, a <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><tt class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></tt></a> object, or any other custom object
that meets this interface.</p>
<p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>,
which are used to control compatibility support for pickle stream generated
by Python 2.x.  If <em>fix_imports</em> is True, pickle will try to map the old
Python 2.x names to the new names used in Python 3.x.  The <em>encoding</em> and
<em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python
2.x; these default to &#8216;ASCII&#8217; and &#8216;strict&#8217;, respectively.</p>
<dl class="method">
<dt id="pickle.Unpickler.load">
<tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Unpickler.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object representation from the open file object given in
the constructor, and return the reconstituted object hierarchy specified
therein.  Bytes past the pickled object&#8217;s representation are ignored.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.persistent_load">
<tt class="descname">persistent_load</tt><big>(</big><em>pid</em><big>)</big><a class="headerlink" href="#pickle.Unpickler.persistent_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an <tt class="xref py py-exc docutils literal"><span class="pre">UnpickingError</span></tt> by default.</p>
<p>If defined, <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><tt class="xref py py-meth docutils literal"><span class="pre">persistent_load()</span></tt></a> should return the object specified by
the persistent ID <em>pid</em>.  If an invalid persistent ID is encountered, an
<tt class="xref py py-exc docutils literal"><span class="pre">UnpickingError</span></tt> should be raised.</p>
<p>See <a class="reference internal" href="#pickle-persistent"><em>Persistence of External Objects</em></a> for details and examples of uses.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.find_class">
<tt class="descname">find_class</tt><big>(</big><em>module</em>, <em>name</em><big>)</big><a class="headerlink" href="#pickle.Unpickler.find_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Import <em>module</em> if necessary and return the object called <em>name</em> from it,
where the <em>module</em> and <em>name</em> arguments are <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> objects.  Note,
unlike its name suggests, <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><tt class="xref py py-meth docutils literal"><span class="pre">find_class()</span></tt></a> is also used for finding
functions.</p>
<p>Subclasses may override this to gain control over what type of objects and
how they can be loaded, potentially reducing security risks. Refer to
<a class="reference internal" href="#pickle-restrict"><em>Restricting Globals</em></a> for details.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-can-be-pickled-and-unpickled">
<span id="pickle-picklable"></span><h2>11.1.4. What can be pickled and unpickled?<a class="headerlink" href="#what-can-be-pickled-and-unpickled" title="Permalink to this headline">¶</a></h2>
<p>The following types can be pickled:</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="xref docutils literal"><span class="pre">True</span></tt>, and <tt class="xref docutils literal"><span class="pre">False</span></tt></li>
<li>integers, floating point numbers, complex numbers</li>
<li>strings, bytes, bytearrays</li>
<li>tuples, lists, sets, and dictionaries containing only picklable objects</li>
<li>functions defined at the top level of a module</li>
<li>built-in functions defined at the top level of a module</li>
<li>classes that are defined at the top level of a module</li>
<li>instances of such classes whose <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt> is
picklable  (see section <a class="reference internal" href="#pickle-inst"><em>Pickling Class Instances</em></a> for details)</li>
</ul>
<p>Attempts to pickle unpicklable objects will raise the <a class="reference internal" href="#pickle.PicklingError" title="pickle.PicklingError"><tt class="xref py py-exc docutils literal"><span class="pre">PicklingError</span></tt></a>
exception; when this happens, an unspecified number of bytes may have already
been written to the underlying file.  Trying to pickle a highly recursive data
structure may exceed the maximum recursion depth, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> will be
raised in this case.  You can carefully raise this limit with
<a class="reference internal" href="sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><tt class="xref py py-func docutils literal"><span class="pre">sys.setrecursionlimit()</span></tt></a>.</p>
<p>Note that functions (built-in and user-defined) are pickled by &#8220;fully qualified&#8221;
name reference, not by value.  This means that only the function name is
pickled, along with the name of module the function is defined in.  Neither the
function&#8217;s code, nor any of its function attributes are pickled.  Thus the
defining module must be importable in the unpickling environment, and the module
must contain the named object, otherwise an exception will be raised. <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>Similarly, classes are pickled by named reference, so the same restrictions in
the unpickling environment apply.  Note that none of the class&#8217;s code or data is
pickled, so in the following example the class attribute <tt class="docutils literal"><span class="pre">attr</span></tt> is not
restored in the unpickling environment:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s">&#39;A class attribute&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p>These restrictions are why picklable functions and classes must be defined in
the top level of a module.</p>
<p>Similarly, when class instances are pickled, their class&#8217;s code and data are not
pickled along with them.  Only the instance data are pickled.  This is done on
purpose, so you can fix bugs in a class or add methods to the class and still
load objects that were created with an earlier version of the class.  If you
plan to have long-lived objects that will see many versions of a class, it may
be worthwhile to put a version number in the objects so that suitable
conversions can be made by the class&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt> method.</p>
</div>
<div class="section" id="pickling-class-instances">
<span id="pickle-inst"></span><h2>11.1.5. Pickling Class Instances<a class="headerlink" href="#pickling-class-instances" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the general mechanisms available to you to define,
customize, and control how class instances are pickled and unpickled.</p>
<p>In most cases, no additional code is needed to make instances picklable.  By
default, pickle will retrieve the class and the attributes of an instance via
introspection. When a class instance is unpickled, its <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> method
is usually <em>not</em> invoked.  The default behaviour first creates an uninitialized
instance and then restores the saved attributes.  The following code shows an
implementation of this behaviour:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>
</pre></div>
</div>
<p>Classes can alter the default behaviour by providing one or several special
methods:</p>
<dl class="method">
<dt id="pickle.object.__getnewargs__">
<tt class="descclassname">object.</tt><tt class="descname">__getnewargs__</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.object.__getnewargs__" title="Permalink to this definition">¶</a></dt>
<dd><p>In protocol 2 and newer, classes that implements the <a class="reference internal" href="#pickle.object.__getnewargs__" title="pickle.object.__getnewargs__"><tt class="xref py py-meth docutils literal"><span class="pre">__getnewargs__()</span></tt></a>
method can dictate the values passed to the <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a> method upon
unpickling.  This is often needed for classes whose <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a> method
requires arguments.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.object.__getstate__">
<tt class="descclassname">object.</tt><tt class="descname">__getstate__</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.object.__getstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Classes can further influence how their instances are pickled; if the class
defines the method <a class="reference internal" href="#pickle.object.__getstate__" title="pickle.object.__getstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt></a>, it is called and the returned object
is pickled as the contents for the instance, instead of the contents of the
instance&#8217;s dictionary.  If the <a class="reference internal" href="#pickle.object.__getstate__" title="pickle.object.__getstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt></a> method is absent, the
instance&#8217;s <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt></a> is pickled as usual.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.object.__setstate__">
<tt class="descclassname">object.</tt><tt class="descname">__setstate__</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#pickle.object.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon unpickling, if the class defines <a class="reference internal" href="#pickle.object.__setstate__" title="pickle.object.__setstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt></a>, it is called with
the unpickled state.  In that case, there is no requirement for the state
object to be a dictionary.  Otherwise, the pickled state must be a dictionary
and its items are assigned to the new instance&#8217;s dictionary.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <a class="reference internal" href="#pickle.object.__getstate__" title="pickle.object.__getstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt></a> returns a false value, the <a class="reference internal" href="#pickle.object.__setstate__" title="pickle.object.__setstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt></a>
method will not be called upon unpickling.</p>
</div>
</dd></dl>

<p>Refer to the section <a class="reference internal" href="#pickle-state"><em>Handling Stateful Objects</em></a> for more information about how to use
the methods <tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At unpickling time, some methods like <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a>,
<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a>, or <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt></a> may be called upon the
instance.  In case those methods rely on some internal invariant being true,
the type should implement <tt class="xref py py-meth docutils literal"><span class="pre">__getnewargs__()</span></tt> to establish such an
invariant; otherwise, neither <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a> nor <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> will be
called.</p>
</div>
<p id="index-3">As we shall see, pickle does not use directly the methods described above.  In
fact, these methods are part of the copy protocol which implements the
<tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt> special method.  The copy protocol provides a unified
interface for retrieving the data necessary for pickling and copying
objects. <a class="footnote-reference" href="#id7" id="id3">[3]</a></p>
<p>Although powerful, implementing <tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt> directly in your classes is
error prone.  For this reason, class designers should use the high-level
interface (i.e., <tt class="xref py py-meth docutils literal"><span class="pre">__getnewargs__()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt>) whenever possible.  We will show, however, cases where
using <tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt> is the only option or leads to more efficient pickling
or both.</p>
<dl class="method">
<dt id="pickle.object.__reduce__">
<tt class="descclassname">object.</tt><tt class="descname">__reduce__</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.object.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>The interface is currently defined as follows.  The <a class="reference internal" href="#pickle.object.__reduce__" title="pickle.object.__reduce__"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt></a> method
takes no argument and shall return either a string or preferably a tuple (the
returned object is often referred to as the &#8220;reduce value&#8221;).</p>
<p>If a string is returned, the string should be interpreted as the name of a
global variable.  It should be the object&#8217;s local name relative to its
module; the pickle module searches the module namespace to determine the
object&#8217;s module.  This behaviour is typically useful for singletons.</p>
<p>When a tuple is returned, it must be between two and five items long.
Optional items can either be omitted, or <tt class="xref docutils literal"><span class="pre">None</span></tt> can be provided as their
value.  The semantics of each item are in order:</p>
<ul class="simple">
<li>A callable object that will be called to create the initial version of the
object.</li>
<li>A tuple of arguments for the callable object.  An empty tuple must be given
if the callable does not accept any argument.</li>
<li>Optionally, the object&#8217;s state, which will be passed to the object&#8217;s
<a class="reference internal" href="#pickle.object.__setstate__" title="pickle.object.__setstate__"><tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt></a> method as previously described.  If the object has no
such method then, the value must be a dictionary and it will be added to
the object&#8217;s <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt></a> attribute.</li>
<li>Optionally, an iterator (and not a sequence) yielding successive items.
These items will be appended to the object either using
<tt class="docutils literal"><span class="pre">obj.append(item)</span></tt> or, in batch, using <tt class="docutils literal"><span class="pre">obj.extend(list_of_items)</span></tt>.
This is primarily used for list subclasses, but may be used by other
classes as long as they have <tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">extend()</span></tt> methods with
the appropriate signature.  (Whether <tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">extend()</span></tt> is
used depends on which pickle protocol version is used as well as the number
of items to append, so both must be supported.)</li>
<li>Optionally, an iterator (not a sequence) yielding successive key-value
pairs.  These items will be stored to the object using <tt class="docutils literal"><span class="pre">obj[key]</span> <span class="pre">=</span>
<span class="pre">value</span></tt>.  This is primarily used for dictionary subclasses, but may be used
by other classes as long as they implement <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></tt></a>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pickle.object.__reduce_ex__">
<tt class="descclassname">object.</tt><tt class="descname">__reduce_ex__</tt><big>(</big><em>protocol</em><big>)</big><a class="headerlink" href="#pickle.object.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternatively, a <a class="reference internal" href="#pickle.object.__reduce_ex__" title="pickle.object.__reduce_ex__"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce_ex__()</span></tt></a> method may be defined.  The only
difference is this method should take a single integer argument, the protocol
version.  When defined, pickle will prefer it over the <a class="reference internal" href="#pickle.object.__reduce__" title="pickle.object.__reduce__"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt></a>
method.  In addition, <a class="reference internal" href="#pickle.object.__reduce__" title="pickle.object.__reduce__"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></tt></a> automatically becomes a synonym for
the extended version.  The main use for this method is to provide
backwards-compatible reduce values for older Python releases.</p>
</dd></dl>

<div class="section" id="persistence-of-external-objects">
<span id="pickle-persistent"></span><h3>11.1.5.1. Persistence of External Objects<a class="headerlink" href="#persistence-of-external-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-4">For the benefit of object persistence, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a persistent ID, which should be either a string of
alphanumeric characters (for protocol 0) <a class="footnote-reference" href="#id8" id="id4">[4]</a> or just an arbitrary object (for
any newer protocol).</p>
<p>The resolution of such persistent IDs is not defined by the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a>
module; it will delegate this resolution to the user defined methods on the
pickler and unpickler, <tt class="xref py py-meth docutils literal"><span class="pre">persistent_id()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">persistent_load()</span></tt>
respectively.</p>
<p>To pickle objects that have an external persistent id, the pickler must have a
custom <tt class="xref py py-meth docutils literal"><span class="pre">persistent_id()</span></tt> method that takes an object as an argument and
returns either <tt class="xref docutils literal"><span class="pre">None</span></tt> or the persistent id for that object.  When <tt class="xref docutils literal"><span class="pre">None</span></tt> is
returned, the pickler simply pickles the object as normal.  When a persistent ID
string is returned, the pickler will pickle that object, along with a marker so
that the unpickler will recognize it as a persistent ID.</p>
<p>To unpickle external objects, the unpickler must have a custom
<tt class="xref py py-meth docutils literal"><span class="pre">persistent_load()</span></tt> method that takes a persistent ID object and returns the
referenced object.</p>
<p>Here is a comprehensive example presenting how persistent ID can be used to
pickle external objects by reference.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="c"># Simple example presenting how persistent ID can be used to pickle</span>
<span class="c"># external objects by reference.</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>

<span class="c"># Simple class representing a record in our database.</span>
<span class="n">MemoRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="s">&quot;key, task&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">persistent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c"># Instead of pickling MemoRecord as a regular class instance, we emit a</span>
        <span class="c"># persistent ID.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MemoRecord</span><span class="p">):</span>
            <span class="c"># Here, our persistent ID is simply a tuple, containing a tag and a</span>
            <span class="c"># key, which refers to a specific record in the database.</span>
            <span class="k">return</span> <span class="p">(</span><span class="s">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If obj does not have a persistent ID, return None. This means obj</span>
            <span class="c"># needs to be pickled as usual.</span>
            <span class="k">return</span> <span class="k">None</span>


<span class="k">class</span> <span class="nc">DBUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">persistent_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c"># This method is invoked whenever a persistent ID is encountered.</span>
        <span class="c"># Here, pid is the tuple returned by DBPickler.</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">type_tag</span><span class="p">,</span> <span class="n">key_id</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="k">if</span> <span class="n">type_tag</span> <span class="o">==</span> <span class="s">&quot;MemoRecord&quot;</span><span class="p">:</span>
            <span class="c"># Fetch the referenced record from the database and return it.</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;SELECT * FROM memos WHERE key=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key_id</span><span class="p">),))</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Always raises an error if you cannot return the correct object.</span>
            <span class="c"># Otherwise, the unpickler will think None is the object referenced</span>
            <span class="c"># by the persistent ID.</span>
            <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s">&quot;unsupported persistent object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">io</span><span class="o">,</span> <span class="nn">pprint</span>

    <span class="c"># Initialize and populate our database.</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;:memory:&quot;</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)&quot;</span><span class="p">)</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&#39;give food to fish&#39;</span><span class="p">,</span>
        <span class="s">&#39;prepare group meeting&#39;</span><span class="p">,</span>
        <span class="s">&#39;fight with a zebra&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;INSERT INTO memos VALUES(NULL, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

    <span class="c"># Fetch the records to be pickled.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;SELECT * FROM memos&quot;</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="p">[</span><span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">]</span>
    <span class="c"># Save the records using our custom DBPickler.</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">DBPickler</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Pickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="c"># Update a record, just for good measure.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;UPDATE memos SET task=&#39;learn italian&#39; WHERE key=1&quot;</span><span class="p">)</span>

    <span class="c"># Load the records from the pickle data stream.</span>
    <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="n">DBUnpickler</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Unpickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="handling-stateful-objects">
<span id="pickle-state"></span><h3>11.1.5.2. Handling Stateful Objects<a class="headerlink" href="#handling-stateful-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-5">Here&#8217;s an example that shows how to modify pickling behavior for a class.
The <tt class="xref py py-class docutils literal"><span class="pre">TextReader</span></tt> class opens a text file, and returns the line number and
line contents each time its <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> method is called. If a
<tt class="xref py py-class docutils literal"><span class="pre">TextReader</span></tt> instance is pickled, all attributes <em>except</em> the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The <tt class="xref py py-meth docutils literal"><span class="pre">__setstate__()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">__getstate__()</span></tt> methods are used to implement this behavior.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TextReader</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Print and number lines in a text file.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">None</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s">&quot;%i: %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Copy the object&#39;s state from self.__dict__ which contains</span>
        <span class="c"># all our instance attributes. Always use the dict.copy()</span>
        <span class="c"># method to avoid modifying the original state.</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># Remove the unpicklable entries.</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s">&#39;file&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c"># Restore instance attributes (i.e., filename and lineno).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c"># Restore the previously opened file&#39;s state. To do so, we need to</span>
        <span class="c"># reopen it and read from it until the line count is restored.</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">):</span>
            <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c"># Finally, save the file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
</pre></div>
</div>
<p>A sample usage might be something like this:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">TextReader</span><span class="p">(</span><span class="s">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: Hello world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: I am line number two.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: Goodbye!&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="restricting-globals">
<span id="pickle-restrict"></span><h2>11.1.6. Restricting Globals<a class="headerlink" href="#restricting-globals" title="Permalink to this headline">¶</a></h2>
<p id="index-6">By default, unpickling will import any class or function that it finds in the
pickle data.  For many applications, this behaviour is unacceptable as it
permits the unpickler to import and invoke arbitrary code.  Just consider what
this hand-crafted pickle data stream does when loaded:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;cos</span><span class="se">\n</span><span class="s">system</span><span class="se">\n</span><span class="s">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s">tR.&quot;</span><span class="p">)</span>
<span class="go">hello world</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In this example, the unpickler imports the <a class="reference internal" href="os.html#os.system" title="os.system"><tt class="xref py py-func docutils literal"><span class="pre">os.system()</span></tt></a> function and then
apply the string argument &#8220;echo hello world&#8221;.  Although this example is
inoffensive, it is not difficult to imagine one that could damage your system.</p>
<p>For this reason, you may want to control what gets unpickled by customizing
<a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><tt class="xref py py-meth docutils literal"><span class="pre">Unpickler.find_class()</span></tt></a>.  Unlike its name suggests, <tt class="xref py py-meth docutils literal"><span class="pre">find_class()</span></tt> is
called whenever a global (i.e., a class or a function) is requested.  Thus it is
possible to either forbid completely globals or restrict them to a safe subset.</p>
<p>Here is an example of an unpickler allowing only few safe classes from the
<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><tt class="xref py py-mod docutils literal"><span class="pre">builtins</span></tt></a> module to be loaded:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;range&#39;</span><span class="p">,</span>
    <span class="s">&#39;complex&#39;</span><span class="p">,</span>
    <span class="s">&#39;set&#39;</span><span class="p">,</span>
    <span class="s">&#39;frozenset&#39;</span><span class="p">,</span>
    <span class="s">&#39;slice&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c"># Only allow safe classes from builtins.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s">&quot;builtins&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c"># Forbid everything else.</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s">&quot;global &#39;%s.%s&#39; is forbidden&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
<p>A sample usage of our unpickler working has intended:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]))</span>
<span class="go">[1, 2, range(0, 15)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;cos</span><span class="se">\n</span><span class="s">system</span><span class="se">\n</span><span class="s">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s">tR.&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">pickle.UnpicklingError</span>: <span class="n-Identifier">global &#39;os.system&#39; is forbidden</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;cbuiltins</span><span class="se">\n</span><span class="s">eval</span><span class="se">\n</span><span class="s">&#39;</span>
<span class="gp">... </span>                 <span class="n">b</span><span class="s">&#39;(S</span><span class="se">\&#39;</span><span class="s">getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;</span>
<span class="gp">... </span>                 <span class="n">b</span><span class="s">&#39;(&quot;echo hello world&quot;)</span><span class="se">\&#39;\n</span><span class="s">tR.&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">pickle.UnpicklingError</span>: <span class="n-Identifier">global &#39;builtins.eval&#39; is forbidden</span>
</pre></div>
</div>
<p>As our examples shows, you have to be careful with what you allow to be
unpickled.  Therefore if security is a concern, you may want to consider
alternatives such as the marshalling API in <a class="reference internal" href="xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><tt class="xref py py-mod docutils literal"><span class="pre">xmlrpc.client</span></tt></a> or
third-party solutions.</p>
</div>
<div class="section" id="examples">
<span id="pickle-example"></span><h2>11.1.7. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>For the simplest code, use the <a class="reference internal" href="#pickle.dump" title="pickle.dump"><tt class="xref py py-func docutils literal"><span class="pre">dump()</span></tt></a> and <a class="reference internal" href="#pickle.load" title="pickle.load"><tt class="xref py py-func docutils literal"><span class="pre">load()</span></tt></a> functions.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pickle</span>

<span class="c"># An arbitrary collection of objects supported by pickle.</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">],</span>
    <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;character string&quot;</span><span class="p">,</span> <span class="n">b</span><span class="s">&quot;byte string&quot;</span><span class="p">),</span>
    <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="k">None</span><span class="p">,</span> <span class="k">True</span><span class="p">,</span> <span class="k">False</span><span class="p">])</span>
<span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c"># Pickle the &#39;data&#39; dictionary using the highest protocol available.</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
</pre></div>
</div>
<p>The following example reads the resulting pickled data.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c"># The protocol version used is detected automatically, so we do not</span>
    <span class="c"># have to specify it.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Module <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><tt class="xref py py-mod docutils literal"><span class="pre">copyreg</span></tt></a></dt>
<dd>Pickle interface constructor registration for extension types.</dd>
<dt>Module <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><tt class="xref py py-mod docutils literal"><span class="pre">pickletools</span></tt></a></dt>
<dd>Tools for working with and analyzing pickled data.</dd>
<dt>Module <a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><tt class="xref py py-mod docutils literal"><span class="pre">shelve</span></tt></a></dt>
<dd>Indexed databases of objects; uses <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a>.</dd>
<dt>Module <a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><tt class="xref py py-mod docutils literal"><span class="pre">copy</span></tt></a></dt>
<dd>Shallow and deep object copying.</dd>
<dt>Module <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a></dt>
<dd>High-performance serialization of built-in types.</dd>
</dl>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Don&#8217;t confuse this with the <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> module</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The exception raised will likely be an <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> or an
<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> but it could be something else.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The <a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><tt class="xref py py-mod docutils literal"><span class="pre">copy</span></tt></a> module uses this protocol for shallow and deep copying
operations.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>The limitation on alphanumeric characters is due to the fact
the persistent IDs, in protocol 0, are delimited by the newline
character.  Therefore if any kind of newline characters occurs in
persistent IDs, the resulting pickle will become unreadable.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">11.1. <tt class="docutils literal"><span class="pre">pickle</span></tt> &#8212; Python object serialization</a><ul>
<li><a class="reference internal" href="#relationship-to-other-python-modules">11.1.1. Relationship to other Python modules</a></li>
<li><a class="reference internal" href="#data-stream-format">11.1.2. Data stream format</a></li>
<li><a class="reference internal" href="#module-interface">11.1.3. Module Interface</a></li>
<li><a class="reference internal" href="#what-can-be-pickled-and-unpickled">11.1.4. What can be pickled and unpickled?</a></li>
<li><a class="reference internal" href="#pickling-class-instances">11.1.5. Pickling Class Instances</a><ul>
<li><a class="reference internal" href="#persistence-of-external-objects">11.1.5.1. Persistence of External Objects</a></li>
<li><a class="reference internal" href="#handling-stateful-objects">11.1.5.2. Handling Stateful Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#restricting-globals">11.1.6. Restricting Globals</a></li>
<li><a class="reference internal" href="#examples">11.1.7. Examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="persistence.html"
                        title="previous chapter">11. Data Persistence</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="copyreg.html"
                        title="next chapter">11.2. <tt class="docutils literal docutils literal"><span class="pre">copyreg</span></tt> &#8212; Register <tt class="docutils literal docutils literal"><span class="pre">pickle</span></tt> support functions</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/pickle.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="11.2. copyreg — Register pickle support functions"
             >next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="11. Data Persistence"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" >11. Data Persistence</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 27, 2011.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>