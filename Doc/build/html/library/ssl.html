

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.3. ssl — TLS/SSL wrapper for socket objects &mdash; Python v3.2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.2 documentation" href="../index.html" />
    <link rel="up" title="17. Interprocess Communication and Networking" href="ipc.html" />
    <link rel="next" title="17.4. signal — Set handlers for asynchronous events" href="signal.html" />
    <link rel="prev" title="17.2. socket — Low-level networking interface" href="socket.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — Set handlers for asynchronous events"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — Low-level networking interface"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" accesskey="U">17. Interprocess Communication and Networking</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1>17.3. <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><tt class="xref py py-mod docutils literal"><span class="pre">ssl</span></tt></a> &#8212; TLS/SSL wrapper for socket objects<a class="headerlink" href="#module-ssl" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1"><strong>Source code:</strong> <a class="reference external" href="http://svn.python.org/view/python/branches/py3k/Lib/ssl.py?view=markup">Lib/ssl.py</a></p>
<hr class="docutils" />
<p>This module provides access to Transport Layer Security (often known as &#8220;Secure
Sockets Layer&#8221;) encryption and peer authentication facilities for network
sockets, both client-side and server-side.  This module uses the OpenSSL
library. It is available on all modern Unix systems, Windows, Mac OS X, and
probably additional platforms, as long as OpenSSL is installed on that platform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some behavior may be platform dependent, since calls are made to the
operating system socket APIs.  The installed version of OpenSSL may also
cause variations in behavior.</p>
</div>
<p>This section documents the objects and functions in the <tt class="docutils literal"><span class="pre">ssl</span></tt> module; for more
general information about TLS, SSL, and certificates, the reader is referred to
the documents in the &#8220;See Also&#8221; section at the bottom.</p>
<p>This module provides a class, <tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></tt>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional methods such as <tt class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></tt>, which retrieves the
certificate of the other side of the connection, and <tt class="xref py py-meth docutils literal"><span class="pre">cipher()</span></tt>,which
retrieves the cipher being used for the secure connection.</p>
<p>For more sophisticated applications, the <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></tt></a> class
helps manage settings and certificates, which can then be inherited
by SSL sockets created through the <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></tt></a> method.</p>
<div class="section" id="functions-constants-and-exceptions">
<h2>17.3.1. Functions, Constants, and Exceptions<a class="headerlink" href="#functions-constants-and-exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><tt class="descclassname">ssl.</tt><tt class="descname">SSLError</tt><a class="headerlink" href="#ssl.SSLError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised to signal an error from the underlying SSL implementation
(currently provided by the OpenSSL library).  This signifies some
problem in the higher-level encryption and authentication layer that&#8217;s
superimposed on the underlying network connection.  This error
is a subtype of <a class="reference internal" href="socket.html#socket.error" title="socket.error"><tt class="xref py py-exc docutils literal"><span class="pre">socket.error</span></tt></a>, which in turn is a subtype of
<a class="reference internal" href="exceptions.html#IOError" title="IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a>.  The error code and message of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a> instances
are provided by the OpenSSL library.</p>
</dd></dl>

<dl class="exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><tt class="descclassname">ssl.</tt><tt class="descname">CertificateError</tt><a class="headerlink" href="#ssl.CertificateError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised to signal an error with a certificate (such as mismatching
hostname).  Certificate errors detected by OpenSSL, though, raise
an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a>.</p>
</dd></dl>

<div class="section" id="socket-creation">
<h3>17.3.1.1. Socket creation<a class="headerlink" href="#socket-creation" title="Permalink to this headline">¶</a></h3>
<p>The following function allows for standalone socket creation.  Starting from
Python 3.2, it can be more flexible to use <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></tt></a>
instead.</p>
<dl class="function">
<dt id="ssl.wrap_socket">
<tt class="descclassname">ssl.</tt><tt class="descname">wrap_socket</tt><big>(</big><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version={see docs}</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><big>)</big><a class="headerlink" href="#ssl.wrap_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an instance <tt class="docutils literal"><span class="pre">sock</span></tt> of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a>, and returns an instance
of <tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></tt>, a subtype of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a>, which wraps
the underlying socket in an SSL context.  For client-side sockets, the
context construction is lazy; if the underlying socket isn&#8217;t connected yet,
the context construction will be performed after <tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt> is called on
the socket.  For server-side sockets, if the socket has no remote peer, it is
assumed to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the <tt class="xref py py-meth docutils literal"><span class="pre">accept()</span></tt>
method.  <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">keyfile</span></tt> and <tt class="docutils literal"><span class="pre">certfile</span></tt> parameters specify optional files which
contain a certificate to be used to identify the local side of the
connection.  See the discussion of <a class="reference internal" href="#ssl-certificates"><em>Certificates</em></a> for more
information on how the certificate is stored in the <tt class="docutils literal"><span class="pre">certfile</span></tt>.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">server_side</span></tt> is a boolean which identifies whether
server-side or client-side behavior is desired from this socket.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">cert_reqs</span></tt> specifies whether a certificate is required from
the other side of the connection, and whether it will be validated if
provided.  It must be one of the three values <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a>
(certificates ignored), <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> (not required, but validated
if provided), or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a> (required and validated).  If the
value of this parameter is not <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a>, then the <tt class="docutils literal"><span class="pre">ca_certs</span></tt>
parameter must point to a file of CA certificates.</p>
<p>The <tt class="docutils literal"><span class="pre">ca_certs</span></tt> file contains a set of concatenated &#8220;certification
authority&#8221; certificates, which are used to validate certificates passed from
the other end of the connection.  See the discussion of
<a class="reference internal" href="#ssl-certificates"><em>Certificates</em></a> for more information about how to arrange the
certificates in this file.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">ssl_version</span></tt> specifies which version of the SSL protocol to
use.  Typically, the server chooses a particular protocol version, and the
client must adapt to the server&#8217;s choice.  Most of the versions are not
interoperable with the other versions.  If not specified, for client-side
operation, the default SSL version is SSLv3; for server-side operation,
SSLv23.  These version selections provide the most compatibility with other
versions.</p>
<p>Here&#8217;s a table showing which versions in a client (down the side) can connect
to which versions in a server (along the top):</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="15%" />
<col width="15%" />
<col width="16%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>SSLv23</strong></td>
<td><strong>TLSv1</strong></td>
</tr>
<tr><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>SSLv3</em></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>SSLv23</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Which connections succeed will vary depending on the version of
OpenSSL.  For instance, in some older versions of OpenSSL (such
as 0.9.7l on OS X 10.4), an SSLv2 client could not connect to an
SSLv23 server.  Another example: beginning with OpenSSL 1.0.0,
an SSLv23 client will not actually attempt SSLv2 connections
unless you explicitly enable SSLv2 ciphers; for example, you
might specify <tt class="docutils literal"><span class="pre">&quot;ALL&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;SSLv2&quot;</span></tt> as the <em>ciphers</em> parameter
to enable them.</p>
</div>
<p>The <em>ciphers</em> parameter sets the available ciphers for this SSL object.
It should be a string in the <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format</a>.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">do_handshake_on_connect</span></tt> specifies whether to do the SSL
handshake automatically after doing a <tt class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></tt>, or whether the
application program will call it explicitly, by invoking the
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></tt></a> method.  Calling
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></tt></a> explicitly gives the program control over the
blocking behavior of the socket I/O involved in the handshake.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">suppress_ragged_eofs</span></tt> specifies how the
<tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.recv()</span></tt> method should signal unexpected EOF from the other end
of the connection.  If specified as <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const xref docutils literal"><span class="pre">True</span></tt></a> (the default), it returns a
normal EOF (an empty bytes object) in response to unexpected EOF errors
raised from the underlying socket; if <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const xref docutils literal"><span class="pre">False</span></tt></a>, it will raise the
exceptions back to the caller.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.2: </span>New optional argument <em>ciphers</em>.</p>
</dd></dl>

</div>
<div class="section" id="random-generation">
<h3>17.3.1.2. Random generation<a class="headerlink" href="#random-generation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="ssl.RAND_status">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_status</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.RAND_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the SSL pseudo-random number generator has been seeded with
&#8216;enough&#8217; randomness, and False otherwise.  You can use <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><tt class="xref py py-func docutils literal"><span class="pre">ssl.RAND_egd()</span></tt></a>
and <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><tt class="xref py py-func docutils literal"><span class="pre">ssl.RAND_add()</span></tt></a> to increase the randomness of the pseudo-random
number generator.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_egd</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#ssl.RAND_egd" title="Permalink to this definition">¶</a></dt>
<dd><p>If you are running an entropy-gathering daemon (EGD) somewhere, and <tt class="docutils literal"><span class="pre">path</span></tt>
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.</p>
<p>See <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> or <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> for sources
of entropy-gathering daemons.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_add</tt><big>(</big><em>bytes</em>, <em>entropy</em><big>)</big><a class="headerlink" href="#ssl.RAND_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixes the given <tt class="docutils literal"><span class="pre">bytes</span></tt> into the SSL pseudo-random number generator.  The
parameter <tt class="docutils literal"><span class="pre">entropy</span></tt> (a float) is a lower bound on the entropy contained in
string (so you can always use <tt class="xref py py-const docutils literal"><span class="pre">0.0</span></tt>).  See <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> for more
information on sources of entropy.</p>
</dd></dl>

</div>
<div class="section" id="certificate-handling">
<h3>17.3.1.3. Certificate handling<a class="headerlink" href="#certificate-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="ssl.match_hostname">
<tt class="descclassname">ssl.</tt><tt class="descname">match_hostname</tt><big>(</big><em>cert</em>, <em>hostname</em><big>)</big><a class="headerlink" href="#ssl.match_hostname" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that <em>cert</em> (in decoded format as returned by
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></tt></a>) matches the given <em>hostname</em>.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in <span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2818.html"><strong>RFC 2818</strong></a>, except that IP addresses are not currently supported.
In addition to HTTPS, this function should be suitable for checking the
identity of servers in various SSL-based protocols such as FTPS, IMAPS,
POPS and others.</p>
<p><a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><tt class="xref py py-exc docutils literal"><span class="pre">CertificateError</span></tt></a> is raised on failure. On success, the function
returns nothing:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n-Identifier">match_hostname</span>
<span class="nc">ssl.CertificateError</span>: <span class="n-Identifier">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<tt class="descclassname">ssl.</tt><tt class="descname">cert_time_to_seconds</tt><big>(</big><em>timestring</em><big>)</big><a class="headerlink" href="#ssl.cert_time_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a floating-point value containing a normal seconds-after-the-epoch
time value, given the time-string representing the &#8220;notBefore&#8221; or &#8220;notAfter&#8221;
date from a certificate.</p>
<p>Here&#8217;s an example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">)</span>
<span class="go">1178694000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">))</span>
<span class="go">&#39;Wed May  9 00:00:00 2007&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<tt class="descclassname">ssl.</tt><tt class="descname">get_server_certificate</tt><big>(</big><em>addr</em>, <em>ssl_version=PROTOCOL_SSLv3</em>, <em>ca_certs=None</em><big>)</big><a class="headerlink" href="#ssl.get_server_certificate" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the address <tt class="docutils literal"><span class="pre">addr</span></tt> of an SSL-protected server, as a (<em>hostname</em>,
<em>port-number</em>) pair, fetches the server&#8217;s certificate, and returns it as a
PEM-encoded string.  If <tt class="docutils literal"><span class="pre">ssl_version</span></tt> is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If <tt class="docutils literal"><span class="pre">ca_certs</span></tt> is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.  The call
will attempt to validate the server certificate against that set of root
certificates, and will fail if the validation attempt fails.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<tt class="descclassname">ssl.</tt><tt class="descname">DER_cert_to_PEM_cert</tt><big>(</big><em>DER_cert_bytes</em><big>)</big><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<tt class="descclassname">ssl.</tt><tt class="descname">PEM_cert_to_DER_cert</tt><big>(</big><em>PEM_cert_string</em><big>)</big><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.</p>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>17.3.1.4. Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="ssl.CERT_NONE">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_NONE</tt><a class="headerlink" href="#ssl.CERT_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><tt class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></tt></a>, or the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.  In this mode (the default), no
certificates will be required from the other side of the socket connection.
If a certificate is received from the other end, no attempt to validate it
is made.</p>
<p>See the discussion of <a class="reference internal" href="#ssl-security"><em>Security considerations</em></a> below.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_OPTIONAL</tt><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><tt class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></tt></a>, or the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.  In this mode no certificates will be
required from the other side of the socket connection; but if they
are provided, validation will be attempted and an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-class docutils literal"><span class="pre">SSLError</span></tt></a>
will be raised on failure.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed, either to <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></tt></a> or as a
value of the <tt class="docutils literal"><span class="pre">ca_certs</span></tt> parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_REQUIRED</tt><a class="headerlink" href="#ssl.CERT_REQUIRED" title="Permalink to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><tt class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></tt></a>, or the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.  In this mode, certificates are
required from the other side of the socket connection; an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-class docutils literal"><span class="pre">SSLError</span></tt></a>
will be raised if no certificate is provided, or if its validation fails.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed, either to <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></tt></a> or as a
value of the <tt class="docutils literal"><span class="pre">ca_certs</span></tt> parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv2</tt><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 2 as the channel encryption protocol.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">SSL version 2 is insecure.  Its use is highly discouraged.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv23</tt><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 2 or 3 as the channel encryption protocol.  This is a
setting to use with servers for maximum compatibility with the other end of
an SSL connection, but it may cause the specific ciphers chosen for the
encryption to be of fairly low quality.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv3</tt><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 3 as the channel encryption protocol.  For clients, this
is the maximally compatible SSL variant.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_TLSv1</tt><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects TLS version 1 as the channel encryption protocol.  This is the most
modern version, and probably the best choice for maximum protection, if both
sides can speak it.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ALL">
<tt class="descclassname">ssl.</tt><tt class="descname">OP_ALL</tt><a class="headerlink" href="#ssl.OP_ALL" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables workarounds for various bugs present in other SSL implementations.
This option is set by default.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv2">
<tt class="descclassname">ssl.</tt><tt class="descname">OP_NO_SSLv2</tt><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevents an SSLv2 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a>.  It prevents the peers from
choosing SSLv2 as the protocol version.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv3">
<tt class="descclassname">ssl.</tt><tt class="descname">OP_NO_SSLv3</tt><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevents an SSLv3 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a>.  It prevents the peers from
choosing SSLv3 as the protocol version.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1">
<tt class="descclassname">ssl.</tt><tt class="descname">OP_NO_TLSv1</tt><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevents a TLSv1 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a>.  It prevents the peers from
choosing TLSv1 as the protocol version.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SNI">
<tt class="descclassname">ssl.</tt><tt class="descname">HAS_SNI</tt><a class="headerlink" href="#ssl.HAS_SNI" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the <em>Server Name
Indication</em> extension to the SSLv3 and TLSv1 protocols (as defined in
<span class="target" id="index-4"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc4366.html"><strong>RFC 4366</strong></a>).  When true, you can use the <em>server_hostname</em> argument to
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION</tt><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="Permalink to this definition">¶</a></dt>
<dd><p>The version string of the OpenSSL library loaded by the interpreter:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 0.9.8k 25 Mar 2009&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION_INFO</tt><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of five integers representing version information about the
OpenSSL library:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(0, 9, 8, 11, 15)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION_NUMBER</tt><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd><p>The raw version number of the OpenSSL library, as a single integer:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">9470143</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x9080bf&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

</div>
</div>
<div class="section" id="ssl-sockets">
<h2>17.3.2. SSL Sockets<a class="headerlink" href="#ssl-sockets" title="Permalink to this headline">¶</a></h2>
<p>SSL sockets provide the following methods of <a class="reference internal" href="socket.html#socket-objects"><em>Socket Objects</em></a>:</p>
<ul class="simple">
<li><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><tt class="xref py py-meth docutils literal"><span class="pre">accept()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">bind()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><tt class="xref py py-meth docutils literal"><span class="pre">detach()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><tt class="xref py py-meth docutils literal"><span class="pre">fileno()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><tt class="xref py py-meth docutils literal"><span class="pre">getpeername()</span></tt></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><tt class="xref py py-meth docutils literal"><span class="pre">getsockname()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><tt class="xref py py-meth docutils literal"><span class="pre">getsockopt()</span></tt></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><tt class="xref py py-meth docutils literal"><span class="pre">setsockopt()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><tt class="xref py py-meth docutils literal"><span class="pre">gettimeout()</span></tt></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><tt class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></tt></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><tt class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><tt class="xref py py-meth docutils literal"><span class="pre">listen()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><tt class="xref py py-meth docutils literal"><span class="pre">makefile()</span></tt></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><tt class="xref py py-meth docutils literal"><span class="pre">recv()</span></tt></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><tt class="xref py py-meth docutils literal"><span class="pre">recv_into()</span></tt></a>
(but passing a non-zero <tt class="docutils literal"><span class="pre">flags</span></tt> argument is not allowed)</li>
<li><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><tt class="xref py py-meth docutils literal"><span class="pre">sendall()</span></tt></a> (with
the same limitation)</li>
<li><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><tt class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></tt></a></li>
</ul>
<p>They also have the following additional methods and attributes:</p>
<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">do_handshake</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the SSL setup handshake.  If the socket is non-blocking, this method
may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a> with the value of the exception instance&#8217;s
<tt class="docutils literal"><span class="pre">args[0]</span></tt> being either <tt class="xref py py-const docutils literal"><span class="pre">SSL_ERROR_WANT_READ</span></tt> or
<tt class="xref py py-const docutils literal"><span class="pre">SSL_ERROR_WANT_WRITE</span></tt>, and should be called again until it stops
raising those exceptions.  Here&#8217;s an example of how to do that:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">while</span> <span class="k">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_READ</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
        <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_WRITE</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">getpeercert</tt><big>(</big><em>binary_form=False</em><big>)</big><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="Permalink to this definition">¶</a></dt>
<dd><p>If there is no certificate for the peer on the other end of the connection,
returns <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>If the parameter <tt class="docutils literal"><span class="pre">binary_form</span></tt> is <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const xref docutils literal"><span class="pre">False</span></tt></a>, and a certificate was
received from the peer, this method returns a <a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> instance.  If the
certificate was not validated, the dict is empty.  If the certificate was
validated, it returns a dict with the keys <tt class="docutils literal"><span class="pre">subject</span></tt> (the principal for
which the certificate was issued), and <tt class="docutils literal"><span class="pre">notAfter</span></tt> (the time after which the
certificate should not be trusted).  If a certificate contains an instance
of the <em>Subject Alternative Name</em> extension (see <span class="target" id="index-5"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a>), there will
also be a <tt class="docutils literal"><span class="pre">subjectAltName</span></tt> key in the dictionary.</p>
<p>The &#8220;subject&#8221; field is a tuple containing the sequence of relative
distinguished names (RDNs) given in the certificate&#8217;s data structure for the
principal, and each RDN is a sequence of name-value pairs:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;Feb 16 16:54:50 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">&#39;Wilmington&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;Python Software Foundation&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="s">&#39;SSL&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;somemachine.python.org&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>If the <tt class="docutils literal"><span class="pre">binary_form</span></tt> parameter is <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const xref docutils literal"><span class="pre">True</span></tt></a>, and a certificate was
provided, this method returns the DER-encoded form of the entire certificate
as a sequence of bytes, or <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const xref docutils literal"><span class="pre">None</span></tt></a> if the peer did not provide a
certificate.  This return value is independent of validation; if validation
was required (<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a>), it will have
been validated, but if <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a> was used to establish the
connection, the certificate, if present, will not have been validated.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.2: </span>The returned dictionary includes additional items such as <tt class="docutils literal"><span class="pre">issuer</span></tt>
and <tt class="docutils literal"><span class="pre">notBefore</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">cipher</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.SSLSocket.cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a three-value tuple containing the name of the cipher being used, the
version of the SSL protocol that defines its use, and the number of secret
bits being used.  If no connection has been established, returns <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">unwrap</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the SSL shutdown handshake, which removes the TLS layer from the
underlying socket, and returns the underlying socket object.  This can be
used to go from encrypted operation over a connection to unencrypted.  The
returned socket should always be used for further communication with the
other side of the connection, rather than the original socket.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.context">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">context</tt><a class="headerlink" href="#ssl.SSLSocket.context" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><tt class="xref py py-class docutils literal"><span class="pre">SSLContext</span></tt></a> object this SSL socket is tied to.  If the SSL
socket was created using the top-level <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> function
(rather than <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></tt></a>), this is a custom context
object created for this SSL socket.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
</dd></dl>

</div>
<div class="section" id="ssl-contexts">
<h2>17.3.3. SSL Contexts<a class="headerlink" href="#ssl-contexts" title="Permalink to this headline">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">New in version 3.2.</span></p>
<p>An SSL context holds various data longer-lived than single SSL connections,
such as SSL configuration options, certificate(s) and private key(s).
It also manages a cache of SSL sessions for server-side sockets, in order
to speed up repeated connections from the same clients.</p>
<dl class="class">
<dt id="ssl.SSLContext">
<em class="property">class </em><tt class="descclassname">ssl.</tt><tt class="descname">SSLContext</tt><big>(</big><em>protocol</em><big>)</big><a class="headerlink" href="#ssl.SSLContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new SSL context.  You must pass <em>protocol</em> which must be one
of the <tt class="docutils literal"><span class="pre">PROTOCOL_*</span></tt> constants defined in this module.
<a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a> is recommended for maximum interoperability.</p>
</dd></dl>

<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><tt class="xref py py-class docutils literal"><span class="pre">SSLContext</span></tt></a> objects have the following methods and attributes:</p>
<dl class="method">
<dt id="ssl.SSLContext.load_cert_chain">
<tt class="descclassname">SSLContext.</tt><tt class="descname">load_cert_chain</tt><big>(</big><em>certfile</em>, <em>keyfile=None</em><big>)</big><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a private key and the corresponding certificate.  The <em>certfile</em>
string must be the path to a single file in PEM format containing the
certificate as well as any number of CA certificates needed to establish
the certificate&#8217;s authenticity.  The <em>keyfile</em> string, if present, must
point to a file containing the private key in.  Otherwise the private
key will be taken from <em>certfile</em> as well.  See the discussion of
<a class="reference internal" href="#ssl-certificates"><em>Certificates</em></a> for more information on how the certificate
is stored in the <em>certfile</em>.</p>
<p>An <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-class docutils literal"><span class="pre">SSLError</span></tt></a> is raised if the private key doesn&#8217;t
match with the certificate.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_verify_locations">
<tt class="descclassname">SSLContext.</tt><tt class="descname">load_verify_locations</tt><big>(</big><em>cafile=None</em>, <em>capath=None</em><big>)</big><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a set of &#8220;certification authority&#8221; (CA) certificates used to validate
other peers&#8217; certificates when <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><tt class="xref py py-data docutils literal"><span class="pre">verify_mode</span></tt></a> is other than
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></tt></a>.  At least one of <em>cafile</em> or <em>capath</em> must be specified.</p>
<p>The <em>cafile</em> string, if present, is the path to a file of concatenated
CA certificates in PEM format. See the discussion of
<a class="reference internal" href="#ssl-certificates"><em>Certificates</em></a> for more information about how to arrange the
certificates in this file.</p>
<p>The <em>capath</em> string, if present, is
the path to a directory containing several CA certificates in PEM format,
following an <a class="reference external" href="http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html">OpenSSL specific layout</a>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<tt class="descclassname">SSLContext.</tt><tt class="descname">set_default_verify_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a set of default &#8220;certification authority&#8221; (CA) certificates from
a filesystem path defined when building the OpenSSL library.  Unfortunately,
there&#8217;s no easy way to know whether this method succeeds: no error is
returned if no certificates are to be found.  When the OpenSSL library is
provided as part of the operating system, though, it is likely to be
configured properly.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ciphers">
<tt class="descclassname">SSLContext.</tt><tt class="descname">set_ciphers</tt><big>(</big><em>ciphers</em><big>)</big><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the available ciphers for sockets created with this context.
It should be a string in the <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format</a>.
If no cipher can be selected (because compile-time options or other
configuration forbids use of all the specified ciphers), an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-class docutils literal"><span class="pre">SSLError</span></tt></a> will be raised.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">when connected, the <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.cipher()</span></tt></a> method of SSL sockets will
give the currently selected cipher.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_socket">
<tt class="descclassname">SSLContext.</tt><tt class="descname">wrap_socket</tt><big>(</big><em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em><big>)</big><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap an existing Python socket <em>sock</em> and return an <tt class="xref py py-class docutils literal"><span class="pre">SSLSocket</span></tt>
object.  The SSL socket is tied to the context, its settings and
certificates.  The parameters <em>server_side</em>, <em>do_handshake_on_connect</em>
and <em>suppress_ragged_eofs</em> have the same meaning as in the top-level
<a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> function.</p>
<p>On client connections, the optional parameter <em>server_hostname</em> specifies
the hostname of the service which we are connecting to.  This allows a
single server to host multiple SSL-based services with distinct certificates,
quite similarly to HTTP virtual hosts.  Specifying <em>server_hostname</em>
will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> if the OpenSSL library doesn&#8217;t have support
for it (that is, if <a class="reference internal" href="#ssl.HAS_SNI" title="ssl.HAS_SNI"><tt class="xref py py-data docutils literal"><span class="pre">HAS_SNI</span></tt></a> is <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const xref docutils literal"><span class="pre">False</span></tt></a>).  Specifying
<em>server_hostname</em> will also raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> if <em>server_side</em>
is true.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.session_stats">
<tt class="descclassname">SSLContext.</tt><tt class="descname">session_stats</tt><big>(</big><big>)</big><a class="headerlink" href="#ssl.SSLContext.session_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Get statistics about the SSL sessions created or managed by this context.
A dictionary is returned which maps the names of each <a class="reference external" href="http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html">piece of information</a> to their
numeric values.  For example, here is the total number of hits and misses
in the session cache since the context was created:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.options">
<tt class="descclassname">SSLContext.</tt><tt class="descname">options</tt><a class="headerlink" href="#ssl.SSLContext.options" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer representing the set of SSL options enabled on this context.
The default value is <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><tt class="xref py py-data docutils literal"><span class="pre">OP_ALL</span></tt></a>, but you can specify other options
such as <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><tt class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv2</span></tt></a> by ORing them together.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With versions of OpenSSL older than 0.9.8m, it is only possible
to set options, not to clear them.  Attempting to clear an option
(by resetting the corresponding bits) will raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.protocol">
<tt class="descclassname">SSLContext.</tt><tt class="descname">protocol</tt><a class="headerlink" href="#ssl.SSLContext.protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>The protocol version chosen when constructing the context.  This attribute
is read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_mode">
<tt class="descclassname">SSLContext.</tt><tt class="descname">verify_mode</tt><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to try to verify other peers&#8217; certificates and how to behave
if verification fails.  This attribute must be one of
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></tt></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-data docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-data docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a>.</p>
</dd></dl>

<span class="target" id="index-6"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-7"></span><h2>17.3.4. Certificates<a class="headerlink" href="#certificates" title="Permalink to this headline">¶</a></h2>
<p>Certificates in general are part of a public-key / private-key system.  In this
system, each <em>principal</em>, (which may be a machine, or a person, or an
organization) is assigned a unique two-part encryption key.  One part of the key
is public, and is called the <em>public key</em>; the other part is kept secret, and is
called the <em>private key</em>.  The two parts are related, in that if you encrypt a
message with one of the parts, you can decrypt it with the other part, and
<strong>only</strong> with the other part.</p>
<p>A certificate contains information about two principals.  It contains the name
of a <em>subject</em>, and the subject&#8217;s public key.  It also contains a statement by a
second principal, the <em>issuer</em>, that the subject is who he claims to be, and
that this is indeed the subject&#8217;s public key.  The issuer&#8217;s statement is signed
with the issuer&#8217;s private key, which only the issuer knows.  However, anyone can
verify the issuer&#8217;s statement by finding the issuer&#8217;s public key, decrypting the
statement with it, and comparing it to the other information in the certificate.
The certificate also contains information about the time period over which it is
valid.  This is expressed as two fields, called &#8220;notBefore&#8221; and &#8220;notAfter&#8221;.</p>
<p>In the Python use of certificates, a client or server can use a certificate to
prove who they are.  The other side of a network connection can also be required
to produce a certificate, and that certificate can be validated to the
satisfaction of the client or server that requires such validation.  The
connection attempt can be set to raise an exception if the validation fails.
Validation is done automatically, by the underlying OpenSSL framework; the
application need not concern itself with its mechanics.  But the application
does usually need to provide sets of certificates to allow this process to take
place.</p>
<p>Python uses files to contain certificates.  They should be formatted as &#8220;PEM&#8221;
(see <span class="target" id="index-8"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a>), which is a base-64 encoded form wrapped with a header line
and a footer line:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<div class="section" id="certificate-chains">
<h3>17.3.4.1. Certificate chains<a class="headerlink" href="#certificate-chains" title="Permalink to this headline">¶</a></h3>
<p>The Python files which contain certificates can contain a sequence of
certificates, sometimes called a <em>certificate chain</em>.  This chain should start
with the specific certificate for the principal who &#8220;is&#8221; the client or server,
and then the certificate for the issuer of that certificate, and then the
certificate for the issuer of <em>that</em> certificate, and so on up the chain till
you get to a certificate which is <em>self-signed</em>, that is, a certificate which
has the same subject and issuer, sometimes called a <em>root certificate</em>.  The
certificates should just be concatenated together in the certificate file.  For
example, suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority&#8217;s certificate:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h3>17.3.4.2. CA certificates<a class="headerlink" href="#ca-certificates" title="Permalink to this headline">¶</a></h3>
<p>If you are going to require validation of the other side of the connection&#8217;s
certificate, you need to provide a &#8220;CA certs&#8221; file, filled with the certificate
chains for each issuer you are willing to trust.  Again, this file just contains
these chains concatenated together.  For validation, Python will use the first
chain it finds in the file which matches.  Some &#8220;standard&#8221; root certificates are
available from various certification authorities: <a class="reference external" href="http://www.cacert.org/index.php?id=3">CACert.org</a>, <a class="reference external" href="http://www.thawte.com/roots/">Thawte</a>, <a class="reference external" href="http://www.verisign.com/support/roots.html">Verisign</a>, <a class="reference external" href="http://www.PositiveSSL.com/ssl-certificate-support/cert_installation/UTN-USERFirst-Hardware.crt">Positive SSL</a>
(used by python.org), <a class="reference external" href="http://www.geotrust.com/resources/root_certificates/index.asp">Equifax and GeoTrust</a>.</p>
<p>In general, if you are using SSL3 or TLS1, you don&#8217;t need to put the full chain
in your &#8220;CA certs&#8221; file; you only need the root certificates, and the remote
peer is supposed to furnish the other certificates necessary to chain from its
certificate to a root certificate.  See <span class="target" id="index-9"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc4158.html"><strong>RFC 4158</strong></a> for more discussion of the
way in which certification chains can be built.</p>
</div>
<div class="section" id="combined-key-and-certificate">
<h3>17.3.4.3. Combined key and certificate<a class="headerlink" href="#combined-key-and-certificate" title="Permalink to this headline">¶</a></h3>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <tt class="docutils literal"><span class="pre">certfile</span></tt> parameter to <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_cert_chain()</span></tt></a>
and <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> needs to be passed.  If the private key is stored
with the certificate, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="self-signed-certificates">
<h3>17.3.4.4. Self-signed certificates<a class="headerlink" href="#self-signed-certificates" title="Permalink to this headline">¶</a></h3>
<p>If you are going to create a server that provides SSL-encrypted connection
services, you will need to acquire a certificate for that service.  There are
many ways of acquiring appropriate certificates, such as buying one from a
certification authority.  Another common practice is to generate a self-signed
certificate.  The simplest way to do this is with the OpenSSL package, using
something like the following:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and trusted)
root certificates.</p>
</div>
</div>
<div class="section" id="examples">
<h2>17.3.5. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>17.3.5.1. Testing for SSL support<a class="headerlink" href="#testing-for-ssl-support" title="Permalink to this headline">¶</a></h3>
<p>To test for the presence of SSL support in a Python installation, user code
should use the following idiom:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span> <span class="c"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>17.3.5.2. Client-side operation<a class="headerlink" href="#client-side-operation" title="Permalink to this headline">¶</a></h3>
<p>This example connects to an SSL server and prints the server&#8217;s certificate:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">pprint</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c"># require a certificate from the server</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                           <span class="n">ca_certs</span><span class="o">=</span><span class="s">&quot;/etc/ca_certs_file&quot;</span><span class="p">,</span>
                           <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>

<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">())</span>
<span class="c"># note that closing the SSLSocket will also close the underlying socket</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>As of October 6, 2010, the certificate printed by this program looks like
this:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;May 25 23:59:59 2012 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.3&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.2&#39;</span><span class="p">,</span> <span class="s">&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;businessCategory&#39;</span><span class="p">,</span> <span class="s">&#39;V1.0, Clause 5.(b)&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;serialNumber&#39;</span><span class="p">,</span> <span class="s">&#39;2497886&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;postalCode&#39;</span><span class="p">,</span> <span class="s">&#39;94043&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">&#39;Mountain View&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;streetAddress&#39;</span><span class="p">,</span> <span class="s">&#39;487 East Middlefield Road&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;VeriSign, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="s">&#39; Production Security Services&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.com&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>This other example first creates an SSL context, instructs it to verify
certificates sent by peers, and feeds it a set of recognized certificate
authorities (CA):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(it is assumed your operating system places a bundle of all CA certificates
in <tt class="docutils literal"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></tt>; if not, you&#8217;ll get an error and have
to adjust the location)</p>
<p>When you use the context to connect to a server, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a>
validates the server certificate: it ensures that the server certificate
was signed with one of the CA certificates, and checks the signature for
correctness:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&quot;linuxfr.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>You should then fetch the certificate and check its fields for conformity:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;linuxfr.org&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Visual inspection shows that the certificate does identify the desired service
(that is, the HTTPS host <tt class="docutils literal"><span class="pre">linuxfr.org</span></tt>):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;notAfter&#39;: &#39;Jun 26 21:41:46 2011 GMT&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;commonName&#39;, &#39;linuxfr.org&#39;),),),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;linuxfr.org&#39;), (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;))}</span>
</pre></div>
</div>
<p>Now that you are assured of its authenticity, you can proceed to talk with
the server:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 302 Found&#39;,</span>
<span class="go"> b&#39;Date: Sun, 16 May 2010 13:43:28 GMT&#39;,</span>
<span class="go"> b&#39;Server: Apache/2.2&#39;,</span>
<span class="go"> b&#39;Location: https://linuxfr.org/pub/&#39;,</span>
<span class="go"> b&#39;Vary: Accept-Encoding&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=iso-8859-1&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>See the discussion of <a class="reference internal" href="#ssl-security"><em>Security considerations</em></a> below.</p>
</div>
<div class="section" id="server-side-operation">
<h3>17.3.5.3. Server-side operation<a class="headerlink" href="#server-side-operation" title="Permalink to this headline">¶</a></h3>
<p>For server operation, typically you&#8217;ll need to have a server certificate, and
private key, each in a file.  You&#8217;ll first create a context holding the key
and the certificate, so that clients can check your authenticity.  Then
you&#8217;ll open a socket, bind it to a port, call <tt class="xref py py-meth docutils literal"><span class="pre">listen()</span></tt> on it, and start
waiting for clients to connect:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>When a client connects, you&#8217;ll call <tt class="xref py py-meth docutils literal"><span class="pre">accept()</span></tt> on the socket to get the
new socket from the other end, and use the context&#8217;s <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><tt class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></tt></a>
method to create a server-side SSL socket for the connection:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">while</span> <span class="k">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Then you&#8217;ll read data from the <tt class="docutils literal"><span class="pre">connstream</span></tt> and do something with it till you
are finished with the client (or the client is finished with you):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c"># we&#39;ll assume do_something returns False</span>
            <span class="c"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c"># finished with client</span>
</pre></div>
</div>
<p>And go back to listening for new client connections (of course, a real server
would probably handle each client connection in a separate thread, or put
the sockets in non-blocking mode and use an event loop).</p>
</div>
</div>
<div class="section" id="security-considerations">
<span id="ssl-security"></span><h2>17.3.6. Security considerations<a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="verifying-certificates">
<h3>17.3.6.1. Verifying certificates<a class="headerlink" href="#verifying-certificates" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a> is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you&#8217;re talking to.
Therefore, when in client mode, it is highly recommended to use
<a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a>.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></tt></a>, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><tt class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></tt></a> function can be used.</p>
<p>In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you&#8217;ll also have
to specify <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a> and similarly check the client certificate.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In client mode, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> and <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a> are
equivalent unless anonymous ciphers are enabled (they are disabled
by default).</p>
</div>
</div></blockquote>
</div>
<div class="section" id="protocol-versions">
<h3>17.3.6.2. Protocol versions<a class="headerlink" href="#protocol-versions" title="Permalink to this headline">¶</a></h3>
<p>SSL version 2 is considered insecure and is therefore dangerous to use.  If
you want maximum compatibility between clients and servers, it is recommended
to use <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a> as the protocol version and then disable
SSLv2 explicitly using the <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><tt class="xref py py-data docutils literal"><span class="pre">SSLContext.options</span></tt></a> attribute:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv2</span>
</pre></div>
</div>
<p>The SSL context created above will allow SSLv3 and TLSv1 connections, but
not SSLv2.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Class <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a></dt>
<dd>Documentation of underlying <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt></a> class</dd>
<dt><a class="reference external" href="http://old.pseudonym.org/ssl/wwwj-index.html">Introducing SSL and Certificates using OpenSSL</a></dt>
<dd>Frederick J. Hirsch</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1422">RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</a></dt>
<dd>Steve Kent</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1750">RFC 1750: Randomness Recommendations for Security</a></dt>
<dd>D. Eastlake et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc3280">RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a></dt>
<dd>Housley et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc4366">RFC 4366: Transport Layer Security (TLS) Extensions</a></dt>
<dd>Blake-Wilson et. al.</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.3. <tt class="docutils literal"><span class="pre">ssl</span></tt> &#8212; TLS/SSL wrapper for socket objects</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">17.3.1. Functions, Constants, and Exceptions</a><ul>
<li><a class="reference internal" href="#socket-creation">17.3.1.1. Socket creation</a></li>
<li><a class="reference internal" href="#random-generation">17.3.1.2. Random generation</a></li>
<li><a class="reference internal" href="#certificate-handling">17.3.1.3. Certificate handling</a></li>
<li><a class="reference internal" href="#constants">17.3.1.4. Constants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">17.3.2. SSL Sockets</a></li>
<li><a class="reference internal" href="#ssl-contexts">17.3.3. SSL Contexts</a></li>
<li><a class="reference internal" href="#certificates">17.3.4. Certificates</a><ul>
<li><a class="reference internal" href="#certificate-chains">17.3.4.1. Certificate chains</a></li>
<li><a class="reference internal" href="#ca-certificates">17.3.4.2. CA certificates</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">17.3.4.3. Combined key and certificate</a></li>
<li><a class="reference internal" href="#self-signed-certificates">17.3.4.4. Self-signed certificates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">17.3.5. Examples</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">17.3.5.1. Testing for SSL support</a></li>
<li><a class="reference internal" href="#client-side-operation">17.3.5.2. Client-side operation</a></li>
<li><a class="reference internal" href="#server-side-operation">17.3.5.3. Server-side operation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-considerations">17.3.6. Security considerations</a><ul>
<li><a class="reference internal" href="#verifying-certificates">17.3.6.1. Verifying certificates</a></li>
<li><a class="reference internal" href="#protocol-versions">17.3.6.2. Protocol versions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="socket.html"
                        title="previous chapter">17.2. <tt class="docutils literal docutils literal"><span class="pre">socket</span></tt> &#8212; Low-level networking interface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="signal.html"
                        title="next chapter">17.4. <tt class="docutils literal docutils literal docutils literal"><span class="pre">signal</span></tt> &#8212; Set handlers for asynchronous events</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/ssl.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — Set handlers for asynchronous events"
             >next</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — Low-level networking interface"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" >17. Interprocess Communication and Networking</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 27, 2011.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>