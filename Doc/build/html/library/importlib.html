

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>29.6. importlib – An implementation of import &mdash; Python v3.2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.2 documentation" href="../index.html" />
    <link rel="up" title="29. Importing Modules" href="modules.html" />
    <link rel="next" title="30. Python Language Services" href="language.html" />
    <link rel="prev" title="29.5. runpy — Locating and executing Python modules" href="runpy.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="language.html" title="30. Python Language Services"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="29.5. runpy — Locating and executing Python modules"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">29. Importing Modules</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-importlib">
<span id="importlib-an-implementation-of-import"></span><h1>29.6. <a class="reference internal" href="#module-importlib" title="importlib: An implementation of the import machinery."><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a> &#8211; An implementation of <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a><a class="headerlink" href="#module-importlib" title="Permalink to this headline">¶</a></h1>
<p class="versionadded">
<span class="versionmodified">New in version 3.1.</span></p>
<div class="section" id="introduction">
<h2>29.6.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The purpose of the <a class="reference internal" href="#module-importlib" title="importlib: An implementation of the import machinery."><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a> package is two-fold. One is to provide an
implementation of the <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement (and thus, by extension, the
<a class="reference internal" href="functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> function) in Python source code. This provides an
implementation of <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> which is portable to any Python
interpreter. This also provides a reference implementation which is easier to
comprehend than one implemented in a programming language other than Python.</p>
<p>Two, the components to implement <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> are exposed in this
package, making it easier for users to create their own custom objects (known
generically as an <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importer</em></a>) to participate in the import process.
Details on custom importers can be found in <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><em>The import statement</em></a></dt>
<dd>The language reference for the <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement.</dd>
<dt><a class="reference external" href="http://www.python.org/doc/essays/packages.html">Packages specification</a></dt>
<dd>Original specification of packages. Some semantics have changed since
the writing of this document (e.g. redirecting based on <tt class="xref docutils literal"><span class="pre">None</span></tt>
in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>).</dd>
<dt>The <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> function</dt>
<dd>The <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> statement is syntactic sugar for this function.</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt>
<dd>Import on Case-Insensitive Platforms</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt>
<dd>Defining Python Source Code Encodings</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt>
<dd>New Import Hooks</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt>
<dd>Imports: Multi-Line and Absolute/Relative</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt>
<dd>Main module explicit relative imports</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt>
<dd>Using UTF-8 as the Default Source Encoding</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt>
<dd>PYC Repository Directories</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>29.6.2. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="importlib.__import__">
<tt class="descclassname">importlib.</tt><tt class="descname">__import__</tt><big>(</big><em>name</em>, <em>globals={}</em>, <em>locals={}</em>, <em>fromlist=list()</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#importlib.__import__" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation of the built-in <a class="reference internal" href="functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> function.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.import_module">
<tt class="descclassname">importlib.</tt><tt class="descname">import_module</tt><big>(</big><em>name</em>, <em>package=None</em><big>)</big><a class="headerlink" href="#importlib.import_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a module. The <em>name</em> argument specifies what module to
import in absolute or relative terms
(e.g. either <tt class="docutils literal"><span class="pre">pkg.mod</span></tt> or <tt class="docutils literal"><span class="pre">..mod</span></tt>). If the name is
specified in relative terms, then the <em>package</em> argument must be set to
the name of the package which is to act as the anchor for resolving the
package name (e.g. <tt class="docutils literal"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></tt> will import
<tt class="docutils literal"><span class="pre">pkg.mod</span></tt>).</p>
<p>The <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">import_module()</span></tt></a> function acts as a simplifying wrapper around
<a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><tt class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></tt></a>. This means all semantics of the function are
derived from <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><tt class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></tt></a>, including requiring the package
from which an import is occurring to have been previously imported
(i.e., <em>package</em> must already be imported). The most important difference
is that <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">import_module()</span></tt></a> returns the most nested package or module
that was imported (e.g. <tt class="docutils literal"><span class="pre">pkg.mod</span></tt>), while <a class="reference internal" href="functions.html#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> returns the
top-level package or module (e.g. <tt class="docutils literal"><span class="pre">pkg</span></tt>).</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2>29.6.3. <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><tt class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></tt></a> &#8211; Abstract base classes related to import<a class="headerlink" href="#module-importlib.abc" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><tt class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></tt></a> module contains all of the core abstract base classes
used by <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>. Some subclasses of the core abstract base classes
are also provided to help in implementing the core ABCs.</p>
<dl class="class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">Finder</tt><a class="headerlink" href="#importlib.abc.Finder" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class representing a <a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">finder</em></a>.
See <span class="target" id="index-8"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> for the exact definition for a finder.</p>
<dl class="method">
<dt id="importlib.abc.Finder.find_module">
<tt class="descname">find_module</tt><big>(</big><em>fullname</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#importlib.abc.Finder.find_module" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method for finding a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> for the specified
module. If the <a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">finder</em></a> is found on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> and the
module to be searched for is a subpackage or module then <em>path</em> will
be the value of <tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt> from the parent package. If a loader
cannot be found, <tt class="xref docutils literal"><span class="pre">None</span></tt> is returned.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">Loader</tt><a class="headerlink" href="#importlib.abc.Loader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a>.
See <span class="target" id="index-9"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> for the exact definition for a loader.</p>
<dl class="method">
<dt id="importlib.abc.Loader.load_module">
<tt class="descname">load_module</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.Loader.load_module" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method for loading a module. If the module cannot be
loaded, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised, otherwise the loaded module is
returned.</p>
<p>If the requested module already exists in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>, that
module should be used and reloaded.
Otherwise the loader should create a new module and insert it into
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> before any loading begins, to prevent recursion
from the import. If the loader inserted a module and the load fails, it
must be removed by the loader from <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>; modules already
in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> before the loader began execution should be left
alone. The <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><tt class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></tt></a> decorator handles
all of these details.</p>
<p>The loader should set several attributes on the module.
(Note that some of these attributes can change when a module is
reloaded.)</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">__name__</span></tt></dt>
<dd><p class="first last">The name of the module.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">__file__</span></tt></dt>
<dd><p class="first last">The path to where the module data is stored (not set for built-in
modules).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt></dt>
<dd><p class="first last">A list of strings specifying the search path within a
package. This attribute is not set on modules.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">__package__</span></tt></dt>
<dd><p class="first last">The parent package for the module/package. If the module is
top-level then it has a value of the empty string. The
<a class="reference internal" href="#importlib.util.set_package" title="importlib.util.set_package"><tt class="xref py py-func docutils literal"><span class="pre">importlib.util.set_package()</span></tt></a> decorator can handle the details
for <tt class="xref py py-attr docutils literal"><span class="pre">__package__</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">__loader__</span></tt></dt>
<dd><p class="first last">The loader used to load the module.
(This is not set by the built-in import machinery,
but it should be set whenever a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> is used.)</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">ResourceLoader</tt><a class="headerlink" href="#importlib.abc.ResourceLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> which implements the optional
<span class="target" id="index-10"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol for loading arbitrary resources from the storage
back-end.</p>
<dl class="method">
<dt id="importlib.abc.ResourceLoader.get_data">
<tt class="descname">get_data</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method to return the bytes for the data located at <em>path</em>.
Loaders that have a file-like storage back-end
that allows storing arbitrary data
can implement this abstract method to give direct access
to the data stored. <a class="reference internal" href="exceptions.html#IOError" title="IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> is to be raised if the <em>path</em> cannot
be found. The <em>path</em> is expected to be constructed using a module&#8217;s
<tt class="xref py py-attr docutils literal"><span class="pre">__file__</span></tt> attribute or an item from a package&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">InspectLoader</tt><a class="headerlink" href="#importlib.abc.InspectLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> which implements the optional
<span class="target" id="index-11"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol for loaders that inspect modules.</p>
<dl class="method">
<dt id="importlib.abc.InspectLoader.get_code">
<tt class="descname">get_code</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method to return the <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><tt class="xref py py-class docutils literal"><span class="pre">code</span></tt></a> object for a module.
<tt class="xref docutils literal"><span class="pre">None</span></tt> is returned if the module does not have a code object
(e.g. built-in module).  <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised if loader cannot
find the requested module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.get_source">
<tt class="descname">get_source</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method to return the source of a module. It is returned as
a text string with universal newlines. Returns <tt class="xref docutils literal"><span class="pre">None</span></tt> if no
source is available (e.g. a built-in module). Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>
if the loader cannot find the module specified.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.is_package">
<tt class="descname">is_package</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method to return a true value if the module is a package, a
false value otherwise. <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised if the
<a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> cannot find the module.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">ExecutionLoader</tt><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class which inherits from <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><tt class="xref py py-class docutils literal"><span class="pre">InspectLoader</span></tt></a> that,
when implemented, helps a module to be executed as a script. The ABC
represents an optional <span class="target" id="index-12"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol.</p>
<dl class="method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<tt class="descname">get_filename</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method that is to return the value of <tt class="xref py py-attr docutils literal"><span class="pre">__file__</span></tt> for
the specified module. If no path is available, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is
raised.</p>
<p>If source code is available, then the method should return the path to
the source file, regardless of whether a bytecode was used to load the
module.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">SourceLoader</tt><a class="headerlink" href="#importlib.abc.SourceLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for implementing source (and optionally bytecode)
file loading. The class inherits from both <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></tt></a> and
<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><tt class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></tt></a>, requiring the implementation of:</p>
<ul>
<li><p class="first"><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><tt class="xref py py-meth docutils literal"><span class="pre">ResourceLoader.get_data()</span></tt></a></p>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><tt class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></tt></a></dt>
<dd><p class="first last">Should only return the path to the source file; sourceless
loading is not supported.</p>
</dd>
</dl>
</li>
</ul>
<p>The abstract methods defined by this class are to add optional bytecode
file support. Not implementing these optional methods causes the loader to
only work with source code. Implementing the methods allows the loader to
work with source <em>and</em> bytecode files; it does not allow for <em>sourceless</em>
loading where only bytecode is provided.  Bytecode files are an
optimization to speed up loading by removing the parsing step of Python&#8217;s
compiler, and so no bytecode-specific API is exposed.</p>
<dl class="method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<tt class="descname">path_mtime</tt><big>(</big><em>self</em>, <em>path</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional abstract method which returns the modification time for the
specified path.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.set_data">
<tt class="descname">set_data</tt><big>(</big><em>self</em>, <em>path</em>, <em>data</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional abstract method which writes the specified bytes to a file
path. Any intermediate directories which do not exist are to be created
automatically.</p>
<p>When writing to the path fails because the path is read-only
(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><tt class="xref py py-attr docutils literal"><span class="pre">errno.EACCES</span></tt></a>), do not propagate the exception.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_code">
<tt class="descname">get_code</tt><big>(</big><em>self</em>, <em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><tt class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_code()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.load_module">
<tt class="descname">load_module</tt><big>(</big><em>self</em>, <em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><tt class="xref py py-meth docutils literal"><span class="pre">Loader.load_module()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_source">
<tt class="descname">get_source</tt><big>(</big><em>self</em>, <em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><tt class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_source()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.is_package">
<tt class="descname">is_package</tt><big>(</big><em>self</em>, <em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><tt class="xref py py-meth docutils literal"><span class="pre">InspectLoader.is_package()</span></tt></a>. A module
is determined to be a package if its file path is a file named
<tt class="docutils literal"><span class="pre">__init__</span></tt> when the file extension is removed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PyLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">PyLoader</tt><a class="headerlink" href="#importlib.abc.PyLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class inheriting from
<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><tt class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></tt></a> and
<a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></tt></a> designed to ease the loading of
Python source modules (bytecode is not handled; see
<a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">SourceLoader</span></tt></a> for a source/bytecode ABC). A subclass
implementing this ABC will only need to worry about exposing how the source
code is stored; all other details for loading Python source code will be
handled by the concrete implementations of key methods.</p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 3.2: </span>This class has been deprecated in favor of <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">SourceLoader</span></tt></a> and is
slated for removal in Python 3.4. See below for how to create a
subclass that is compatible with Python 3.1 onwards.</p>
<p>If compatibility with Python 3.1 is required, then use the following idiom
to implement a subclass that will work with Python 3.1 onwards (make sure
to implement <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><tt class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></tt></a>):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib.abc</span> <span class="k">import</span> <span class="n">SourceLoader</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib.abc</span> <span class="k">import</span> <span class="n">PyLoader</span> <span class="k">as</span> <span class="n">SourceLoader</span>


<span class="k">class</span> <span class="nc">CustomLoader</span><span class="p">(</span><span class="n">SourceLoader</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the path to the source file.&quot;&quot;&quot;</span>
        <span class="c"># Implement ...</span>

    <span class="k">def</span> <span class="nf">source_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement source_path in terms of get_filename.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">None</span>

    <span class="k">def</span> <span class="nf">is_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement is_package by looking for an __init__ file</span>
<span class="sd">        name as returned by get_filename.&quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;__init__&#39;</span>
</pre></div>
</div>
<dl class="method">
<dt id="importlib.abc.PyLoader.source_path">
<tt class="descname">source_path</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyLoader.source_path" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method that returns the path to the source code for a
module. Should return <tt class="xref docutils literal"><span class="pre">None</span></tt> if there is no source code.
Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> if the loader knows it cannot handle the
module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyLoader.get_filename">
<tt class="descname">get_filename</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyLoader.get_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of
<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><tt class="xref py py-meth docutils literal"><span class="pre">importlib.abc.ExecutionLoader.get_filename()</span></tt></a> that
relies on <a class="reference internal" href="#importlib.abc.PyLoader.source_path" title="importlib.abc.PyLoader.source_path"><tt class="xref py py-meth docutils literal"><span class="pre">source_path()</span></tt></a>. If <a class="reference internal" href="#importlib.abc.PyLoader.source_path" title="importlib.abc.PyLoader.source_path"><tt class="xref py py-meth docutils literal"><span class="pre">source_path()</span></tt></a> returns
<tt class="xref docutils literal"><span class="pre">None</span></tt>, then <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyLoader.load_module">
<tt class="descname">load_module</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyLoader.load_module" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><tt class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></tt></a>
that loads Python source code. All needed information comes from the
abstract methods required by this ABC. The only pertinent assumption
made by this method is that when loading a package
<tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt> is set to <tt class="docutils literal"><span class="pre">[os.path.dirname(__file__)]</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyLoader.get_code">
<tt class="descname">get_code</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyLoader.get_code" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of
<a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><tt class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.get_code()</span></tt></a> that creates code objects
from Python source code, by requesting the source code (using
<a class="reference internal" href="#importlib.abc.PyLoader.source_path" title="importlib.abc.PyLoader.source_path"><tt class="xref py py-meth docutils literal"><span class="pre">source_path()</span></tt></a> and <tt class="xref py py-meth docutils literal"><span class="pre">get_data()</span></tt>) and compiling it with the
built-in <a class="reference internal" href="functions.html#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> function.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyLoader.get_source">
<tt class="descname">get_source</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyLoader.get_source" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of
<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><tt class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.get_source()</span></tt></a>. Uses
<a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><tt class="xref py py-meth docutils literal"><span class="pre">importlib.abc.ResourceLoader.get_data()</span></tt></a> and <a class="reference internal" href="#importlib.abc.PyLoader.source_path" title="importlib.abc.PyLoader.source_path"><tt class="xref py py-meth docutils literal"><span class="pre">source_path()</span></tt></a>
to get the source code.  It tries to guess the source encoding using
<a class="reference internal" href="tokenize.html#tokenize.detect_encoding" title="tokenize.detect_encoding"><tt class="xref py py-func docutils literal"><span class="pre">tokenize.detect_encoding()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PyPycLoader">
<em class="property">class </em><tt class="descclassname">importlib.abc.</tt><tt class="descname">PyPycLoader</tt><a class="headerlink" href="#importlib.abc.PyPycLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class inheriting from <a class="reference internal" href="#importlib.abc.PyLoader" title="importlib.abc.PyLoader"><tt class="xref py py-class docutils literal"><span class="pre">PyLoader</span></tt></a>.
This ABC is meant to help in creating loaders that support both Python
source and bytecode.</p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 3.2: </span>This class has been deprecated in favor of <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">SourceLoader</span></tt></a> and to
properly support <span class="target" id="index-13"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>. If compatibility is required with
Python 3.1, implement both <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><tt class="xref py py-class docutils literal"><span class="pre">SourceLoader</span></tt></a> and <a class="reference internal" href="#importlib.abc.PyLoader" title="importlib.abc.PyLoader"><tt class="xref py py-class docutils literal"><span class="pre">PyLoader</span></tt></a>;
instructions on how to do so are included in the documentation for
<a class="reference internal" href="#importlib.abc.PyLoader" title="importlib.abc.PyLoader"><tt class="xref py py-class docutils literal"><span class="pre">PyLoader</span></tt></a>. Do note that this solution will not support
sourceless/bytecode-only loading; only source <em>and</em> bytecode loading.</p>
<dl class="method">
<dt id="importlib.abc.PyPycLoader.source_mtime">
<tt class="descname">source_mtime</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyPycLoader.source_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method which returns the modification time for the source
code of the specified module. The modification time should be an
integer. If there is no source code, return <tt class="xref docutils literal"><span class="pre">None</span></tt>. If the
module cannot be found then <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyPycLoader.bytecode_path">
<tt class="descname">bytecode_path</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyPycLoader.bytecode_path" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method which returns the path to the bytecode for the
specified module, if it exists. It returns <tt class="xref docutils literal"><span class="pre">None</span></tt>
if no bytecode exists (yet).
Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> if the loader knows it cannot handle the
module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyPycLoader.get_filename">
<tt class="descname">get_filename</tt><big>(</big><em>fullname</em><big>)</big><a class="headerlink" href="#importlib.abc.PyPycLoader.get_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>A concrete implementation of
<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><tt class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></tt></a> that relies on
<a class="reference internal" href="#importlib.abc.PyLoader.source_path" title="importlib.abc.PyLoader.source_path"><tt class="xref py py-meth docutils literal"><span class="pre">PyLoader.source_path()</span></tt></a> and <a class="reference internal" href="#importlib.abc.PyPycLoader.bytecode_path" title="importlib.abc.PyPycLoader.bytecode_path"><tt class="xref py py-meth docutils literal"><span class="pre">bytecode_path()</span></tt></a>.
If <tt class="xref py py-meth docutils literal"><span class="pre">source_path()</span></tt> returns a path, then that value is returned.
Else if <a class="reference internal" href="#importlib.abc.PyPycLoader.bytecode_path" title="importlib.abc.PyPycLoader.bytecode_path"><tt class="xref py py-meth docutils literal"><span class="pre">bytecode_path()</span></tt></a> returns a path, that path will be
returned. If a path is not available from both methods,
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PyPycLoader.write_bytecode">
<tt class="descname">write_bytecode</tt><big>(</big><em>fullname</em>, <em>bytecode</em><big>)</big><a class="headerlink" href="#importlib.abc.PyPycLoader.write_bytecode" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method which has the loader write <em>bytecode</em> for future
use. If the bytecode is written, return <tt class="xref docutils literal"><span class="pre">True</span></tt>. Return
<tt class="xref docutils literal"><span class="pre">False</span></tt> if the bytecode could not be written. This method
should not be called if <a class="reference internal" href="sys.html#sys.dont_write_bytecode" title="sys.dont_write_bytecode"><tt class="xref py py-data docutils literal"><span class="pre">sys.dont_write_bytecode</span></tt></a> is true.
The <em>bytecode</em> argument should be a bytes string or bytes array.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2>29.6.4. <a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><tt class="xref py py-mod docutils literal"><span class="pre">importlib.machinery</span></tt></a> &#8211; Importers and path hooks<a class="headerlink" href="#module-importlib.machinery" title="Permalink to this headline">¶</a></h2>
<p>This module contains the various objects that help <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>
find and load modules.</p>
<dl class="class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><tt class="descclassname">importlib.machinery.</tt><tt class="descname">BuiltinImporter</tt><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importer</em></a> for built-in modules. All known built-in modules are
listed in <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><tt class="xref py py-data docutils literal"><span class="pre">sys.builtin_module_names</span></tt></a>. This class implements the
<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><tt class="xref py py-class docutils literal"><span class="pre">importlib.abc.Finder</span></tt></a> and <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><tt class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></tt></a>
ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><tt class="descclassname">importlib.machinery.</tt><tt class="descname">FrozenImporter</tt><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importer</em></a> for frozen modules. This class implements the
<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><tt class="xref py py-class docutils literal"><span class="pre">importlib.abc.Finder</span></tt></a> and <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><tt class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></tt></a>
ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><tt class="descclassname">importlib.machinery.</tt><tt class="descname">PathFinder</tt><a class="headerlink" href="#importlib.machinery.PathFinder" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">Finder</em></a> for <a class="reference internal" href="sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>. This class implements the
<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><tt class="xref py py-class docutils literal"><span class="pre">importlib.abc.Finder</span></tt></a> ABC.</p>
<p>This class does not perfectly mirror the semantics of <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> in
terms of <a class="reference internal" href="sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>. No implicit path hooks are assumed for
simplification of the class and its semantics.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><tt class="descname">find_module</tt><big>(</big><em>fullname</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method that attempts to find a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> for the module
specified by <em>fullname</em> on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> or, if defined, on
<em>path</em>. For each path entry that is searched,
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> is checked. If an non-false object is
found then it is used as the <a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">finder</em></a> to look for the module
being searched for. If no entry is found in
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a>, then <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> is
searched for a finder for the path entry and, if found, is stored in
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> along with being queried about the
module. If no finder is ever found then <tt class="xref docutils literal"><span class="pre">None</span></tt> is returned.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2>29.6.5. <a class="reference internal" href="#module-importlib.util" title="importlib.util: Importers and path hooks"><tt class="xref py py-mod docutils literal"><span class="pre">importlib.util</span></tt></a> &#8211; Utility code for importers<a class="headerlink" href="#module-importlib.util" title="Permalink to this headline">¶</a></h2>
<p>This module contains the various objects that help in the construction of
an <a class="reference internal" href="../glossary.html#term-importer"><em class="xref std std-term">importer</em></a>.</p>
<dl class="function">
<dt id="importlib.util.module_for_loader">
<tt class="descclassname">&#64;</tt><tt class="descclassname">importlib.util.</tt><tt class="descname">module_for_loader</tt><a class="headerlink" href="#importlib.util.module_for_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> method,
to handle selecting the proper
module object to load with. The decorated method is expected to have a call
signature taking two positional arguments
(e.g. <tt class="docutils literal"><span class="pre">load_module(self,</span> <span class="pre">module)</span></tt>) for which the second argument
will be the module <strong>object</strong> to be used by the loader.
Note that the decorator
will not work on static methods because of the assumption of two
arguments.</p>
<p>The decorated method will take in the <strong>name</strong> of the module to be loaded
as expected for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a>. If the module is not found in
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> then a new one is constructed with its
<tt class="xref py py-attr docutils literal"><span class="pre">__name__</span></tt> attribute set. Otherwise the module found in
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> will be passed into the method. If an
exception is raised by the decorated method and a module was added to
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> it will be removed to prevent a partially initialized
module from being in left in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>. If the module was already
in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> then it is left alone.</p>
<p>Use of this decorator handles all the details of which module object a
loader should initialize as specified by <span class="target" id="index-14"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_loader">
<tt class="descclassname">&#64;</tt><tt class="descclassname">importlib.util.</tt><tt class="descname">set_loader</tt><a class="headerlink" href="#importlib.util.set_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> method,
to set the <tt class="xref py py-attr docutils literal"><span class="pre">__loader__</span></tt>
attribute on loaded modules. If the attribute is already set the decorator
does nothing. It is assumed that the first positional argument to the
wrapped method is what <tt class="xref py py-attr docutils literal"><span class="pre">__loader__</span></tt> should be set to.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_package">
<tt class="descclassname">&#64;</tt><tt class="descclassname">importlib.util.</tt><tt class="descname">set_package</tt><a class="headerlink" href="#importlib.util.set_package" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> for a <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> to set the <tt class="xref py py-attr docutils literal"><span class="pre">__package__</span></tt>
attribute on the module returned by the loader. If <tt class="xref py py-attr docutils literal"><span class="pre">__package__</span></tt> is
set and has a value other than <tt class="xref docutils literal"><span class="pre">None</span></tt> it will not be changed.
Note that the module returned by the loader is what has the attribute
set on and not the module found in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>.</p>
<p>Reliance on this decorator is discouraged when it is possible to set
<tt class="xref py py-attr docutils literal"><span class="pre">__package__</span></tt> before the execution of the code is possible. By
setting it before the code for the module is executed it allows the
attribute to be used at the global level of the module during
initialization.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">29.6. <tt class="docutils literal"><span class="pre">importlib</span></tt> &#8211; An implementation of <tt class="docutils literal"><span class="pre">import</span></tt></a><ul>
<li><a class="reference internal" href="#introduction">29.6.1. Introduction</a></li>
<li><a class="reference internal" href="#functions">29.6.2. Functions</a></li>
<li><a class="reference internal" href="#module-importlib.abc">29.6.3. <tt class="docutils literal"><span class="pre">importlib.abc</span></tt> &#8211; Abstract base classes related to import</a></li>
<li><a class="reference internal" href="#module-importlib.machinery">29.6.4. <tt class="docutils literal"><span class="pre">importlib.machinery</span></tt> &#8211; Importers and path hooks</a></li>
<li><a class="reference internal" href="#module-importlib.util">29.6.5. <tt class="docutils literal"><span class="pre">importlib.util</span></tt> &#8211; Utility code for importers</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="runpy.html"
                        title="previous chapter">29.5. <tt class="docutils literal"><span class="pre">runpy</span></tt> &#8212; Locating and executing Python modules</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="language.html"
                        title="next chapter">30. Python Language Services</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/importlib.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="language.html" title="30. Python Language Services"
             >next</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="29.5. runpy — Locating and executing Python modules"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python v3.2 documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="modules.html" >29. Importing Modules</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 27, 2011.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>